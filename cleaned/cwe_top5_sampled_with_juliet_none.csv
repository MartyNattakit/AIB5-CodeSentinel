file,cwe,label,code
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_63b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(char * * dataPtr)
{
    char * data = *dataPtr;
    {
        char source[10+1] = SRC_STRING;
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * * dataPtr)
{
    char * data = *dataPtr;
    {
        char source[10+1] = SRC_STRING;
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_68b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
extern char * var;
extern char * var;
#ifndef OMITBAD
void var()
{
    char * data = var;
    {
        char dest[50] = """";
        strcpy(dest, data);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    char * data = var;
    {
        char dest[50] = """";
        strcpy(dest, data);
        printLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_68a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
char * var;
char * var;
#ifndef OMITBAD
void var();
void var()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    data = dataBadBuffer;
    data[0] = '\0'; 
    var = data;
    var();
}
#endif 
#ifndef OMITGOOD
void var();
static void goodG2B()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    data = dataGoodBuffer;
    data[0] = '\0'; 
    var = data;
    var();
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_02.c,CWE121,good,"#include ""std_testcase.h""
    #include <wchar.h>
    #ifndef OMITBAD
    void var()
    {
        wchar_t * data;
        wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
        wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
        if(1)
        {
            data = dataBadBuffer;
            data[0] = L'\0'; 
        }
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); 
            source[100-1] = L'\0'; 
            wcsncat(data, source, 100);
            printWLine(data);
        }
    }
    #endif 
    #ifndef OMITGOOD
    static void goodG2B1()
    {
        wchar_t * data;
        wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
        wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
        if(0)
        {
            printLine(""Benign, fixed string"");
        }
        else
        {
            data = dataGoodBuffer;
            data[0] = L'\0'; 
        }
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); 
            source[100-1] = L'\0'; 
            wcsncat(data, source, 100);
            printWLine(data);
        }
    }
    static void goodG2B2()
    {
        wchar_t * data;
        wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
        wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
        if(1)
        {
            data = dataGoodBuffer;
            data[0] = L'\0'; 
        }
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); 
            source[100-1] = L'\0'; 
            wcsncat(data, source, 100);
            printWLine(data);
        }
    }
    void var()
    {
        goodG2B1();
        goodG2B2();
    }
    #endif 
    #ifdef INCLUDEMAIN
    int main(int argc, char * argv[])
    {
        srand( (unsigned)time(NULL) );
    #ifndef OMITGOOD
        printLine(""Calling good()..."");
        var();
        printLine(""Finished good()"");
    #endif 
    #ifndef OMITBAD
        printLine(""Calling bad()..."");
        var();
        printLine(""Finished bad()"");
    #endif 
        return 0;
    }
    #endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_31.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            char dest[50] = """";
            size_t i, dataLen;
            dataLen = strlen(data);
            for (i = 0; i < dataLen; i++)
            {
                dest[i] = data[i];
            }
            dest[50-1] = '\0'; 
            printLine(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            char dest[50] = """";
            size_t i, dataLen;
            dataLen = strlen(data);
            for (i = 0; i < dataLen; i++)
            {
                dest[i] = data[i];
            }
            dest[50-1] = '\0'; 
            printLine(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_51a.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * data);
void var()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    data = dataBadBuffer;
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int * data);
static void goodG2B()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    data = dataGoodBuffer;
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_54d.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_12.c,CWE121,bad,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        data = 7;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
    else
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int data;
    data = -1;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
        }
    }
    else
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
        }
    }
}
static void goodG2B()
{
    int data;
    data = -1;
    if(globalReturnsTrueOrFalse())
    {
        data = 7;
    }
    else
    {
        data = 7;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
    else
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_22b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
extern int var;
char * var(char * data)
{
    if(var)
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    return data;
}
#endif 
#ifndef OMITGOOD
extern int var;
extern int var;
char * var(char * data)
{
    if(var)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    return data;
}
char * var(char * data)
{
    if(var)
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    return data;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_07.c,CWE121,bad,"#include ""std_testcase.h""
static int staticFive = 5;
#ifndef OMITBAD
void var()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    if(staticFive==5)
    {
        data = dataBadBuffer;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
static void goodG2B2()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    if(staticFive==5)
    {
        data = dataGoodBuffer;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_41.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * data)
{
    {
        int source[100] = {0}; 
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
void var()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    data = dataBadBuffer;
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int * data)
{
    {
        int source[100] = {0}; 
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
static void goodG2B()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    data = dataGoodBuffer;
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_52a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
static void goodG2B()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_68b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
extern wchar_t * var;
extern wchar_t * var;
#ifndef OMITBAD
void var()
{
    wchar_t * data = var;
    {
        wchar_t dest[50] = L"""";
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    wchar_t * data = var;
    {
        wchar_t dest[50] = L"""";
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_52a.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var(wchar_t * data);
void var()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    data = dataBadBuffer;
    data[0] = L'\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_53c.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_63a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var(wchar_t * * dataPtr);
void var()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_18.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    goto source;
source:
    data = dataBadBuffer;
    data[0] = '\0'; 
    {
        char source[10+1] = SRC_STRING;
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    goto source;
source:
    data = dataGoodBuffer;
    data[0] = '\0'; 
    {
        char source[10+1] = SRC_STRING;
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_05.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void var()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    if(staticTrue)
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    {
        char dest[50] = """";
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    if(staticTrue)
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_53b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_53d.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF swprintf
#endif
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_04.c,CWE121,good,"#include ""std_testcase.h""
static const int STATIC_CONST_TRUE = 1; 
static const int STATIC_CONST_FALSE = 0; 
#ifndef OMITBAD
void var()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    if(STATIC_CONST_TRUE)
    {
        data = dataBadBuffer;
    }
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
    }
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
static void goodG2B2()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    if(STATIC_CONST_TRUE)
    {
        data = dataGoodBuffer;
    }
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_17.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    int i;
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    for(i = 0; i < 1; i++)
    {
        data = dataBadBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncpy(data, source, 100-1);
        data[100-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int h;
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    for(h = 0; h < 1; h++)
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncpy(data, source, 100-1);
        data[100-1] = L'\0'; 
        printWLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_32.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t * data;
    int64_t * *dataPtr1 = &data;
    int64_t * *dataPtr2 = &data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    {
        int64_t * data = *dataPtr1;
        data = dataBadBuffer;
        *dataPtr1 = data;
    }
    {
        int64_t * data = *dataPtr2;
        {
            int64_t source[100] = {0}; 
            memcpy(data, source, 100*sizeof(int64_t));
            printLongLongLine(data[0]);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int64_t * data;
    int64_t * *dataPtr1 = &data;
    int64_t * *dataPtr2 = &data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    {
        int64_t * data = *dataPtr1;
        data = dataGoodBuffer;
        *dataPtr1 = data;
    }
    {
        int64_t * data = *dataPtr2;
        {
            int64_t source[100] = {0}; 
            memcpy(data, source, 100*sizeof(int64_t));
            printLongLongLine(data[0]);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_64b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    char * * dataPtr = (char * *)dataVoidPtr;
    char * data = (*dataPtr);
    {
        char dest[50] = """";
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    char * * dataPtr = (char * *)dataVoidPtr;
    char * data = (*dataPtr);
    {
        char dest[50] = """";
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_53a.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(twoIntsStruct * data);
void var()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    data = dataBadBuffer;
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(twoIntsStruct * data);
static void goodG2B()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    data = dataGoodBuffer;
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_45.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
static wchar_t * var;
static wchar_t * var;
#ifndef OMITBAD
static void badSink()
{
    wchar_t * data = var;
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
void var()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    wchar_t * data = var;
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    var = data;
    goodG2BSink();
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_44.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
static void badSink(char * data)
{
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; 
        printLine(data);
    }
}
void var()
{
    char * data;
    void (*funcPtr) (char *) = badSink;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    data = dataBadBuffer;
    data[0] = '\0'; 
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(char * data)
{
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; 
        printLine(data);
    }
}
static void goodG2B()
{
    char * data;
    void (*funcPtr) (char *) = goodG2BSink;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    data = dataGoodBuffer;
    data[0] = '\0'; 
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_52b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_66b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscat(data, source);
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscat(data, source);
        printWLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_63a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var(char * * dataPtr);
void var()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBadBuffer;
    data[0] = '\0'; 
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(char * * data);
static void goodG2B()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataGoodBuffer;
    data[0] = '\0'; 
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_02.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(1)
    {
        data = dataBadBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(1)
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_31.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            char dest[50] = """";
            memcpy(dest, data, strlen(data)*sizeof(char));
            dest[50-1] = '\0'; 
            printLine(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            char dest[50] = """";
            memcpy(dest, data, strlen(data)*sizeof(char));
            dest[50-1] = '\0'; 
            printLine(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_66b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_61a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
wchar_t * var(wchar_t * data);
void var()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    data = var(data);
    {
        wchar_t dest[50] = L"""";
        memmove(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
wchar_t * var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    data = var(data);
    {
        wchar_t dest[50] = L"""";
        memmove(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_34.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
typedef union
{
    char * unionFirst;
    char * unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    char * data;
    var myUnion;
    char dataBuffer[100];
    data = dataBuffer;
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char dest[50] = """";
            memcpy(dest, data, strlen(data)*sizeof(char));
            dest[50-1] = '\0'; 
            printLine(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    var myUnion;
    char dataBuffer[100];
    data = dataBuffer;
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char dest[50] = """";
            memcpy(dest, data, strlen(data)*sizeof(char));
            dest[50-1] = '\0'; 
            printLine(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_17.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    int i;
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    for(i = 0; i < 1; i++)
    {
        data = dataBadBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memmove(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int h;
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    for(h = 0; h < 1; h++)
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memmove(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_66b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * dataArray[])
{
    char * data = dataArray[2];
    {
        char dest[50] = """";
        size_t i, dataLen;
        dataLen = strlen(data);
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * dataArray[])
{
    char * data = dataArray[2];
    {
        char dest[50] = """";
        size_t i, dataLen;
        dataLen = strlen(data);
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_53c.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE129_large_13.c,CWE121,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = 10;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = -1;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = 10;
    }
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
        }
    }
}
static void goodB2G2()
{
    int data;
    data = -1;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = 10;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
        }
    }
}
static void goodG2B1()
{
    int data;
    data = -1;
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 7;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
static void goodG2B2()
{
    int data;
    data = -1;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = 7;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_15.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    switch(6)
    {
    case 6:
        data = dataBadBuffer;
        data[0] = L'\0'; 
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        data = dataGoodBuffer;
        data[0] = L'\0'; 
        break;
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    switch(6)
    {
    case 6:
        data = dataGoodBuffer;
        data[0] = L'\0'; 
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_65b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(twoIntsStruct * data)
{
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
#endif 
#ifndef OMITGOOD
void var(twoIntsStruct * data)
{
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_67a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
typedef struct _CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_67_structType
{
    char * structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct);
void var()
{
    char * data;
    var myStruct;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    data = dataBadBuffer;
    data[0] = '\0'; 
    myStruct.structFirst = data;
    var(myStruct);
}
#endif 
#ifndef OMITGOOD
void var(var myStruct);
static void goodG2B()
{
    char * data;
    var myStruct;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    data = dataGoodBuffer;
    data[0] = '\0'; 
    myStruct.structFirst = data;
    var(myStruct);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
int var = 0;
char * var(char * data);
void var()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    var = 1; 
    data = var(data);
    {
        char dest[50] = """";
        strcat(dest, data);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
int var = 0;
int var = 0;
char * var(char * data);
static void goodG2B1()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    var = 0; 
    data = var(data);
    {
        char dest[50] = """";
        strcat(dest, data);
        printLine(data);
    }
}
char * var(char * data);
static void goodG2B2()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    var = 1; 
    data = var(data);
    {
        char dest[50] = """";
        strcat(dest, data);
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_54c.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_18.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    goto source;
source:
    data = dataBadBuffer;
    {
        int source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    goto source;
source:
    data = dataGoodBuffer;
    {
        int source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_17.c,CWE121,bad,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    int i;
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    for(i = 0; i < 1; i++)
    {
        data = dataBadBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = wcslen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int h;
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    for(h = 0; h < 1; h++)
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = wcslen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printWLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_54e.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(twoIntsStruct * data)
{
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
#endif 
#ifndef OMITGOOD
void var(twoIntsStruct * data)
{
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_68a.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
wchar_t * var;
wchar_t * var;
#ifndef OMITBAD
void var();
void var()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    data = dataBadBuffer;
    data[0] = L'\0'; 
    var = data;
    var();
}
#endif 
#ifndef OMITGOOD
void var();
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    var = data;
    var();
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_67a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif
typedef struct _CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_67_structType
{
    char * structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct);
void var()
{
    char * data;
    var myStruct;
    char dataBuffer[100];
    data = dataBuffer;
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    myStruct.structFirst = data;
    var(myStruct);
}
#endif 
#ifndef OMITGOOD
void var(var myStruct);
static void goodG2B()
{
    char * data;
    var myStruct;
    char dataBuffer[100];
    data = dataBuffer;
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    myStruct.structFirst = data;
    var(myStruct);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE135_34.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#define WIDE_STRING L""AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA""
#define CHAR_STRING ""AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA""
typedef union
{
    void * unionFirst;
    void * unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    void * data;
    var myUnion;
    data = NULL;
    data = (void *)WIDE_STRING;
    myUnion.unionFirst = data;
    {
        void * data = myUnion.unionSecond;
        {
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
            (void)wcscpy(dest, data);
            printLine((char *)dest);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    void * data;
    var myUnion;
    data = NULL;
    data = (void *)CHAR_STRING;
    myUnion.unionFirst = data;
    {
        void * data = myUnion.unionSecond;
        {
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
            printLine((char *)dest);
        }
    }
}
static void goodB2G()
{
    void * data;
    var myUnion;
    data = NULL;
    data = (void *)WIDE_STRING;
    myUnion.unionFirst = data;
    {
        void * data = myUnion.unionSecond;
        {
            size_t dataLen = wcslen((wchar_t *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
            (void)wcscpy(dest, data);
            printWLine((wchar_t *)dest);
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_66a.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(char * dataArray[]);
void var()
{
    char * data;
    char * dataArray[5];
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    data = dataBadBuffer;
    data[0] = '\0'; 
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(char * dataArray[]);
static void goodG2B()
{
    char * data;
    char * dataArray[5];
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    data = dataGoodBuffer;
    data[0] = '\0'; 
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_61b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
char * var(char * data)
{
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    return data;
}
#endif 
#ifndef OMITGOOD
char * var(char * data)
{
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    return data;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_31.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF swprintf
#endif
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBadBuffer;
    data[0] = L'\0'; 
    {
        wchar_t * dataCopy = data;
        wchar_t * data = dataCopy;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); 
            source[100-1] = L'\0'; 
            SNPRINTF(data, 100, L""%s"", source);
            printWLine(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    {
        wchar_t * dataCopy = data;
        wchar_t * data = dataCopy;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); 
            source[100-1] = L'\0'; 
            SNPRINTF(data, 100, L""%s"", source);
            printWLine(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_53c.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_09.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_67b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
typedef struct _CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_67_structType
{
    char * structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct)
{
    char * data = myStruct.structFirst;
    {
        char dest[50] = """";
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(var myStruct)
{
    char * data = myStruct.structFirst;
    {
        char dest[50] = """";
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_18.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    goto source;
source:
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    {
        char dest[50] = """";
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    goto source;
source:
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    {
        char dest[50] = """";
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_63b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    {
        wchar_t dest[50] = L"""";
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    {
        wchar_t dest[50] = L"""";
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_31.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    data = dataBadBuffer;
    data[0] = '\0'; 
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            char source[100];
            memset(source, 'C', 100-1); 
            source[100-1] = '\0'; 
            memmove(data, source, 100*sizeof(char));
            data[100-1] = '\0'; 
            printLine(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    data = dataGoodBuffer;
    data[0] = '\0'; 
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            char source[100];
            memset(source, 'C', 100-1); 
            source[100-1] = '\0'; 
            memmove(data, source, 100*sizeof(char));
            data[100-1] = '\0'; 
            printLine(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_51a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var(char * data);
void var()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
static void goodG2B()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_12.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF swprintf
#endif
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    if(globalReturnsTrueOrFalse())
    {
        data = dataBadBuffer;
        data[0] = L'\0'; 
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    if(globalReturnsTrueOrFalse())
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_13.c,CWE121,bad,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STR ""0123456789abcdef0123456789abcde""
typedef struct _charVoid
{
    char charFirst[16];
    void * voidSecond;
    void * voidThird;
} charVoid;
#ifndef OMITBAD
void var()
{
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            printLine((char *)structCharVoid.voidSecond);
            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; 
            printLine((char *)structCharVoid.charFirst);
            printLine((char *)structCharVoid.voidSecond);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void good1()
{
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            printLine((char *)structCharVoid.voidSecond);
            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; 
            printLine((char *)structCharVoid.charFirst);
            printLine((char *)structCharVoid.voidSecond);
        }
    }
}
static void good2()
{
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            printLine((char *)structCharVoid.voidSecond);
            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; 
            printLine((char *)structCharVoid.charFirst);
            printLine((char *)structCharVoid.voidSecond);
        }
    }
}
void var()
{
    good1();
    good2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_08.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    if(staticReturnsTrue())
    {
        data = dataBadBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    if(staticReturnsTrue())
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_53b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_54d.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_52b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_54b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * data);
void var(int64_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t * data);
void var(int64_t * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_63b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memmove(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memmove(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_01.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBadBuffer;
    data[0] = L'\0'; 
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memmove(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memmove(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_04.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
static const int STATIC_CONST_TRUE = 1; 
static const int STATIC_CONST_FALSE = 0; 
#ifndef OMITBAD
void var()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    if(STATIC_CONST_TRUE)
    {
        data = dataBadBuffer;
        data[0] = '\0'; 
    }
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    if(STATIC_CONST_TRUE)
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_53d.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(char * data)
{
    {
        char source[10+1] = SRC_STRING;
        strcpy(data, source);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * data)
{
    {
        char source[10+1] = SRC_STRING;
        strcpy(data, source);
        printLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_66b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * dataArray[])
{
    char * data = dataArray[2];
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * dataArray[])
{
    char * data = dataArray[2];
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; 
        printLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_65a.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * data);
void var()
{
    int64_t * data;
    void (*funcPtr) (int64_t *) = var;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    data = dataBadBuffer;
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t * data);
static void goodG2B()
{
    int64_t * data;
    void (*funcPtr) (int64_t *) = var;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    data = dataGoodBuffer;
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_52b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_12.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    if(globalReturnsTrueOrFalse())
    {
        data = dataBadBuffer;
    }
    else
    {
        data = dataGoodBuffer;
    }
    {
        int source[100] = {0}; 
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    if(globalReturnsTrueOrFalse())
    {
        data = dataGoodBuffer;
    }
    else
    {
        data = dataGoodBuffer;
    }
    {
        int source[100] = {0}; 
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_54d.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_65a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var()
{
    char * data;
    void (*funcPtr) (char *) = var;
    char dataBuffer[100];
    data = dataBuffer;
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
static void goodG2B()
{
    char * data;
    void (*funcPtr) (char *) = var;
    char dataBuffer[100];
    data = dataBuffer;
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_42.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF swprintf
#endif
#ifndef OMITBAD
static wchar_t * badSource(wchar_t * data)
{
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    return data;
}
void var()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    data = badSource(data);
    {
        wchar_t dest[50] = L"""";
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static wchar_t * goodG2BSource(wchar_t * data)
{
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    return data;
}
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    data = goodG2BSource(data);
    {
        wchar_t dest[50] = L"""";
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_54d.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * data);
void var(int64_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t * data);
void var(int64_t * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_53a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_02.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(1)
    {
        data = dataBadBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = wcslen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = wcslen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printWLine(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(1)
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = wcslen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printWLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_15.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    switch(6)
    {
    case 6:
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        char dest[50] = """";
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
        break;
    }
    {
        char dest[50] = """";
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    switch(6)
    {
    case 6:
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        char dest[50] = """";
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_52b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_34.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
typedef union
{
    wchar_t * unionFirst;
    wchar_t * unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    var myUnion;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBadBuffer;
    data[0] = L'\0'; 
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); 
            source[100-1] = L'\0'; 
            memmove(data, source, 100*sizeof(wchar_t));
            data[100-1] = L'\0'; 
            printWLine(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    var myUnion;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); 
            source[100-1] = L'\0'; 
            memmove(data, source, 100*sizeof(wchar_t));
            data[100-1] = L'\0'; 
            printWLine(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_34.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
typedef union
{
    wchar_t * unionFirst;
    wchar_t * unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    var myUnion;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    data = dataBadBuffer;
    data[0] = L'\0'; 
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t source[10+1] = SRC_STRING;
            memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
            printWLine(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    var myUnion;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t source[10+1] = SRC_STRING;
            memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
            printWLine(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_44.c,CWE121,bad,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
static void badSink(int data)
{
    {
        int i;
        int buffer[10] = { 0 };
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
    }
}
void var()
{
    int data;
    void (*funcPtr) (int) = badSink;
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(int data)
{
    {
        int i;
        int buffer[10] = { 0 };
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
    }
}
static void goodG2B()
{
    int data;
    void (*funcPtr) (int) = goodG2BSink;
    data = -1;
    data = 7;
    funcPtr(data);
}
static void goodB2GSink(int data)
{
    {
        int i;
        int buffer[10] = { 0 };
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
    }
}
static void goodB2G()
{
    int data;
    void (*funcPtr) (int) = goodB2GSink;
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_44.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
static void badSink(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncpy(data, source, 100-1);
        data[100-1] = L'\0'; 
        printWLine(data);
    }
}
void var()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = badSink;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBadBuffer;
    data[0] = L'\0'; 
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncpy(data, source, 100-1);
        data[100-1] = L'\0'; 
        printWLine(data);
    }
}
static void goodG2B()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = goodG2BSink;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_53d.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncpy(data, source, 100-1);
        data[100-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncpy(data, source, 100-1);
        data[100-1] = L'\0'; 
        printWLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_65b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data)
{
    {
        char dest[50] = """";
        size_t i, dataLen;
        dataLen = strlen(data);
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * data)
{
    {
        char dest[50] = """";
        size_t i, dataLen;
        dataLen = strlen(data);
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_51b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        wchar_t source[10+1] = SRC_STRING;
        wcscpy(data, source);
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        wchar_t source[10+1] = SRC_STRING;
        wcscpy(data, source);
        printWLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_10.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(globalTrue)
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strcpy(dest, data);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strcpy(dest, data);
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(globalTrue)
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strcpy(dest, data);
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_64b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    char * * dataPtr = (char * *)dataVoidPtr;
    char * data = (*dataPtr);
    {
        char dest[50] = """";
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    char * * dataPtr = (char * *)dataVoidPtr;
    char * data = (*dataPtr);
    {
        char dest[50] = """";
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_32.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    {
        wchar_t * data = *dataPtr1;
        data = dataBadBuffer;
        data[0] = L'\0'; 
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            wchar_t source[10+1] = SRC_STRING;
            wcsncpy(data, source, wcslen(source) + 1);
            printWLine(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    {
        wchar_t * data = *dataPtr1;
        data = dataGoodBuffer;
        data[0] = L'\0'; 
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            wchar_t source[10+1] = SRC_STRING;
            wcsncpy(data, source, wcslen(source) + 1);
            printWLine(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_54d.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_32.c,CWE121,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    data = -1;
    {
        int data = *dataPtr1;
        data = RAND32();
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    data = -1;
    {
        int data = *dataPtr1;
        data = 7;
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
static void goodB2G()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    data = -1;
    {
        int data = *dataPtr1;
        data = RAND32();
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_63a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * * dataPtr);
void var()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    data = dataBadBuffer;
    data[0] = '\0'; 
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(char * * data);
static void goodG2B()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    data = dataGoodBuffer;
    data[0] = '\0'; 
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_53a.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * data);
void var()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    data = dataBadBuffer;
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int * data);
static void goodG2B()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    data = dataGoodBuffer;
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_31.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBadBuffer;
    data[0] = L'\0'; 
    {
        wchar_t * dataCopy = data;
        wchar_t * data = dataCopy;
        {
            size_t i;
            wchar_t source[100];
            wmemset(source, L'C', 100-1); 
            source[100-1] = L'\0'; 
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            data[100-1] = L'\0'; 
            printWLine(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    {
        wchar_t * dataCopy = data;
        wchar_t * data = dataCopy;
        {
            size_t i;
            wchar_t source[100];
            wmemset(source, L'C', 100-1); 
            source[100-1] = L'\0'; 
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            data[100-1] = L'\0'; 
            printWLine(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_65a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var(wchar_t * data);
void var()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = var;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = var;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_31.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    data = dataBadBuffer;
    data[0] = '\0'; 
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            char source[10+1] = SRC_STRING;
            memmove(data, source, (strlen(source) + 1) * sizeof(char));
            printLine(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    data = dataGoodBuffer;
    data[0] = '\0'; 
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            char source[10+1] = SRC_STRING;
            memmove(data, source, (strlen(source) + 1) * sizeof(char));
            printLine(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_18.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    goto source;
source:
    data = dataBadBuffer;
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    goto source;
source:
    data = dataGoodBuffer;
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_05.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    if(staticTrue)
    {
        data = dataBadBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscpy(data, source);
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscpy(data, source);
        printWLine(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    if(staticTrue)
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscpy(data, source);
        printWLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_68a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
char * var;
char * var;
#ifndef OMITBAD
void var();
void var()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBadBuffer;
    data[0] = '\0'; 
    var = data;
    var();
}
#endif 
#ifndef OMITGOOD
void var();
static void goodG2B()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataGoodBuffer;
    data[0] = '\0'; 
    var = data;
    var();
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_61a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
char * var(char * data);
void var()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    data = var(data);
    {
        char dest[50] = """";
        strcat(dest, data);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
char * var(char * data);
static void goodG2B()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    data = var(data);
    {
        char dest[50] = """";
        strcat(dest, data);
        printLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_63a.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(char * * dataPtr);
void var()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    data = dataBadBuffer;
    data[0] = '\0'; 
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(char * * data);
static void goodG2B()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    data = dataGoodBuffer;
    data[0] = '\0'; 
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_52c.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data)
{
    {
        char dest[50] = """";
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * data)
{
    {
        char dest[50] = """";
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_65a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = var;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBadBuffer;
    data[0] = L'\0'; 
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = var;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_53d.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(char * data)
{
    {
        char source[10+1] = SRC_STRING;
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * data)
{
    {
        char source[10+1] = SRC_STRING;
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_53c.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_54b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_34.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
typedef union
{
    wchar_t * unionFirst;
    wchar_t * unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    var myUnion;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t dest[50] = L"""";
            memmove(dest, data, wcslen(data)*sizeof(wchar_t));
            dest[50-1] = L'\0'; 
            printWLine(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    var myUnion;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t dest[50] = L"""";
            memmove(dest, data, wcslen(data)*sizeof(wchar_t));
            dest[50-1] = L'\0'; 
            printWLine(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_07.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
static int staticFive = 5;
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    if(staticFive==5)
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    if(staticFive==5)
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_16.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    while(1)
    {
        data = dataBadBuffer;
        data[0] = '\0'; 
        break;
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcpy(data, source);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    while(1)
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
        break;
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcpy(data, source);
        printLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_63a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * * dataPtr);
void var()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_45.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
static char * var;
static char * var;
#ifndef OMITBAD
static void badSink()
{
    char * data = var;
    {
        char dest[50] = """";
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
void var()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    char * data = var;
    {
        char dest[50] = """";
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
static void goodG2B()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    var = data;
    goodG2BSink();
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_52c.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * data)
{
    {
        int64_t source[100] = {0}; 
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
#endif 
#ifndef OMITGOOD
void var(int64_t * data)
{
    {
        int64_t source[100] = {0}; 
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_54c.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
extern int var;
char * var(char * data)
{
    if(var)
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    return data;
}
#endif 
#ifndef OMITGOOD
extern int var;
extern int var;
char * var(char * data)
{
    if(var)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    return data;
}
char * var(char * data)
{
    if(var)
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    return data;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_08.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STR ""0123456789abcdef0123456789abcde""
typedef struct _charVoid
{
    char charFirst[16];
    void * voidSecond;
    void * voidThird;
} charVoid;
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    if(staticReturnsTrue())
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            printLine((char *)structCharVoid.voidSecond);
            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; 
            printLine((char *)structCharVoid.charFirst);
            printLine((char *)structCharVoid.voidSecond);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void good1()
{
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            printLine((char *)structCharVoid.voidSecond);
            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; 
            printLine((char *)structCharVoid.charFirst);
            printLine((char *)structCharVoid.voidSecond);
        }
    }
}
static void good2()
{
    if(staticReturnsTrue())
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            printLine((char *)structCharVoid.voidSecond);
            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; 
            printLine((char *)structCharVoid.charFirst);
            printLine((char *)structCharVoid.voidSecond);
        }
    }
}
void var()
{
    good1();
    good2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_10.c,CWE121,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    if(globalTrue)
    {
        data = dataBadBuffer;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
static void goodG2B2()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    if(globalTrue)
    {
        data = dataGoodBuffer;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_17.c,CWE121,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int i;
    int * data;
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        data = (int *)ALLOCA(10);
    }
    {
        int source[10] = {0};
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int h;
    int * data;
    data = NULL;
    for(h = 0; h < 1; h++)
    {
        data = (int *)ALLOCA(10*sizeof(int));
    }
    {
        int source[10] = {0};
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_06.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    {
        char dest[50] = """";
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_53d.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var(char * data)
{
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * data)
{
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_10.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(globalTrue)
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(globalTrue)
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_15.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    switch(6)
    {
    case 6:
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        char dest[50] = """";
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
        break;
    }
    {
        char dest[50] = """";
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    switch(6)
    {
    case 6:
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        char dest[50] = """";
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_06.c,CWE121,good,"#include ""std_testcase.h""
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    if(STATIC_CONST_FIVE==5)
    {
        data = dataBadBuffer;
    }
    {
        int64_t source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
    }
    {
        int64_t source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
        }
    }
}
static void goodG2B2()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    if(STATIC_CONST_FIVE==5)
    {
        data = dataGoodBuffer;
    }
    {
        int64_t source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
        }
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_16.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    while(1)
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
        break;
    }
    {
        wchar_t dest[50] = L"""";
        wcscat(dest, data);
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    while(1)
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
        break;
    }
    {
        wchar_t dest[50] = L"""";
        wcscat(dest, data);
        printWLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_41.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        memmove(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
void var()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        memmove(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_34.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
typedef union
{
    wchar_t * unionFirst;
    wchar_t * unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    var myUnion;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBadBuffer;
    data[0] = L'\0'; 
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); 
            source[100-1] = L'\0'; 
            memcpy(data, source, 100*sizeof(wchar_t));
            data[100-1] = L'\0'; 
            printWLine(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    var myUnion;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); 
            source[100-1] = L'\0'; 
            memcpy(data, source, 100*sizeof(wchar_t));
            data[100-1] = L'\0'; 
            printWLine(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_68a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
char * var;
char * var;
#ifndef OMITBAD
void var();
void var()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBadBuffer;
    data[0] = '\0'; 
    var = data;
    var();
}
#endif 
#ifndef OMITGOOD
void var();
static void goodG2B()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataGoodBuffer;
    data[0] = '\0'; 
    var = data;
    var();
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_31.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    data = dataBadBuffer;
    {
        int64_t * dataCopy = data;
        int64_t * data = dataCopy;
        {
            int64_t source[100] = {0}; 
            memmove(data, source, 100*sizeof(int64_t));
            printLongLongLine(data[0]);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    data = dataGoodBuffer;
    {
        int64_t * dataCopy = data;
        int64_t * data = dataCopy;
        {
            int64_t source[100] = {0}; 
            memmove(data, source, 100*sizeof(int64_t));
            printLongLongLine(data[0]);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_06.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STR L""0123456789abcdef0123456789abcde""
typedef struct _charVoid
{
    wchar_t charFirst[16];
    void * voidSecond;
    void * voidThird;
} charVoid;
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    if(STATIC_CONST_FIVE==5)
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            printWLine((wchar_t *)structCharVoid.voidSecond);
            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\0'; 
            printWLine((wchar_t *)structCharVoid.charFirst);
            printWLine((wchar_t *)structCharVoid.voidSecond);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void good1()
{
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            printWLine((wchar_t *)structCharVoid.voidSecond);
            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\0'; 
            printWLine((wchar_t *)structCharVoid.charFirst);
            printWLine((wchar_t *)structCharVoid.voidSecond);
        }
    }
}
static void good2()
{
    if(STATIC_CONST_FIVE==5)
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            printWLine((wchar_t *)structCharVoid.voidSecond);
            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\0'; 
            printWLine((wchar_t *)structCharVoid.charFirst);
            printWLine((wchar_t *)structCharVoid.voidSecond);
        }
    }
}
void var()
{
    good1();
    good2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_68a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
wchar_t * var;
wchar_t * var;
#ifndef OMITBAD
void var();
void var()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    var = data;
    var();
}
#endif 
#ifndef OMITGOOD
void var();
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    var = data;
    var();
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_52c.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data)
{
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncat(data, source, 100);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * data)
{
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncat(data, source, 100);
        printLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_16.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    while(1)
    {
        data = dataBadBuffer;
        data[0] = '\0'; 
        break;
    }
    {
        char source[10+1] = SRC_STRING;
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    while(1)
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
        break;
    }
    {
        char source[10+1] = SRC_STRING;
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_45.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
static wchar_t * var;
static wchar_t * var;
#ifndef OMITBAD
static void badSink()
{
    wchar_t * data = var;
    {
        wchar_t source[10+1] = SRC_STRING;
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
void var()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    data = dataBadBuffer;
    data[0] = L'\0'; 
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    wchar_t * data = var;
    {
        wchar_t source[10+1] = SRC_STRING;
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    var = data;
    goodG2BSink();
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_63b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * dataPtr)
{
    int data = *dataPtr;
    {
        int i;
        int buffer[10] = { 0 };
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
    }
}
#endif 
#ifndef OMITGOOD
void var(int * dataPtr)
{
    int data = *dataPtr;
    {
        int i;
        int buffer[10] = { 0 };
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
    }
}
void var(int * dataPtr)
{
    int data = *dataPtr;
    {
        int i;
        int buffer[10] = { 0 };
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_21.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
static int badStatic = 0;
static wchar_t * badSource(wchar_t * data)
{
    if(badStatic)
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
    }
    return data;
}
void var()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    badStatic = 1; 
    data = badSource(data);
    {
        wchar_t dest[50] = L"""";
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static int goodG2B1Static = 0;
static int goodG2B2Static = 0;
static wchar_t * goodG2B1Source(wchar_t * data)
{
    if(goodG2B1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    return data;
}
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    goodG2B1Static = 0; 
    data = goodG2B1Source(data);
    {
        wchar_t dest[50] = L"""";
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
static wchar_t * goodG2B2Source(wchar_t * data)
{
    if(goodG2B2Static)
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    return data;
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    goodG2B2Static = 1; 
    data = goodG2B2Source(data);
    {
        wchar_t dest[50] = L"""";
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_65a.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * data);
void var()
{
    int64_t * data;
    void (*funcPtr) (int64_t *) = var;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    data = dataBadBuffer;
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t * data);
static void goodG2B()
{
    int64_t * data;
    void (*funcPtr) (int64_t *) = var;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    data = dataGoodBuffer;
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_13.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    if(GLOBAL_CONST_FIVE==5)
    {
        data = dataBadBuffer;
        data[0] = '\0'; 
    }
    {
        char source[10+1] = SRC_STRING;
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[10+1] = SRC_STRING;
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    if(GLOBAL_CONST_FIVE==5)
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[10+1] = SRC_STRING;
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_52a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    data = dataBadBuffer;
    data[0] = L'\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_52a.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(char * data);
void var()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    data = dataBadBuffer;
    data[0] = '\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
static void goodG2B()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    data = dataGoodBuffer;
    data[0] = '\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_65a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = var;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    data = dataBadBuffer;
    data[0] = L'\0'; 
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = var;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_10.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(globalTrue)
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(globalTrue)
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_31.c,CWE121,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    fscanf(stdin, ""%d"", &data);
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int data;
    data = -1;
    data = 7;
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
static void goodB2G()
{
    int data;
    data = -1;
    fscanf(stdin, ""%d"", &data);
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_51a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    data = dataBadBuffer;
    data[0] = '\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
static void goodG2B()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    data = dataGoodBuffer;
    data[0] = '\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_45.c,CWE121,bad,"#include ""std_testcase.h""
static twoIntsStruct * var;
static twoIntsStruct * var;
#ifndef OMITBAD
static void badSink()
{
    twoIntsStruct * data = var;
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printStructLine(&data[0]);
        }
    }
}
void var()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    data = dataBadBuffer;
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    twoIntsStruct * data = var;
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printStructLine(&data[0]);
        }
    }
}
static void goodG2B()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    data = dataGoodBuffer;
    var = data;
    goodG2BSink();
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_66b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * dataArray[])
{
    int * data = dataArray[2];
    {
        int source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
        }
    }
}
#endif 
#ifndef OMITGOOD
void var(int * dataArray[])
{
    int * data = dataArray[2];
    {
        int source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
        }
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_66a.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(char * dataArray[]);
void var()
{
    char * data;
    char * dataArray[5];
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    data = dataBadBuffer;
    data[0] = '\0'; 
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(char * dataArray[]);
static void goodG2B()
{
    char * data;
    char * dataArray[5];
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    data = dataGoodBuffer;
    data[0] = '\0'; 
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_53b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_63b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * * dataPtr)
{
    int64_t * data = *dataPtr;
    {
        int64_t source[100] = {0}; 
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
#endif 
#ifndef OMITGOOD
void var(int64_t * * dataPtr)
{
    int64_t * data = *dataPtr;
    {
        int64_t source[100] = {0}; 
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_04.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif
static const int STATIC_CONST_TRUE = 1; 
static const int STATIC_CONST_FALSE = 0; 
#ifndef OMITBAD
void var()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_18.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    goto source;
source:
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    {
        char dest[50] = """";
        strcpy(dest, data);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    goto source;
source:
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    {
        char dest[50] = """";
        strcpy(dest, data);
        printLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_32.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    {
        char * data = *dataPtr1;
        data = dataBadBuffer;
        data[0] = '\0'; 
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char source[100];
            memset(source, 'C', 100-1); 
            source[100-1] = '\0'; 
            SNPRINTF(data, 100, ""%s"", source);
            printLine(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    {
        char * data = *dataPtr1;
        data = dataGoodBuffer;
        data[0] = '\0'; 
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char source[100];
            memset(source, 'C', 100-1); 
            source[100-1] = '\0'; 
            SNPRINTF(data, 100, ""%s"", source);
            printLine(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_17.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    int i;
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int h;
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    for(h = 0; h < 1; h++)
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_01.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_14.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    if(globalFive==5)
    {
        data = dataBadBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    if(globalFive==5)
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_41.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * data)
{
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
void var()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    data = dataBadBuffer;
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t * data)
{
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
static void goodG2B()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    data = dataGoodBuffer;
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_68b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
extern wchar_t * var;
extern wchar_t * var;
#ifndef OMITBAD
void var()
{
    wchar_t * data = var;
    {
        wchar_t source[10+1] = SRC_STRING;
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    wchar_t * data = var;
    {
        wchar_t source[10+1] = SRC_STRING;
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_53a.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * data);
void var()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    data = dataBadBuffer;
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t * data);
static void goodG2B()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    data = dataGoodBuffer;
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_45.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
static char * var;
static char * var;
#ifndef OMITBAD
static void badSink()
{
    char * data = var;
    {
        char dest[50] = """";
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
void var()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    char * data = var;
    {
        char dest[50] = """";
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
static void goodG2B()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    var = data;
    goodG2BSink();
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_63a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * * dataPtr);
void var()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_22b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
extern int var;
wchar_t * var(wchar_t * data)
{
    if(var)
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
    }
    return data;
}
#endif 
#ifndef OMITGOOD
extern int var;
extern int var;
wchar_t * var(wchar_t * data)
{
    if(var)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    return data;
}
wchar_t * var(wchar_t * data)
{
    if(var)
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    return data;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_64b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    char * * dataPtr = (char * *)dataVoidPtr;
    char * data = (*dataPtr);
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    char * * dataPtr = (char * *)dataVoidPtr;
    char * data = (*dataPtr);
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_53a.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var(wchar_t * data);
void var()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    data = dataBadBuffer;
    data[0] = L'\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_34.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
typedef union
{
    char * unionFirst;
    char * unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    char * data;
    var myUnion;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBadBuffer;
    data[0] = '\0'; 
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char source[100];
            memset(source, 'C', 100-1); 
            source[100-1] = '\0'; 
            strcpy(data, source);
            printLine(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    var myUnion;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataGoodBuffer;
    data[0] = '\0'; 
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char source[100];
            memset(source, 'C', 100-1); 
            source[100-1] = '\0'; 
            strcpy(data, source);
            printLine(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_61b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
char * var(char * data)
{
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    return data;
}
#endif 
#ifndef OMITGOOD
char * var(char * data)
{
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    return data;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_53c.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(twoIntsStruct * data);
void var(twoIntsStruct * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(twoIntsStruct * data);
void var(twoIntsStruct * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_12.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    if(globalReturnsTrueOrFalse())
    {
        data = dataBadBuffer;
    }
    else
    {
        data = dataGoodBuffer;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printStructLine(&data[0]);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    if(globalReturnsTrueOrFalse())
    {
        data = dataGoodBuffer;
    }
    else
    {
        data = dataGoodBuffer;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printStructLine(&data[0]);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_51b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_54c.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE129_large_03.c,CWE121,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    if(5==5)
    {
        data = 10;
    }
    if(5==5)
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = -1;
    if(5==5)
    {
        data = 10;
    }
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
        }
    }
}
static void goodB2G2()
{
    int data;
    data = -1;
    if(5==5)
    {
        data = 10;
    }
    if(5==5)
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
        }
    }
}
static void goodG2B1()
{
    int data;
    data = -1;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 7;
    }
    if(5==5)
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
static void goodG2B2()
{
    int data;
    data = -1;
    if(5==5)
    {
        data = 7;
    }
    if(5==5)
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_06.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    if(STATIC_CONST_FIVE==5)
    {
        data = dataBadBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    if(STATIC_CONST_FIVE==5)
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_34.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
typedef union
{
    char * unionFirst;
    char * unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    char * data;
    var myUnion;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    data = dataBadBuffer;
    data[0] = '\0'; 
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char source[100];
            memset(source, 'C', 100-1); 
            source[100-1] = '\0'; 
            strncpy(data, source, 100-1);
            data[100-1] = '\0'; 
            printLine(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    var myUnion;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    data = dataGoodBuffer;
    data[0] = '\0'; 
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char source[100];
            memset(source, 'C', 100-1); 
            source[100-1] = '\0'; 
            strncpy(data, source, 100-1);
            data[100-1] = '\0'; 
            printLine(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_14.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    if(globalFive==5)
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcscat(dest, data);
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcscat(dest, data);
        printWLine(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    if(globalFive==5)
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcscat(dest, data);
        printWLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_53c.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_06.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    if(STATIC_CONST_FIVE==5)
    {
        data = dataBadBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        wcscpy(data, source);
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        wcscpy(data, source);
        printWLine(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    if(STATIC_CONST_FIVE==5)
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        wcscpy(data, source);
        printWLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_53c.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_63a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * * dataPtr);
void var()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(char * * data);
static void goodG2B()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_06.c,CWE121,good,"#include ""std_testcase.h""
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    if(STATIC_CONST_FIVE==5)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = -1;
    if(STATIC_CONST_FIVE==5)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
        }
    }
}
static void goodB2G2()
{
    int data;
    data = -1;
    if(STATIC_CONST_FIVE==5)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
        }
    }
}
static void goodG2B1()
{
    int data;
    data = -1;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 7;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
static void goodG2B2()
{
    int data;
    data = -1;
    if(STATIC_CONST_FIVE==5)
    {
        data = 7;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_32.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    {
        char * data = *dataPtr1;
        data = dataBadBuffer;
        data[0] = '\0'; 
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char source[10+1] = SRC_STRING;
            memmove(data, source, (strlen(source) + 1) * sizeof(char));
            printLine(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    {
        char * data = *dataPtr1;
        data = dataGoodBuffer;
        data[0] = '\0'; 
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char source[10+1] = SRC_STRING;
            memmove(data, source, (strlen(source) + 1) * sizeof(char));
            printLine(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_54a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBadBuffer;
    data[0] = L'\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_17.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var()
{
    int i;
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int h;
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    for(h = 0; h < 1; h++)
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_64a.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(void * dataVoidPtr);
void var()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    data = dataBadBuffer;
    data[0] = '\0'; 
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr);
static void goodG2B()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    data = dataGoodBuffer;
    data[0] = '\0'; 
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_54a.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var(wchar_t * data);
void var()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    data = dataBadBuffer;
    data[0] = L'\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_09.c,CWE121,bad,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STR ""0123456789abcdef0123456789abcde""
typedef struct _charVoid
{
    char charFirst[16];
    void * voidSecond;
    void * voidThird;
} charVoid;
#ifndef OMITBAD
void var()
{
    if(GLOBAL_CONST_TRUE)
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            printLine((char *)structCharVoid.voidSecond);
            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; 
            printLine((char *)structCharVoid.charFirst);
            printLine((char *)structCharVoid.voidSecond);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void good1()
{
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            printLine((char *)structCharVoid.voidSecond);
            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; 
            printLine((char *)structCharVoid.charFirst);
            printLine((char *)structCharVoid.voidSecond);
        }
    }
}
static void good2()
{
    if(GLOBAL_CONST_TRUE)
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            printLine((char *)structCharVoid.voidSecond);
            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; 
            printLine((char *)structCharVoid.charFirst);
            printLine((char *)structCharVoid.voidSecond);
        }
    }
}
void var()
{
    good1();
    good2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_03.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    if(5==5)
    {
        data = dataBadBuffer;
        data[0] = '\0'; 
    }
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    if(5==5)
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_67a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
typedef struct _CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_67_structType
{
    wchar_t * structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct);
void var()
{
    wchar_t * data;
    var myStruct;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    data = dataBadBuffer;
    data[0] = L'\0'; 
    myStruct.structFirst = data;
    var(myStruct);
}
#endif 
#ifndef OMITGOOD
void var(var myStruct);
static void goodG2B()
{
    wchar_t * data;
    var myStruct;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    myStruct.structFirst = data;
    var(myStruct);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_54d.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_15.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    switch(6)
    {
    case 6:
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        char dest[50] = """";
        strcpy(dest, data);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
        break;
    }
    {
        char dest[50] = """";
        strcpy(dest, data);
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    switch(6)
    {
    case 6:
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        char dest[50] = """";
        strcpy(dest, data);
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_63b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    {
        wchar_t source[10+1] = SRC_STRING;
        wcsncpy(data, source, wcslen(source) + 1);
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    {
        wchar_t source[10+1] = SRC_STRING;
        wcsncpy(data, source, wcslen(source) + 1);
        printWLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_16.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    while(1)
    {
        data = dataBadBuffer;
        data[0] = '\0'; 
        break;
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    while(1)
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
        break;
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; 
        printLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_41.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        wcscpy(dest, data);
        printWLine(data);
    }
}
void var()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        wcscpy(dest, data);
        printWLine(data);
    }
}
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_02.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    if(1)
    {
        data = dataBadBuffer;
    }
    {
        int64_t source[100] = {0}; 
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
    }
    {
        int64_t source[100] = {0}; 
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
static void goodG2B2()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    if(1)
    {
        data = dataGoodBuffer;
    }
    {
        int64_t source[100] = {0}; 
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_18.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    goto source;
source:
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    {
        char dest[50] = """";
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    goto source;
source:
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    {
        char dest[50] = """";
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_53c.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_11.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    if(globalReturnsTrue())
    {
        data = dataBadBuffer;
        data[0] = '\0'; 
    }
    {
        char source[10+1] = SRC_STRING;
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[10+1] = SRC_STRING;
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    if(globalReturnsTrue())
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[10+1] = SRC_STRING;
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_17.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int i;
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    for(i = 0; i < 1; i++)
    {
        data = dataBadBuffer;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int h;
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    for(h = 0; h < 1; h++)
    {
        data = dataGoodBuffer;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_31.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF swprintf
#endif
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    {
        wchar_t * dataCopy = data;
        wchar_t * data = dataCopy;
        {
            wchar_t dest[50] = L"""";
            SNPRINTF(dest, wcslen(data), L""%s"", data);
            printWLine(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    {
        wchar_t * dataCopy = data;
        wchar_t * data = dataCopy;
        {
            wchar_t dest[50] = L"""";
            SNPRINTF(dest, wcslen(data), L""%s"", data);
            printWLine(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_53a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    data = dataBadBuffer;
    data[0] = L'\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_04.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
static const int STATIC_CONST_TRUE = 1; 
static const int STATIC_CONST_FALSE = 0; 
#ifndef OMITBAD
void var()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    if(STATIC_CONST_TRUE)
    {
        data = dataBadBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; 
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    if(STATIC_CONST_TRUE)
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; 
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_66b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * dataArray[])
{
    char * data = dataArray[2];
    {
        char dest[50] = """";
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * dataArray[])
{
    char * data = dataArray[2];
    {
        char dest[50] = """";
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_52c.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_68b.c,CWE121,good,"#include ""std_testcase.h""
extern twoIntsStruct * var;
extern twoIntsStruct * var;
#ifndef OMITBAD
void var()
{
    twoIntsStruct * data = var;
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    twoIntsStruct * data = var;
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_52c.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        memmove(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        memmove(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_66a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * dataArray[]);
void var()
{
    char * data;
    char * dataArray[5];
    char dataBuffer[100];
    data = dataBuffer;
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(char * dataArray[]);
static void goodG2B()
{
    char * data;
    char * dataArray[5];
    char dataBuffer[100];
    data = dataBuffer;
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_68a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
wchar_t * var;
wchar_t * var;
#ifndef OMITBAD
void var();
void var()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    data = dataBadBuffer;
    data[0] = L'\0'; 
    var = data;
    var();
}
#endif 
#ifndef OMITGOOD
void var();
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    var = data;
    var();
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_31.c,CWE121,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    data = dataBadBuffer;
    {
        twoIntsStruct * dataCopy = data;
        twoIntsStruct * data = dataCopy;
        {
            twoIntsStruct source[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    source[i].intOne = 0;
                    source[i].intTwo = 0;
                }
            }
            memcpy(data, source, 100*sizeof(twoIntsStruct));
            printStructLine(&data[0]);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    data = dataGoodBuffer;
    {
        twoIntsStruct * dataCopy = data;
        twoIntsStruct * data = dataCopy;
        {
            twoIntsStruct source[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    source[i].intOne = 0;
                    source[i].intTwo = 0;
                }
            }
            memcpy(data, source, 100*sizeof(twoIntsStruct));
            printStructLine(&data[0]);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_15.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    switch(6)
    {
    case 6:
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        wchar_t dest[50] = L"""";
        size_t i, dataLen;
        dataLen = wcslen(data);
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
        break;
    }
    {
        wchar_t dest[50] = L"""";
        size_t i, dataLen;
        dataLen = wcslen(data);
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    switch(6)
    {
    case 6:
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        wchar_t dest[50] = L"""";
        size_t i, dataLen;
        dataLen = wcslen(data);
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_51b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(char * data)
{
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * data)
{
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_17.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    int i;
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    {
        char dest[50] = """";
        size_t i, dataLen;
        dataLen = strlen(data);
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int h;
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    for(h = 0; h < 1; h++)
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        size_t i, dataLen;
        dataLen = strlen(data);
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_66b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * dataArray[])
{
    char * data = dataArray[2];
    {
        char dest[50] = """";
        strcpy(dest, data);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * dataArray[])
{
    char * data = dataArray[2];
    {
        char dest[50] = """";
        strcpy(dest, data);
        printLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_53c.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_53d.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(char * data)
{
    {
        char source[10+1] = SRC_STRING;
        memmove(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * data)
{
    {
        char source[10+1] = SRC_STRING;
        memmove(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_51b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF swprintf
#endif
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_18.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    goto source;
source:
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    {
        char dest[50] = """";
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    goto source;
source:
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    {
        char dest[50] = """";
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_32.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100];
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char dest[50] = """";
            SNPRINTF(dest, strlen(data), ""%s"", data);
            printLine(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100];
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char dest[50] = """";
            SNPRINTF(dest, strlen(data), ""%s"", data);
            printLine(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_65a.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(twoIntsStruct * data);
void var()
{
    twoIntsStruct * data;
    void (*funcPtr) (twoIntsStruct *) = var;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    data = dataBadBuffer;
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(twoIntsStruct * data);
static void goodG2B()
{
    twoIntsStruct * data;
    void (*funcPtr) (twoIntsStruct *) = var;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    data = dataGoodBuffer;
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_65b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        wcscat(dest, data);
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        wcscat(dest, data);
        printWLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_32.c,CWE121,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    data = -1;
    {
        int data = *dataPtr1;
        fscanf(stdin, ""%d"", &data);
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    data = -1;
    {
        int data = *dataPtr1;
        data = 7;
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
static void goodB2G()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    data = -1;
    {
        int data = *dataPtr1;
        fscanf(stdin, ""%d"", &data);
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_52a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    data = dataBadBuffer;
    data[0] = '\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
static void goodG2B()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    data = dataGoodBuffer;
    data[0] = '\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_52b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(twoIntsStruct * data);
void var(twoIntsStruct * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(twoIntsStruct * data);
void var(twoIntsStruct * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_54e.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncat(data, source, 100);
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncat(data, source, 100);
        printWLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_66b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    {
        wchar_t source[10+1] = SRC_STRING;
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    {
        wchar_t source[10+1] = SRC_STRING;
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67a.c,CWE121,good,"#include ""std_testcase.h""
typedef struct _CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67_structType
{
    int64_t * structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct);
void var()
{
    int64_t * data;
    var myStruct;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    data = dataBadBuffer;
    myStruct.structFirst = data;
    var(myStruct);
}
#endif 
#ifndef OMITGOOD
void var(var myStruct);
static void goodG2B()
{
    int64_t * data;
    var myStruct;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    data = dataGoodBuffer;
    myStruct.structFirst = data;
    var(myStruct);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_51b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        size_t i, dataLen;
        dataLen = wcslen(data);
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        size_t i, dataLen;
        dataLen = wcslen(data);
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_45.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif
static char * var;
static char * var;
#ifndef OMITBAD
static void badSink()
{
    char * data = var;
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
void var()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    char * data = var;
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
static void goodG2B()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    var = data;
    goodG2BSink();
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_18.c,CWE121,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int * data;
    data = NULL;
    goto source;
source:
    data = (int *)ALLOCA(10);
    {
        int source[10] = {0};
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int * data;
    data = NULL;
    goto source;
source:
    data = (int *)ALLOCA(10*sizeof(int));
    {
        int source[10] = {0};
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_08.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    if(staticReturnsTrue())
    {
        data = dataBadBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    if(staticReturnsTrue())
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_17.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    int i;
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    for(i = 0; i < 1; i++)
    {
        data = dataBadBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int h;
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    for(h = 0; h < 1; h++)
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_34.c,CWE121,bad,"#include ""std_testcase.h""
typedef union
{
    int * unionFirst;
    int * unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    int * data;
    var myUnion;
    data = NULL;
    data = (int *)ALLOCA(10);
    myUnion.unionFirst = data;
    {
        int * data = myUnion.unionSecond;
        {
            int source[10] = {0};
            memmove(data, source, 10*sizeof(int));
            printIntLine(data[0]);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int * data;
    var myUnion;
    data = NULL;
    data = (int *)ALLOCA(10*sizeof(int));
    myUnion.unionFirst = data;
    {
        int * data = myUnion.unionSecond;
        {
            int source[10] = {0};
            memmove(data, source, 10*sizeof(int));
            printIntLine(data[0]);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_41.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(char * data)
{
    {
        char source[10+1] = SRC_STRING;
        memmove(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
void var()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    data = dataBadBuffer;
    data[0] = '\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data)
{
    {
        char source[10+1] = SRC_STRING;
        memmove(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
static void goodG2B()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    data = dataGoodBuffer;
    data[0] = '\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_54c.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_66a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * dataArray[]);
void var()
{
    char * data;
    char * dataArray[5];
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(char * dataArray[]);
static void goodG2B()
{
    char * data;
    char * dataArray[5];
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_07.c,CWE121,bad,"#include ""std_testcase.h""
static int staticFive = 5;
#ifndef OMITBAD
void var()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    if(staticFive==5)
    {
        data = dataBadBuffer;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
static void goodG2B2()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    if(staticFive==5)
    {
        data = dataGoodBuffer;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_34.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
typedef union
{
    char * unionFirst;
    char * unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    char * data;
    var myUnion;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    data = dataBadBuffer;
    data[0] = '\0'; 
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char source[100];
            memset(source, 'C', 100-1); 
            source[100-1] = '\0'; 
            memcpy(data, source, 100*sizeof(char));
            data[100-1] = '\0'; 
            printLine(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    var myUnion;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    data = dataGoodBuffer;
    data[0] = '\0'; 
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char source[100];
            memset(source, 'C', 100-1); 
            source[100-1] = '\0'; 
            memcpy(data, source, 100*sizeof(char));
            data[100-1] = '\0'; 
            printLine(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_01.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    data = dataBadBuffer;
    data[0] = '\0'; 
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    data = dataGoodBuffer;
    data[0] = '\0'; 
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_51b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var(char * data)
{
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * data)
{
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_09.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    {
        char dest[50] = """";
        size_t i, dataLen;
        dataLen = strlen(data);
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        size_t i, dataLen;
        dataLen = strlen(data);
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        size_t i, dataLen;
        dataLen = strlen(data);
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_09.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    if(GLOBAL_CONST_TRUE)
    {
        data = dataBadBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncat(data, source, 100);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncat(data, source, 100);
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    if(GLOBAL_CONST_TRUE)
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncat(data, source, 100);
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_04.c,CWE121,good,"#include ""std_testcase.h""
static const int STATIC_CONST_TRUE = 1; 
static const int STATIC_CONST_FALSE = 0; 
#ifndef OMITBAD
void var()
{
    int * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        data = (int *)ALLOCA(10);
    }
    {
        int source[10] = {0};
        size_t i;
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    int * data;
    data = NULL;
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (int *)ALLOCA(10*sizeof(int));
    }
    {
        int source[10] = {0};
        size_t i;
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
    }
}
static void goodG2B2()
{
    int * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        data = (int *)ALLOCA(10*sizeof(int));
    }
    {
        int source[10] = {0};
        size_t i;
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_63a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var(char * * dataPtr);
void var()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    data = dataBadBuffer;
    data[0] = '\0'; 
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(char * * data);
static void goodG2B()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    data = dataGoodBuffer;
    data[0] = '\0'; 
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_66b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * dataArray[])
{
    char * data = dataArray[2];
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * dataArray[])
{
    char * data = dataArray[2];
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_12.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF swprintf
#endif
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_54b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_53b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * data);
void var(int * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int * data);
void var(int * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_52c.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(twoIntsStruct * data)
{
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
#endif 
#ifndef OMITGOOD
void var(twoIntsStruct * data)
{
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_53a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBadBuffer;
    data[0] = '\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
static void goodG2B()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataGoodBuffer;
    data[0] = '\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_66b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * dataArray[])
{
    int64_t * data = dataArray[2];
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
#endif 
#ifndef OMITGOOD
void var(int64_t * dataArray[])
{
    int64_t * data = dataArray[2];
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54c.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * data);
void var(int64_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t * data);
void var(int64_t * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_09.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    if(GLOBAL_CONST_TRUE)
    {
        data = dataBadBuffer;
    }
    {
        int source[100] = {0}; 
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
    }
    {
        int source[100] = {0}; 
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
static void goodG2B2()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    if(GLOBAL_CONST_TRUE)
    {
        data = dataGoodBuffer;
    }
    {
        int source[100] = {0}; 
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_53a.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * data);
void var()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    data = dataBadBuffer;
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int * data);
static void goodG2B()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    data = dataGoodBuffer;
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_11.c,CWE121,bad,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    if(globalReturnsTrue())
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(globalReturnsTrue())
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = -1;
    if(globalReturnsTrue())
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
        }
    }
}
static void goodB2G2()
{
    int data;
    data = -1;
    if(globalReturnsTrue())
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(globalReturnsTrue())
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
        }
    }
}
static void goodG2B1()
{
    int data;
    data = -1;
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 7;
    }
    if(globalReturnsTrue())
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
static void goodG2B2()
{
    int data;
    data = -1;
    if(globalReturnsTrue())
    {
        data = 7;
    }
    if(globalReturnsTrue())
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_52b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_64b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;
    wchar_t * data = (*dataPtr);
    {
        wchar_t dest[50] = L"""";
        wcscpy(dest, data);
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;
    wchar_t * data = (*dataPtr);
    {
        wchar_t dest[50] = L"""";
        wcscpy(dest, data);
        printWLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_34.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
typedef union
{
    char * unionFirst;
    char * unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    char * data;
    var myUnion;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char dest[50] = """";
            size_t i, dataLen;
            dataLen = strlen(data);
            for (i = 0; i < dataLen; i++)
            {
                dest[i] = data[i];
            }
            dest[50-1] = '\0'; 
            printLine(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    var myUnion;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char dest[50] = """";
            size_t i, dataLen;
            dataLen = strlen(data);
            for (i = 0; i < dataLen; i++)
            {
                dest[i] = data[i];
            }
            dest[50-1] = '\0'; 
            printLine(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_67b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
typedef struct _CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_67_structType
{
    wchar_t * structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(var myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; 
        printWLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_03.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    if(5==5)
    {
        data = dataBadBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        wcscpy(data, source);
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        wcscpy(data, source);
        printWLine(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    if(5==5)
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        wcscpy(data, source);
        printWLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_52a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var(char * data);
void var()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
static void goodG2B()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_15.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    switch(6)
    {
    case 6:
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
        break;
    }
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    switch(6)
    {
    case 6:
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_51a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_53b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * data);
void var(int * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int * data);
void var(int * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_01.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBadBuffer;
    data[0] = '\0'; 
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataGoodBuffer;
    data[0] = '\0'; 
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; 
        printLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_64a.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(void * dataVoidPtr);
void var()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    data = dataBadBuffer;
    data[0] = '\0'; 
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr);
static void goodG2B()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    data = dataGoodBuffer;
    data[0] = '\0'; 
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_14.c,CWE121,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    if(globalFive==5)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(globalFive==5)
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = -1;
    if(globalFive==5)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
        }
    }
}
static void goodB2G2()
{
    int data;
    data = -1;
    if(globalFive==5)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(globalFive==5)
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
        }
    }
}
static void goodG2B1()
{
    int data;
    data = -1;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 7;
    }
    if(globalFive==5)
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
static void goodG2B2()
{
    int data;
    data = -1;
    if(globalFive==5)
    {
        data = 7;
    }
    if(globalFive==5)
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_08.c,CWE121,good,"#include ""std_testcase.h""
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    if(staticReturnsTrue())
    {
        data = dataBadBuffer;
    }
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
    }
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
static void goodG2B2()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    if(staticReturnsTrue())
    {
        data = dataGoodBuffer;
    }
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE135_18.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#define WIDE_STRING L""AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA""
#define CHAR_STRING ""AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    void * data;
    data = NULL;
    goto source;
source:
    data = (void *)WIDE_STRING;
    goto sink;
sink:
    {
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
        (void)wcscpy(dest, data);
        printLine((char *)dest);
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    void * data;
    data = NULL;
    goto source;
source:
    data = (void *)WIDE_STRING;
    goto sink;
sink:
    {
        size_t dataLen = wcslen((wchar_t *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
        (void)wcscpy(dest, data);
        printWLine((wchar_t *)dest);
    }
}
static void goodG2B()
{
    void * data;
    data = NULL;
    goto source;
source:
    data = (void *)CHAR_STRING;
    goto sink;
sink:
    {
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
        printLine((char *)dest);
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_61a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
char * var(char * data);
void var()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    data = var(data);
    {
        char dest[50] = """";
        strcpy(dest, data);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
char * var(char * data);
static void goodG2B()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    data = var(data);
    {
        char dest[50] = """";
        strcpy(dest, data);
        printLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_66a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * dataArray[]);
void var()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBadBuffer;
    data[0] = L'\0'; 
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * dataArray[]);
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_63a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * * dataPtr);
void var()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBadBuffer;
    data[0] = L'\0'; 
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_42.c,CWE121,bad,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
static int badSource(int data)
{
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    return data;
}
void var()
{
    int data;
    data = -1;
    data = badSource(data);
    {
        int i;
        int buffer[10] = { 0 };
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
    }
}
#endif 
#ifndef OMITGOOD
static int goodG2BSource(int data)
{
    data = 7;
    return data;
}
static void goodG2B()
{
    int data;
    data = -1;
    data = goodG2BSource(data);
    {
        int i;
        int buffer[10] = { 0 };
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
    }
}
static int goodB2GSource(int data)
{
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    return data;
}
static void goodB2G()
{
    int data;
    data = -1;
    data = goodB2GSource(data);
    {
        int i;
        int buffer[10] = { 0 };
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_63a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * * dataPtr);
void var()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    data = dataBadBuffer;
    data[0] = L'\0'; 
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_13.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(GLOBAL_CONST_FIVE==5)
    {
        data = dataBadBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(GLOBAL_CONST_FIVE==5)
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_17.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF swprintf
#endif
#ifndef OMITBAD
void var()
{
    int i;
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int h;
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    for(h = 0; h < 1; h++)
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_34.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
typedef union
{
    char * unionFirst;
    char * unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    char * data;
    var myUnion;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char dest[50] = """";
            memcpy(dest, data, strlen(data)*sizeof(char));
            dest[50-1] = '\0'; 
            printLine(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    var myUnion;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char dest[50] = """";
            memcpy(dest, data, strlen(data)*sizeof(char));
            dest[50-1] = '\0'; 
            printLine(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_54c.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_67b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
typedef struct _CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_67_structType
{
    wchar_t * structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = wcslen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(var myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = wcslen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printWLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_64a.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(void * dataVoidPtr);
void var()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    data = dataBadBuffer;
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr);
static void goodG2B()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    data = dataGoodBuffer;
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_63b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * * dataPtr)
{
    char * data = *dataPtr;
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncat(data, source, 100);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * * dataPtr)
{
    char * data = *dataPtr;
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncat(data, source, 100);
        printLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_65a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var()
{
    char * data;
    void (*funcPtr) (char *) = var;
    char dataBuffer[100];
    data = dataBuffer;
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
static void goodG2B()
{
    char * data;
    void (*funcPtr) (char *) = var;
    char dataBuffer[100];
    data = dataBuffer;
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_45.c,CWE121,good,"#include ""std_testcase.h""
static int64_t * var;
static int64_t * var;
#ifndef OMITBAD
static void badSink()
{
    int64_t * data = var;
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
void var()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    data = dataBadBuffer;
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    int64_t * data = var;
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
static void goodG2B()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    data = dataGoodBuffer;
    var = data;
    goodG2BSink();
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_11.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(globalReturnsTrue())
    {
        data = dataBadBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(globalReturnsTrue())
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_63a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * * dataPtr);
void var()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBadBuffer;
    data[0] = '\0'; 
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(char * * data);
static void goodG2B()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataGoodBuffer;
    data[0] = '\0'; 
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_51b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data)
{
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcat(data, source);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * data)
{
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcat(data, source);
        printLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_54c.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_02.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    if(1)
    {
        data = dataBadBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        wcscpy(data, source);
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        wcscpy(data, source);
        printWLine(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    if(1)
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        wcscpy(data, source);
        printWLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_66a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * dataArray[]);
void var()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * dataArray[]);
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE135_15.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#define WIDE_STRING L""AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA""
#define CHAR_STRING ""AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    void * data;
    data = NULL;
    switch(6)
    {
    case 6:
        data = (void *)WIDE_STRING;
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
        (void)wcscpy(dest, data);
        printLine((char *)dest);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    void * data;
    data = NULL;
    switch(6)
    {
    case 6:
        data = (void *)WIDE_STRING;
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(8)
    {
    case 7:
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        size_t dataLen = wcslen((wchar_t *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
        (void)wcscpy(dest, data);
        printWLine((wchar_t *)dest);
    }
    break;
    }
}
static void goodB2G2()
{
    void * data;
    data = NULL;
    switch(6)
    {
    case 6:
        data = (void *)WIDE_STRING;
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        size_t dataLen = wcslen((wchar_t *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
        (void)wcscpy(dest, data);
        printWLine((wchar_t *)dest);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B1()
{
    void * data;
    data = NULL;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        data = (void *)CHAR_STRING;
        break;
    }
    switch(7)
    {
    case 7:
    {
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
        printLine((char *)dest);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B2()
{
    void * data;
    data = NULL;
    switch(6)
    {
    case 6:
        data = (void *)CHAR_STRING;
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
        printLine((char *)dest);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_09.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    if(GLOBAL_CONST_TRUE)
    {
        data = dataBadBuffer;
    }
    {
        int source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
    }
    {
        int source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
static void goodG2B2()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    if(GLOBAL_CONST_TRUE)
    {
        data = dataGoodBuffer;
    }
    {
        int source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_53c.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_01.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBadBuffer;
    data[0] = '\0'; 
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcat(data, source);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataGoodBuffer;
    data[0] = '\0'; 
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcat(data, source);
        printLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_67a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
typedef struct _CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_67_structType
{
    char * structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct);
void var()
{
    char * data;
    var myStruct;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBadBuffer;
    data[0] = '\0'; 
    myStruct.structFirst = data;
    var(myStruct);
}
#endif 
#ifndef OMITGOOD
void var(var myStruct);
static void goodG2B()
{
    char * data;
    var myStruct;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataGoodBuffer;
    data[0] = '\0'; 
    myStruct.structFirst = data;
    var(myStruct);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_13.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(GLOBAL_CONST_FIVE==5)
    {
        data = dataBadBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        wcscpy(data, source);
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        wcscpy(data, source);
        printWLine(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(GLOBAL_CONST_FIVE==5)
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        wcscpy(data, source);
        printWLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_10.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    if(globalTrue)
    {
        data = dataBadBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        SNPRINTF(data, 100, ""%s"", source);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        SNPRINTF(data, 100, ""%s"", source);
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    if(globalTrue)
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        SNPRINTF(data, 100, ""%s"", source);
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_54d.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_12.c,CWE121,bad,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STR ""0123456789abcdef0123456789abcde""
typedef struct _charVoid
{
    char charFirst[16];
    void * voidSecond;
    void * voidThird;
} charVoid;
#ifndef OMITBAD
void var()
{
    if(globalReturnsTrueOrFalse())
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            printLine((char *)structCharVoid.voidSecond);
            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; 
            printLine((char *)structCharVoid.charFirst);
            printLine((char *)structCharVoid.voidSecond);
        }
    }
    else
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            printLine((char *)structCharVoid.voidSecond);
            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; 
            printLine((char *)structCharVoid.charFirst);
            printLine((char *)structCharVoid.voidSecond);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void good1()
{
    if(globalReturnsTrueOrFalse())
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            printLine((char *)structCharVoid.voidSecond);
            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; 
            printLine((char *)structCharVoid.charFirst);
            printLine((char *)structCharVoid.voidSecond);
        }
    }
    else
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            printLine((char *)structCharVoid.voidSecond);
            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; 
            printLine((char *)structCharVoid.charFirst);
            printLine((char *)structCharVoid.voidSecond);
        }
    }
}
void var()
{
    good1();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_34.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
typedef union
{
    wchar_t * unionFirst;
    wchar_t * unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    var myUnion;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t dest[50] = L"""";
            wcscpy(dest, data);
            printWLine(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    var myUnion;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t dest[50] = L"""";
            wcscpy(dest, data);
            printWLine(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_53a.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * data);
void var()
{
    int * data;
    data = NULL;
    data = (int *)ALLOCA(10);
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int * data);
static void goodG2B()
{
    int * data;
    data = NULL;
    data = (int *)ALLOCA(10*sizeof(int));
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_68a.c,CWE121,good,"#include ""std_testcase.h""
int * var;
int * var;
#ifndef OMITBAD
void var();
void var()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    data = dataBadBuffer;
    var = data;
    var();
}
#endif 
#ifndef OMITGOOD
void var();
static void goodG2B()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    data = dataGoodBuffer;
    var = data;
    var();
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_03.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    if(5==5)
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    if(5==5)
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_08.c,CWE121,good,"#include ""std_testcase.h""
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    int * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        data = (int *)ALLOCA(10);
    }
    {
        int source[10] = {0};
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    int * data;
    data = NULL;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (int *)ALLOCA(10*sizeof(int));
    }
    {
        int source[10] = {0};
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
static void goodG2B2()
{
    int * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        data = (int *)ALLOCA(10*sizeof(int));
    }
    {
        int source[10] = {0};
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_66a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * dataArray[]);
void var()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    data = dataBadBuffer;
    data[0] = L'\0'; 
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * dataArray[]);
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_22b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
extern int var;
void var(int data)
{
    if(var)
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
#endif 
#ifndef OMITGOOD
extern int var;
extern int var;
extern int var;
void var(int data)
{
    if(var)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
        }
    }
}
void var(int data)
{
    if(var)
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
        }
    }
}
void var(int data)
{
    if(var)
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_54b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * data);
void var(int64_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t * data);
void var(int64_t * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_42.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
static char * badSource(char * data)
{
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    return data;
}
void var()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    data = badSource(data);
    {
        char dest[50] = """";
        strcat(dest, data);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static char * goodG2BSource(char * data)
{
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    return data;
}
static void goodG2B()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    data = goodG2BSource(data);
    {
        char dest[50] = """";
        strcat(dest, data);
        printLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_42.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
static char * badSource(char * data)
{
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    return data;
}
void var()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    data = badSource(data);
    {
        char dest[50] = """";
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static char * goodG2BSource(char * data)
{
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    return data;
}
static void goodG2B()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    data = goodG2BSource(data);
    {
        char dest[50] = """";
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_17.c,CWE121,bad,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STR ""0123456789abcdef0123456789abcde""
typedef struct _charVoid
{
    char charFirst[16];
    void * voidSecond;
    void * voidThird;
} charVoid;
#ifndef OMITBAD
void var()
{
    int j;
    for(j = 0; j < 1; j++)
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            printLine((char *)structCharVoid.voidSecond);
            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; 
            printLine((char *)structCharVoid.charFirst);
            printLine((char *)structCharVoid.voidSecond);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void good1()
{
    int k;
    for(k = 0; k < 1; k++)
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            printLine((char *)structCharVoid.voidSecond);
            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; 
            printLine((char *)structCharVoid.charFirst);
            printLine((char *)structCharVoid.voidSecond);
        }
    }
}
void var()
{
    good1();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_68a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
char * var;
char * var;
#ifndef OMITBAD
void var();
void var()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBadBuffer;
    data[0] = '\0'; 
    var = data;
    var();
}
#endif 
#ifndef OMITGOOD
void var();
static void goodG2B()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataGoodBuffer;
    data[0] = '\0'; 
    var = data;
    var();
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_63b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * * dataPtr)
{
    int * data = *dataPtr;
    {
        int source[100] = {0}; 
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
#endif 
#ifndef OMITGOOD
void var(int * * dataPtr)
{
    int * data = *dataPtr;
    {
        int source[100] = {0}; 
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_15.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    switch(6)
    {
    case 6:
        data = dataBadBuffer;
        data[0] = L'\0'; 
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscpy(data, source);
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        data = dataGoodBuffer;
        data[0] = L'\0'; 
        break;
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscpy(data, source);
        printWLine(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    switch(6)
    {
    case 6:
        data = dataGoodBuffer;
        data[0] = L'\0'; 
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscpy(data, source);
        printWLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_51b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data)
{
    {
        char dest[50] = """";
        strcat(dest, data);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * data)
{
    {
        char dest[50] = """";
        strcat(dest, data);
        printLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_01.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    {
        wchar_t dest[50] = L"""";
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    {
        wchar_t dest[50] = L"""";
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_68b.c,CWE121,good,"#include ""std_testcase.h""
extern int * var;
extern int * var;
#ifndef OMITBAD
void var()
{
    int * data = var;
    {
        int source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
        }
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    int * data = var;
    {
        int source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
        }
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_53b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_64b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    char * * dataPtr = (char * *)dataVoidPtr;
    char * data = (*dataPtr);
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    char * * dataPtr = (char * *)dataVoidPtr;
    char * data = (*dataPtr);
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_12.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF swprintf
#endif
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_34.c,CWE121,bad,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
typedef union
{
    int unionFirst;
    int unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    int data;
    var myUnion;
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int data;
    var myUnion;
    data = -1;
    data = 7;
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
static void goodB2G()
{
    int data;
    var myUnion;
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_12.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_54c.c,CWE121,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_10.c,CWE121,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int * data;
    data = NULL;
    if(globalTrue)
    {
        data = (int *)ALLOCA(10);
    }
    {
        int source[10] = {0};
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    int * data;
    data = NULL;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (int *)ALLOCA(10*sizeof(int));
    }
    {
        int source[10] = {0};
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
static void goodG2B2()
{
    int * data;
    data = NULL;
    if(globalTrue)
    {
        data = (int *)ALLOCA(10*sizeof(int));
    }
    {
        int source[10] = {0};
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_03.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    if(5==5)
    {
        data = dataBadBuffer;
    }
    {
        int source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
    }
    {
        int source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
static void goodG2B2()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    if(5==5)
    {
        data = dataGoodBuffer;
    }
    {
        int source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_04.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF swprintf
#endif
static const int STATIC_CONST_TRUE = 1; 
static const int STATIC_CONST_FALSE = 0; 
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    if(STATIC_CONST_TRUE)
    {
        data = dataBadBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    if(STATIC_CONST_TRUE)
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_13.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(GLOBAL_CONST_FIVE==5)
    {
        data = dataBadBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(GLOBAL_CONST_FIVE==5)
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_54e.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data)
{
    {
        char dest[50] = """";
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * data)
{
    {
        char dest[50] = """";
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_68b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF swprintf
#endif
extern wchar_t * var;
extern wchar_t * var;
#ifndef OMITBAD
void var()
{
    wchar_t * data = var;
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    wchar_t * data = var;
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54e.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * data)
{
    {
        int64_t source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
        }
    }
}
#endif 
#ifndef OMITGOOD
void var(int64_t * data)
{
    {
        int64_t source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
        }
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_17.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    int i;
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    for(i = 0; i < 1; i++)
    {
        data = dataBadBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int h;
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    for(h = 0; h < 1; h++)
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_44.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
static void badSink(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
void var()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = badSink;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
static void goodG2B()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = goodG2BSink;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_11.c,CWE121,bad,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    if(globalReturnsTrue())
    {
        data = dataBadBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    if(globalReturnsTrue())
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_02.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    if(1)
    {
        data = dataBadBuffer;
        data[0] = '\0'; 
    }
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    if(1)
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_52b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_03.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(5==5)
    {
        data = dataBadBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = wcslen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = wcslen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printWLine(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(5==5)
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = wcslen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printWLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_53d.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncat(data, source, 100);
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncat(data, source, 100);
        printWLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_64b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr;
    twoIntsStruct * data = (*dataPtr);
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr;
    twoIntsStruct * data = (*dataPtr);
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_03.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    if(5==5)
    {
        data = dataBadBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncat(data, source, 100);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncat(data, source, 100);
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    if(5==5)
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncat(data, source, 100);
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_44.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
static void badSink(wchar_t * data)
{
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; 
        printWLine(data);
    }
}
void var()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = badSink;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    data = dataBadBuffer;
    data[0] = L'\0'; 
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(wchar_t * data)
{
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; 
        printWLine(data);
    }
}
static void goodG2B()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = goodG2BSink;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_67a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF snprintf
#endif
typedef struct _CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_67_structType
{
    wchar_t * structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct);
void var()
{
    wchar_t * data;
    var myStruct;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    myStruct.structFirst = data;
    var(myStruct);
}
#endif 
#ifndef OMITGOOD
void var(var myStruct);
static void goodG2B()
{
    wchar_t * data;
    var myStruct;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    myStruct.structFirst = data;
    var(myStruct);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_16.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    while(1)
    {
        data = dataBadBuffer;
        data[0] = L'\0'; 
        break;
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        wcscpy(data, source);
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    while(1)
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
        break;
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        wcscpy(data, source);
        printWLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_68a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
char * var;
char * var;
#ifndef OMITBAD
void var();
void var()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    var = data;
    var();
}
#endif 
#ifndef OMITGOOD
void var();
static void goodG2B()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    var = data;
    var();
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54d.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_02.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    if(1)
    {
        data = dataBadBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    if(1)
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_10.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    if(globalTrue)
    {
        data = dataBadBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcpy(data, source);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcpy(data, source);
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    if(globalTrue)
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcpy(data, source);
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_01.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBadBuffer;
    data[0] = '\0'; 
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataGoodBuffer;
    data[0] = '\0'; 
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_03.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    if(5==5)
    {
        data = dataBadBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscat(data, source);
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscat(data, source);
        printWLine(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    if(5==5)
    {
        data = dataGoodBuffer;
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscat(data, source);
        printWLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_32.c,CWE121,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    twoIntsStruct * data;
    twoIntsStruct * *dataPtr1 = &data;
    twoIntsStruct * *dataPtr2 = &data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    {
        twoIntsStruct * data = *dataPtr1;
        data = dataBadBuffer;
        *dataPtr1 = data;
    }
    {
        twoIntsStruct * data = *dataPtr2;
        {
            twoIntsStruct source[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    source[i].intOne = 0;
                    source[i].intTwo = 0;
                }
            }
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    data[i] = source[i];
                }
                printStructLine(&data[0]);
            }
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    twoIntsStruct * data;
    twoIntsStruct * *dataPtr1 = &data;
    twoIntsStruct * *dataPtr2 = &data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    {
        twoIntsStruct * data = *dataPtr1;
        data = dataGoodBuffer;
        *dataPtr1 = data;
    }
    {
        twoIntsStruct * data = *dataPtr2;
        {
            twoIntsStruct source[100];
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    source[i].intOne = 0;
                    source[i].intTwo = 0;
                }
            }
            {
                size_t i;
                for (i = 0; i < 100; i++)
                {
                    data[i] = source[i];
                }
                printStructLine(&data[0]);
            }
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_63b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(twoIntsStruct * * dataPtr)
{
    twoIntsStruct * data = *dataPtr;
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printStructLine(&data[0]);
        }
    }
}
#endif 
#ifndef OMITGOOD
void var(twoIntsStruct * * dataPtr)
{
    twoIntsStruct * data = *dataPtr;
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printStructLine(&data[0]);
        }
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_53a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    data = dataBadBuffer;
    data[0] = L'\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_09.c,CWE121,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    if(GLOBAL_CONST_TRUE)
    {
        data = dataBadBuffer;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
static void goodG2B2()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    if(GLOBAL_CONST_TRUE)
    {
        data = dataGoodBuffer;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_66a.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var(wchar_t * dataArray[]);
void var()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    data = dataBadBuffer;
    data[0] = L'\0'; 
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * dataArray[]);
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_67b.c,CWE121,good,"#include ""std_testcase.h""
typedef struct _CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_67_structType
{
    int * structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct)
{
    int * data = myStruct.structFirst;
    {
        int source[100] = {0}; 
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
#endif 
#ifndef OMITGOOD
void var(var myStruct)
{
    int * data = myStruct.structFirst;
    {
        int source[100] = {0}; 
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_12.c,CWE121,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = (int *)ALLOCA(10);
    }
    else
    {
        data = (int *)ALLOCA(10*sizeof(int));
    }
    {
        int source[10] = {0};
        size_t i;
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = (int *)ALLOCA(10*sizeof(int));
    }
    else
    {
        data = (int *)ALLOCA(10*sizeof(int));
    }
    {
        int source[10] = {0};
        size_t i;
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_66b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    {
        wchar_t source[10+1] = SRC_STRING;
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    {
        wchar_t source[10+1] = SRC_STRING;
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_66a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * dataArray[]);
void var()
{
    char * data;
    char * dataArray[5];
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    data = dataBadBuffer;
    data[0] = '\0'; 
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(char * dataArray[]);
static void goodG2B()
{
    char * data;
    char * dataArray[5];
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    data = dataGoodBuffer;
    data[0] = '\0'; 
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_54c.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_53c.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * data);
void var(int * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int * data);
void var(int * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_67b.c,CWE121,good,"#include ""std_testcase.h""
typedef struct _CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_67_structType
{
    int * structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct)
{
    int * data = myStruct.structFirst;
    {
        int source[100] = {0}; 
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
#endif 
#ifndef OMITGOOD
void var(var myStruct)
{
    int * data = myStruct.structFirst;
    {
        int source[100] = {0}; 
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_15.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STR L""0123456789abcdef0123456789abcde""
typedef struct _charVoid
{
    wchar_t charFirst[16];
    void * voidSecond;
    void * voidThird;
} charVoid;
#ifndef OMITBAD
void var()
{
    switch(6)
    {
    case 6:
    {
        charVoid structCharVoid;
        structCharVoid.voidSecond = (void *)SRC_STR;
        printWLine((wchar_t *)structCharVoid.voidSecond);
        memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));
        structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\0'; 
        printWLine((wchar_t *)structCharVoid.charFirst);
        printWLine((wchar_t *)structCharVoid.voidSecond);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void good1()
{
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        charVoid structCharVoid;
        structCharVoid.voidSecond = (void *)SRC_STR;
        printWLine((wchar_t *)structCharVoid.voidSecond);
        memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
        structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\0'; 
        printWLine((wchar_t *)structCharVoid.charFirst);
        printWLine((wchar_t *)structCharVoid.voidSecond);
    }
    break;
    }
}
static void good2()
{
    switch(6)
    {
    case 6:
    {
        charVoid structCharVoid;
        structCharVoid.voidSecond = (void *)SRC_STR;
        printWLine((wchar_t *)structCharVoid.voidSecond);
        memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
        structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\0'; 
        printWLine((wchar_t *)structCharVoid.charFirst);
        printWLine((wchar_t *)structCharVoid.voidSecond);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
void var()
{
    good1();
    good2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_64a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(void * dataVoidPtr);
void var()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    data = dataBadBuffer;
    data[0] = '\0'; 
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr);
static void goodG2B()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    data = dataGoodBuffer;
    data[0] = '\0'; 
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_54d.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_52b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * data);
void var(int * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int * data);
void var(int * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_45.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
static wchar_t * var;
static wchar_t * var;
#ifndef OMITBAD
static void badSink()
{
    wchar_t * data = var;
    {
        wchar_t dest[50] = L"""";
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
void var()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    wchar_t * data = var;
    {
        wchar_t dest[50] = L"""";
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    var = data;
    goodG2BSink();
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_01.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    data = dataBadBuffer;
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    data = dataGoodBuffer;
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_64a.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(void * dataVoidPtr);
void var()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    data = dataBadBuffer;
    data[0] = '\0'; 
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr);
static void goodG2B()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    data = dataGoodBuffer;
    data[0] = '\0'; 
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_10.c,CWE121,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    if(globalTrue)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(globalTrue)
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = -1;
    if(globalTrue)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
        }
    }
}
static void goodB2G2()
{
    int data;
    data = -1;
    if(globalTrue)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(globalTrue)
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
        }
    }
}
static void goodG2B1()
{
    int data;
    data = -1;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 7;
    }
    if(globalTrue)
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
static void goodG2B2()
{
    int data;
    data = -1;
    if(globalTrue)
    {
        data = 7;
    }
    if(globalTrue)
    {
        {
            int i;
            int buffer[10] = { 0 };
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE135_16.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#define WIDE_STRING L""AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA""
#define CHAR_STRING ""AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    void * data;
    data = NULL;
    while(1)
    {
        data = (void *)WIDE_STRING;
        break;
    }
    while(1)
    {
        {
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
            (void)wcscpy(dest, data);
            printLine((char *)dest);
        }
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    void * data;
    data = NULL;
    while(1)
    {
        data = (void *)WIDE_STRING;
        break;
    }
    while(1)
    {
        {
            size_t dataLen = wcslen((wchar_t *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
            (void)wcscpy(dest, data);
            printWLine((wchar_t *)dest);
        }
        break;
    }
}
static void goodG2B()
{
    void * data;
    data = NULL;
    while(1)
    {
        data = (void *)CHAR_STRING;
        break;
    }
    while(1)
    {
        {
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
            printLine((char *)dest);
        }
        break;
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_53b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_12.c,CWE121,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    if(globalReturnsTrueOrFalse())
    {
        data = dataBadBuffer;
    }
    else
    {
        data = dataGoodBuffer;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    if(globalReturnsTrueOrFalse())
    {
        data = dataGoodBuffer;
    }
    else
    {
        data = dataGoodBuffer;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_01.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    data = dataBadBuffer;
    data[0] = L'\0'; 
    {
        wchar_t source[10+1] = SRC_STRING;
        wcscpy(data, source);
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    {
        wchar_t source[10+1] = SRC_STRING;
        wcscpy(data, source);
        printWLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_18.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    goto source;
source:
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    {
        char dest[50] = """";
        strcat(dest, data);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    goto source;
source:
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    {
        char dest[50] = """";
        strcat(dest, data);
        printLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_66b.c,CWE121,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int dataArray[])
{
    int data = dataArray[2];
    {
        int i;
        int buffer[10] = { 0 };
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
    }
}
#endif 
#ifndef OMITGOOD
void var(int dataArray[])
{
    int data = dataArray[2];
    {
        int i;
        int buffer[10] = { 0 };
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
    }
}
void var(int dataArray[])
{
    int data = dataArray[2];
    {
        int i;
        int buffer[10] = { 0 };
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_18.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    goto source;
source:
    data = dataBadBuffer;
    data[0] = L'\0'; 
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncpy(data, source, 100-1);
        data[100-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    goto source;
source:
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncpy(data, source, 100-1);
        data[100-1] = L'\0'; 
        printWLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_63a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * * dataPtr);
void var()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBadBuffer;
    data[0] = '\0'; 
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(char * * data);
static void goodG2B()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataGoodBuffer;
    data[0] = '\0'; 
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_53c.c,CWE121,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(twoIntsStruct * data);
void var(twoIntsStruct * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(twoIntsStruct * data);
void var(twoIntsStruct * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_41.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        wchar_t source[10+1] = SRC_STRING;
        wcsncpy(data, source, wcslen(source) + 1);
        printWLine(data);
    }
}
void var()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    data = dataBadBuffer;
    data[0] = L'\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        wchar_t source[10+1] = SRC_STRING;
        wcsncpy(data, source, wcslen(source) + 1);
        printWLine(data);
    }
}
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_65b.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_41.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncat(data, source, 100);
        printWLine(data);
    }
}
void var()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBadBuffer;
    data[0] = L'\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncat(data, source, 100);
        printWLine(data);
    }
}
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_10.c,CWE121,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int * data;
    data = NULL;
    if(globalTrue)
    {
        data = (int *)ALLOCA(10);
    }
    {
        int source[10] = {0};
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    int * data;
    data = NULL;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (int *)ALLOCA(10*sizeof(int));
    }
    {
        int source[10] = {0};
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
static void goodG2B2()
{
    int * data;
    data = NULL;
    if(globalTrue)
    {
        data = (int *)ALLOCA(10*sizeof(int));
    }
    {
        int source[10] = {0};
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_68b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
extern wchar_t * var;
extern wchar_t * var;
#ifndef OMITBAD
void var()
{
    wchar_t * data = var;
    {
        wchar_t source[10+1] = SRC_STRING;
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    wchar_t * data = var;
    {
        wchar_t source[10+1] = SRC_STRING;
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_08.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    {
        char dest[50] = """";
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_52a.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(char * data);
void var()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    data = dataBadBuffer;
    data[0] = '\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
static void goodG2B()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    data = dataGoodBuffer;
    data[0] = '\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_08.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    if(staticReturnsTrue())
    {
        data = dataBadBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    if(staticReturnsTrue())
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_07.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
static int staticFive = 5;
#ifndef OMITBAD
void var()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(staticFive==5)
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strcpy(dest, data);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strcpy(dest, data);
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(staticFive==5)
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strcpy(dest, data);
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_66a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * dataArray[]);
void var()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * dataArray[]);
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_12.c,CWE121,bad,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    if(globalReturnsTrueOrFalse())
    {
        data = dataBadBuffer;
        data[0] = '\0'; 
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[10+1] = SRC_STRING;
        strcpy(data, source);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    if(globalReturnsTrueOrFalse())
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[10+1] = SRC_STRING;
        strcpy(data, source);
        printLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_68a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
char * var;
char * var;
#ifndef OMITBAD
void var();
void var()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    var = data;
    var();
}
#endif 
#ifndef OMITGOOD
void var();
static void goodG2B()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    var = data;
    var();
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_03.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    if(5==5)
    {
        data = dataBadBuffer;
        data[0] = '\0'; 
    }
    {
        char source[10+1] = SRC_STRING;
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[10+1] = SRC_STRING;
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    if(5==5)
    {
        data = dataGoodBuffer;
        data[0] = '\0'; 
    }
    {
        char source[10+1] = SRC_STRING;
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_10.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(globalTrue)
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    {
        char dest[50] = """";
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(globalTrue)
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_31.c,CWE121,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    data = dataBadBuffer;
    data[0] = L'\0'; 
    {
        wchar_t * dataCopy = data;
        wchar_t * data = dataCopy;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); 
            source[100-1] = L'\0'; 
            memmove(data, source, 100*sizeof(wchar_t));
            data[100-1] = L'\0'; 
            printWLine(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    data = dataGoodBuffer;
    data[0] = L'\0'; 
    {
        wchar_t * dataCopy = data;
        wchar_t * data = dataCopy;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); 
            source[100-1] = L'\0'; 
            memmove(data, source, 100*sizeof(wchar_t));
            data[100-1] = L'\0'; 
            printWLine(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_54c.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE129_large_15.c,CWE121,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    switch(6)
    {
    case 6:
        data = 10;
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        int i;
        int buffer[10] = { 0 };
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = -1;
    switch(6)
    {
    case 6:
        data = 10;
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(8)
    {
    case 7:
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        int i;
        int buffer[10] = { 0 };
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
    }
    break;
    }
}
static void goodB2G2()
{
    int data;
    data = -1;
    switch(6)
    {
    case 6:
        data = 10;
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        int i;
        int buffer[10] = { 0 };
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B1()
{
    int data;
    data = -1;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        data = 7;
        break;
    }
    switch(7)
    {
    case 7:
    {
        int i;
        int buffer[10] = { 0 };
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B2()
{
    int data;
    data = -1;
    switch(6)
    {
    case 6:
        data = 7;
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        int i;
        int buffer[10] = { 0 };
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_61a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
char * var(char * data);
void var()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    data = var(data);
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
char * var(char * data);
static void goodG2B()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    data = var(data);
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_65b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(char * data)
{
    {
        char source[10+1] = SRC_STRING;
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * data)
{
    {
        char source[10+1] = SRC_STRING;
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_06.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_67a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
typedef struct _CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_67_structType
{
    char * structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct);
void var()
{
    char * data;
    var myStruct;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBadBuffer;
    data[0] = '\0'; 
    myStruct.structFirst = data;
    var(myStruct);
}
#endif 
#ifndef OMITGOOD
void var(var myStruct);
static void goodG2B()
{
    char * data;
    var myStruct;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataGoodBuffer;
    data[0] = '\0'; 
    myStruct.structFirst = data;
    var(myStruct);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_12.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_52b.c,CWE121,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_51a.c,CWE121,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    data = dataBadBuffer;
    data[0] = '\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
static void goodG2B()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    data = dataGoodBuffer;
    data[0] = '\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_file_w32_spawnv_21.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#ifndef OMITBAD
static int badStatic = 0;
static char * badSource(char * data)
{
    if(badStatic)
    {
        {
            size_t dataLen = strlen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    return data;
}
void CWE78_OS_Command_Injection__char_file_w32_spawnv_21_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    badStatic = 1; 
    data = badSource(data);
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static int goodG2B1Static = 0;
static int goodG2B2Static = 0;
static char * goodG2B1Source(char * data)
{
    if(goodG2B1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    return data;
}
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goodG2B1Static = 0; 
    data = goodG2B1Source(data);
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
static char * goodG2B2Source(char * data)
{
    if(goodG2B2Static)
    {
        strcat(data, ""*.*"");
    }
    return data;
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goodG2B2Static = 1; 
    data = goodG2B2Source(data);
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__char_file_w32_spawnv_21_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_file_w32_spawnv_21_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_file_w32_spawnv_21_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_file_system_52b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#ifdef _WIN32
#define SYSTEM system
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_system_52c_badSink(char * data);
void CWE78_OS_Command_Injection__char_file_system_52b_badSink(char * data)
{
    CWE78_OS_Command_Injection__char_file_system_52c_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_file_system_52c_goodG2BSink(char * data);
void CWE78_OS_Command_Injection__char_file_system_52b_goodG2BSink(char * data)
{
    CWE78_OS_Command_Injection__char_file_system_52c_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_11.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_11_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(char)] = '\0';
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        strcat(data, ""*.*"");
    }
    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_11_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_11_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_11_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_execl_01.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_execl_01_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_listen_socket_execl_01_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_listen_socket_execl_01_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_listen_socket_execl_01_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_environment_w32_execvp_22a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#define EXECVP _execvp
#ifndef OMITBAD
int CWE78_OS_Command_Injection__char_environment_w32_execvp_22_badGlobal = 0;
char * CWE78_OS_Command_Injection__char_environment_w32_execvp_22_badSource(char * data);
void CWE78_OS_Command_Injection__char_environment_w32_execvp_22_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    CWE78_OS_Command_Injection__char_environment_w32_execvp_22_badGlobal = 1; 
    data = CWE78_OS_Command_Injection__char_environment_w32_execvp_22_badSource(data);
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
int CWE78_OS_Command_Injection__char_environment_w32_execvp_22_goodG2B1Global = 0;
int CWE78_OS_Command_Injection__char_environment_w32_execvp_22_goodG2B2Global = 0;
char * CWE78_OS_Command_Injection__char_environment_w32_execvp_22_goodG2B1Source(char * data);
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    CWE78_OS_Command_Injection__char_environment_w32_execvp_22_goodG2B1Global = 0; 
    data = CWE78_OS_Command_Injection__char_environment_w32_execvp_22_goodG2B1Source(data);
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
char * CWE78_OS_Command_Injection__char_environment_w32_execvp_22_goodG2B2Source(char * data);
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    CWE78_OS_Command_Injection__char_environment_w32_execvp_22_goodG2B2Global = 1; 
    data = CWE78_OS_Command_Injection__char_environment_w32_execvp_22_goodG2B2Source(data);
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
void CWE78_OS_Command_Injection__char_environment_w32_execvp_22_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_environment_w32_execvp_22_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_environment_w32_execvp_22_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_system_52c.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#define SYSTEM _wsystem
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_system_52c_badSink(wchar_t * data)
{
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_system_52c_goodG2BSink(wchar_t * data)
{
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif"
CWE78_OS_Command_Injection__char_console_system_03.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#define SYSTEM system
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_system_03_bad()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(5==5)
    {
        {
            size_t dataLen = strlen(data);
            if (100-dataLen > 1)
            {
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    data[dataLen] = '\0';
                }
            }
        }
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
static void goodG2B2()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(5==5)
    {
        strcat(data, ""*.*"");
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
void CWE78_OS_Command_Injection__char_console_system_03_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_console_system_03_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_console_system_03_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_popen_53a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#define POPEN _popen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_popen_53b_badSink(char * data);
void CWE78_OS_Command_Injection__char_console_popen_53_bad()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        size_t dataLen = strlen(data);
        if (100-dataLen > 1)
        {
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                data[dataLen] = '\0';
            }
        }
    }
    CWE78_OS_Command_Injection__char_console_popen_53b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_console_popen_53b_goodG2BSink(char * data);
static void goodG2B()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_console_popen_53b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__char_console_popen_53_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_console_popen_53_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_console_popen_53_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_environment_execlp_68b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif
extern char * CWE78_OS_Command_Injection__char_environment_execlp_68_badData;
extern char * CWE78_OS_Command_Injection__char_environment_execlp_68_goodG2BData;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_execlp_68b_badSink()
{
    char * data = CWE78_OS_Command_Injection__char_environment_execlp_68_badData;
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_environment_execlp_68b_goodG2BSink()
{
    char * data = CWE78_OS_Command_Injection__char_environment_execlp_68_goodG2BData;
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_12.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#define EXECV _wexecv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_12_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        wcscat(data, L""*.*"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_12_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_12_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_12_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_52a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_52b_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_52_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = wcslen(data);
        wchar_t * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            wcsncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_52b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_52b_goodG2BSink(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_52b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_52_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_52_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_52_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_w32_spawnlp_52c.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnlp_52c_badSink(wchar_t * data)
{
    _wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnlp_52c_goodG2BSink(wchar_t * data)
{
    _wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_54c.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#define EXECVP _execvp
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_54d_badSink(char * data);
void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_54c_badSink(char * data)
{
    CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_54d_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_54d_goodG2BSink(char * data);
void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_54c_goodG2BSink(char * data)
{
    CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_54d_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__char_file_system_51b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#ifdef _WIN32
#define SYSTEM system
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_system_51b_badSink(char * data)
{
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_file_system_51b_goodG2BSink(char * data)
{
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_41.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_41_badSink(wchar_t * data)
{
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_41_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        wchar_t *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = wcslen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
            replace = wcschr(data, L'\r');
            if (replace)
            {
                *replace = L'\0';
            }
            replace = wcschr(data, L'\n');
            if (replace)
            {
                *replace = L'\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_41_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_41_goodG2BSink(wchar_t * data)
{
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_41_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_41_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_41_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_41_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_w32_spawnvp_13.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnvp_13_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            size_t dataLen = wcslen(data);
            if (100-dataLen > 1)
            {
                if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    dataLen = wcslen(data);
                    if (dataLen > 0 && data[dataLen-1] == L'\n')
                    {
                        data[dataLen-1] = L'\0';
                    }
                }
                else
                {
                    printLine(""fgetws() failed"");
                    data[dataLen] = L'\0';
                }
            }
        }
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_FIVE==5)
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnvp_13_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_console_w32_spawnvp_13_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_console_w32_spawnvp_13_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_environment_w32spawnl_51a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_w32spawnl_51b_badSink(char * data);
void CWE78_OS_Command_Injection__char_environment_w32spawnl_51_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    CWE78_OS_Command_Injection__char_environment_w32spawnl_51b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_environment_w32spawnl_51b_goodG2BSink(char * data);
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_environment_w32spawnl_51b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__char_environment_w32spawnl_51_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_environment_w32spawnl_51_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_environment_w32spawnl_51_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_execlp_63b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_execlp_63b_badSink(char * * dataPtr)
{
    char * data = *dataPtr;
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_connect_socket_execlp_63b_goodG2BSink(char * * dataPtr)
{
    char * data = *dataPtr;
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_w32_execvp_41.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#define EXECVP _wexecvp
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_w32_execvp_41_badSink(wchar_t * data)
{
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_file_w32_execvp_41_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = wcslen(data);
        FILE * pFile;
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgetws() failed"");
                    data[dataLen] = L'\0';
                }
                fclose(pFile);
            }
        }
    }
    CWE78_OS_Command_Injection__wchar_t_file_w32_execvp_41_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_file_w32_execvp_41_goodG2BSink(wchar_t * data)
{
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_file_w32_execvp_41_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__wchar_t_file_w32_execvp_41_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_execvp_41_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_execvp_41_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_w32_execv_68a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#define EXECV _wexecv
wchar_t * CWE78_OS_Command_Injection__wchar_t_file_w32_execv_68_badData;
wchar_t * CWE78_OS_Command_Injection__wchar_t_file_w32_execv_68_goodG2BData;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_w32_execv_68b_badSink();
void CWE78_OS_Command_Injection__wchar_t_file_w32_execv_68_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = wcslen(data);
        FILE * pFile;
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgetws() failed"");
                    data[dataLen] = L'\0';
                }
                fclose(pFile);
            }
        }
    }
    CWE78_OS_Command_Injection__wchar_t_file_w32_execv_68_badData = data;
    CWE78_OS_Command_Injection__wchar_t_file_w32_execv_68b_badSink();
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_file_w32_execv_68b_goodG2BSink();
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_file_w32_execv_68_goodG2BData = data;
    CWE78_OS_Command_Injection__wchar_t_file_w32_execv_68b_goodG2BSink();
}
void CWE78_OS_Command_Injection__wchar_t_file_w32_execv_68_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_execv_68_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_execv_68_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_68b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
extern char * CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_68_badData;
extern char * CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_68_goodG2BData;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_68b_badSink()
{
    char * data = CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_68_badData;
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_68b_goodG2BSink()
{
    char * data = CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_68_goodG2BData;
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_18.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#define EXECVP _execvp
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_18_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goto source;
source:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goto source;
source:
    strcat(data, ""*.*"");
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_18_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_18_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_18_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_12.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#include <process.h>
#define EXECL _wexecl
#else 
#define EXECL execl
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_12_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        wcscat(data, L""*.*"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_12_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_12_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_12_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_51a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_51b_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_51_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = wcslen(data);
        wchar_t * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            wcsncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_51b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_51b_goodG2BSink(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_51b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_51_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_51_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_51_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_environment_execlp_31.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_execlp_31_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    {
        char * dataCopy = data;
        char * data = dataCopy;
        EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
    }
}
void CWE78_OS_Command_Injection__char_environment_execlp_31_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_environment_execlp_31_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_environment_execlp_31_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_61a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#define EXECV _wexecv
#ifndef OMITBAD
wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_61b_badSource(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_61_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    data = CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_61b_badSource(data);
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_61b_goodG2BSource(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    data = CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_61b_goodG2BSource(data);
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_61_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_61_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_61_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_execlp_34.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif
typedef union
{
    char * unionFirst;
    char * unionSecond;
} CWE78_OS_Command_Injection__char_connect_socket_execlp_34_unionType;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_execlp_34_bad()
{
    char * data;
    CWE78_OS_Command_Injection__char_connect_socket_execlp_34_unionType myUnion;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    CWE78_OS_Command_Injection__char_connect_socket_execlp_34_unionType myUnion;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
    }
}
void CWE78_OS_Command_Injection__char_connect_socket_execlp_34_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_execlp_34_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_execlp_34_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_execl_15.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_execl_15_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    switch(6)
    {
    case 6:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        strcat(data, ""*.*"");
        break;
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    switch(6)
    {
    case 6:
        strcat(data, ""*.*"");
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_listen_socket_execl_15_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_listen_socket_execl_15_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_listen_socket_execl_15_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_system_17.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#define SYSTEM _wsystem
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_system_17_bad()
{
    int i;
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    for(i = 0; i < 1; i++)
    {
        {
            size_t dataLen = wcslen(data);
            wchar_t * environment = GETENV(ENV_VARIABLE);
            if (environment != NULL)
            {
                wcsncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int h;
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    for(h = 0; h < 1; h++)
    {
        wcscat(data, L""*.*"");
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
void CWE78_OS_Command_Injection__wchar_t_environment_system_17_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_system_17_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_system_17_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_w32_execvp_65b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#define EXECVP _execvp
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_w32_execvp_65b_badSink(char * data)
{
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_console_w32_execvp_65b_goodG2BSink(char * data)
{
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_popen_68b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#define POPEN _popen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
extern char * CWE78_OS_Command_Injection__char_connect_socket_popen_68_badData;
extern char * CWE78_OS_Command_Injection__char_connect_socket_popen_68_goodG2BData;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_popen_68b_badSink()
{
    char * data = CWE78_OS_Command_Injection__char_connect_socket_popen_68_badData;
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_connect_socket_popen_68b_goodG2BSink()
{
    char * data = CWE78_OS_Command_Injection__char_connect_socket_popen_68_goodG2BData;
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_68a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#define POPEN _wpopen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_68_badData;
wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_68_goodG2BData;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_68b_badSink();
void CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_68_bad()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        wchar_t *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = wcslen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
            replace = wcschr(data, L'\r');
            if (replace)
            {
                *replace = L'\0';
            }
            replace = wcschr(data, L'\n');
            if (replace)
            {
                *replace = L'\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_68_badData = data;
    CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_68b_badSink();
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_68b_goodG2BSink();
static void goodG2B()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_68_goodG2BData = data;
    CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_68b_goodG2BSink();
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_68_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_68_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_68_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_w32_execv_65b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#define EXECV _wexecv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_w32_execv_65b_badSink(wchar_t * data)
{
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_console_w32_execv_65b_goodG2BSink(wchar_t * data)
{
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_53a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_53b_badSink(char * data);
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_53_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_53b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_53b_goodG2BSink(char * data);
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_53b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_53_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_53_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_53_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_44.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
static void badSink(char * data)
{
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_44_bad()
{
    char * data;
    void (*funcPtr) (char *) = badSink;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(char * data)
{
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
static void goodG2B()
{
    char * data;
    void (*funcPtr) (char *) = goodG2BSink;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    funcPtr(data);
}
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_44_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_44_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_44_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_execlp_67a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#ifdef _WIN32
#include <process.h>
#define EXECLP _wexeclp
#else 
#define EXECLP execlp
#endif
typedef struct _CWE78_OS_Command_Injection__wchar_t_file_execlp_67_structType
{
    wchar_t * structFirst;
} CWE78_OS_Command_Injection__wchar_t_file_execlp_67_structType;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_execlp_67b_badSink(CWE78_OS_Command_Injection__wchar_t_file_execlp_67_structType myStruct);
void CWE78_OS_Command_Injection__wchar_t_file_execlp_67_bad()
{
    wchar_t * data;
    CWE78_OS_Command_Injection__wchar_t_file_execlp_67_structType myStruct;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = wcslen(data);
        FILE * pFile;
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgetws() failed"");
                    data[dataLen] = L'\0';
                }
                fclose(pFile);
            }
        }
    }
    myStruct.structFirst = data;
    CWE78_OS_Command_Injection__wchar_t_file_execlp_67b_badSink(myStruct);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_file_execlp_67b_goodG2BSink(CWE78_OS_Command_Injection__wchar_t_file_execlp_67_structType myStruct);
static void goodG2B()
{
    wchar_t * data;
    CWE78_OS_Command_Injection__wchar_t_file_execlp_67_structType myStruct;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    myStruct.structFirst = data;
    CWE78_OS_Command_Injection__wchar_t_file_execlp_67b_goodG2BSink(myStruct);
}
void CWE78_OS_Command_Injection__wchar_t_file_execlp_67_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_file_execlp_67_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_file_execlp_67_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_w32_spawnv_42.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
static char * badSource(char * data)
{
    {
        size_t dataLen = strlen(data);
        if (100-dataLen > 1)
        {
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                data[dataLen] = '\0';
            }
        }
    }
    return data;
}
void CWE78_OS_Command_Injection__char_console_w32_spawnv_42_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    data = badSource(data);
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static char * goodG2BSource(char * data)
{
    strcat(data, ""*.*"");
    return data;
}
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    data = goodG2BSource(data);
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__char_console_w32_spawnv_42_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_console_w32_spawnv_42_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_console_w32_spawnv_42_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_w32_spawnlp_65a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnlp_65b_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnlp_65_bad()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = CWE78_OS_Command_Injection__wchar_t_console_w32_spawnlp_65b_badSink;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = wcslen(data);
        if (100-dataLen > 1)
        {
            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                dataLen = wcslen(data);
                if (dataLen > 0 && data[dataLen-1] == L'\n')
                {
                    data[dataLen-1] = L'\0';
                }
            }
            else
            {
                printLine(""fgetws() failed"");
                data[dataLen] = L'\0';
            }
        }
    }
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnlp_65b_goodG2BSink(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = CWE78_OS_Command_Injection__wchar_t_console_w32_spawnlp_65b_goodG2BSink;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    funcPtr(data);
}
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnlp_65_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_console_w32_spawnlp_65_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_console_w32_spawnlp_65_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_68b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#define EXECVP _wexecvp
extern wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_68_badData;
extern wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_68_goodG2BData;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_68b_badSink()
{
    wchar_t * data = CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_68_badData;
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_68b_goodG2BSink()
{
    wchar_t * data = CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_68_goodG2BData;
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
#endif"
CWE78_OS_Command_Injection__char_console_w32spawnl_66b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_w32spawnl_66b_badSink(char * dataArray[])
{
    char * data = dataArray[2];
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_console_w32spawnl_66b_goodG2BSink(char * dataArray[])
{
    char * data = dataArray[2];
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_w32_execvp_31.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#define EXECVP _wexecvp
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_w32_execvp_31_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = wcslen(data);
        if (100-dataLen > 1)
        {
            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                dataLen = wcslen(data);
                if (dataLen > 0 && data[dataLen-1] == L'\n')
                {
                    data[dataLen-1] = L'\0';
                }
            }
            else
            {
                printLine(""fgetws() failed"");
                data[dataLen] = L'\0';
            }
        }
    }
    {
        wchar_t * dataCopy = data;
        wchar_t * data = dataCopy;
        {
            wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
            EXECVP(COMMAND_INT, args);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    {
        wchar_t * dataCopy = data;
        wchar_t * data = dataCopy;
        {
            wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
            EXECVP(COMMAND_INT, args);
        }
    }
}
void CWE78_OS_Command_Injection__wchar_t_console_w32_execvp_31_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_console_w32_execvp_31_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_console_w32_execvp_31_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_popen_22a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#define POPEN _popen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
int CWE78_OS_Command_Injection__char_console_popen_22_badGlobal = 0;
char * CWE78_OS_Command_Injection__char_console_popen_22_badSource(char * data);
void CWE78_OS_Command_Injection__char_console_popen_22_bad()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    CWE78_OS_Command_Injection__char_console_popen_22_badGlobal = 1; 
    data = CWE78_OS_Command_Injection__char_console_popen_22_badSource(data);
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif 
#ifndef OMITGOOD
int CWE78_OS_Command_Injection__char_console_popen_22_goodG2B1Global = 0;
int CWE78_OS_Command_Injection__char_console_popen_22_goodG2B2Global = 0;
char * CWE78_OS_Command_Injection__char_console_popen_22_goodG2B1Source(char * data);
static void goodG2B1()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    CWE78_OS_Command_Injection__char_console_popen_22_goodG2B1Global = 0; 
    data = CWE78_OS_Command_Injection__char_console_popen_22_goodG2B1Source(data);
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
char * CWE78_OS_Command_Injection__char_console_popen_22_goodG2B2Source(char * data);
static void goodG2B2()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    CWE78_OS_Command_Injection__char_console_popen_22_goodG2B2Global = 1; 
    data = CWE78_OS_Command_Injection__char_console_popen_22_goodG2B2Source(data);
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
void CWE78_OS_Command_Injection__char_console_popen_22_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_console_popen_22_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_console_popen_22_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_66b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_66b_badSink(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    _wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_66b_goodG2BSink(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    _wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_system_01.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#define SYSTEM _wsystem
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_system_01_bad()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        size_t dataLen = wcslen(data);
        wchar_t * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            wcsncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    wcscat(data, L""*.*"");
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
void CWE78_OS_Command_Injection__wchar_t_environment_system_01_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_system_01_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_system_01_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_execv_07.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#define EXECV _execv
static int staticFive = 5;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32_execv_07_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(char)] = '\0';
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFive==5)
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__char_connect_socket_w32_execv_07_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_execv_07_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_execv_07_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_w32spawnl_52b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_w32spawnl_52c_badSink(char * data);
void CWE78_OS_Command_Injection__char_console_w32spawnl_52b_badSink(char * data)
{
    CWE78_OS_Command_Injection__char_console_w32spawnl_52c_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_console_w32spawnl_52c_goodG2BSink(char * data);
void CWE78_OS_Command_Injection__char_console_w32spawnl_52b_goodG2BSink(char * data)
{
    CWE78_OS_Command_Injection__char_console_w32spawnl_52c_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__char_console_w32_execv_34.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#define EXECV _execv
typedef union
{
    char * unionFirst;
    char * unionSecond;
} CWE78_OS_Command_Injection__char_console_w32_execv_34_unionType;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_w32_execv_34_bad()
{
    char * data;
    CWE78_OS_Command_Injection__char_console_w32_execv_34_unionType myUnion;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        if (100-dataLen > 1)
        {
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                data[dataLen] = '\0';
            }
        }
    }
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
            EXECV(COMMAND_INT_PATH, args);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    CWE78_OS_Command_Injection__char_console_w32_execv_34_unionType myUnion;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
            EXECV(COMMAND_INT_PATH, args);
        }
    }
}
void CWE78_OS_Command_Injection__char_console_w32_execv_34_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_console_w32_execv_34_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_console_w32_execv_34_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_execlp_41.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_execlp_41_badSink(char * data)
{
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_connect_socket_execlp_41_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__char_connect_socket_execlp_41_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_connect_socket_execlp_41_goodG2BSink(char * data)
{
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_connect_socket_execlp_41_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__char_connect_socket_execlp_41_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_execlp_41_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_execlp_41_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_popen_01.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#define POPEN _wpopen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_popen_01_bad()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        size_t dataLen = wcslen(data);
        if (100-dataLen > 1)
        {
            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                dataLen = wcslen(data);
                if (dataLen > 0 && data[dataLen-1] == L'\n')
                {
                    data[dataLen-1] = L'\0';
                }
            }
            else
            {
                printLine(""fgetws() failed"");
                data[dataLen] = L'\0';
            }
        }
    }
    {
        FILE *pipe;
        pipe = POPEN(data, L""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    wcscat(data, L""*.*"");
    {
        FILE *pipe;
        pipe = POPEN(data, L""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
void CWE78_OS_Command_Injection__wchar_t_console_popen_01_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_console_popen_01_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_console_popen_01_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_execl_08.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#include <process.h>
#define EXECL _wexecl
#else 
#define EXECL execl
#endif
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_execl_08_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        {
            size_t dataLen = wcslen(data);
            wchar_t * environment = GETENV(ENV_VARIABLE);
            if (environment != NULL)
            {
                wcsncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        wcscat(data, L""*.*"");
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_environment_execl_08_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_execl_08_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_execl_08_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_execlp_64a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <process.h>
#define EXECLP _wexeclp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_execlp_64b_badSink(void * dataVoidPtr);
void CWE78_OS_Command_Injection__wchar_t_console_execlp_64_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = wcslen(data);
        if (100-dataLen > 1)
        {
            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                dataLen = wcslen(data);
                if (dataLen > 0 && data[dataLen-1] == L'\n')
                {
                    data[dataLen-1] = L'\0';
                }
            }
            else
            {
                printLine(""fgetws() failed"");
                data[dataLen] = L'\0';
            }
        }
    }
    CWE78_OS_Command_Injection__wchar_t_console_execlp_64b_badSink(&data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_console_execlp_64b_goodG2BSink(void * dataVoidPtr);
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_console_execlp_64b_goodG2BSink(&data);
}
void CWE78_OS_Command_Injection__wchar_t_console_execlp_64_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_console_execlp_64_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_console_execlp_64_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_popen_18.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#define POPEN _popen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_popen_18_bad()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    goto source;
source:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    goto source;
source:
    strcat(data, ""*.*"");
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
void CWE78_OS_Command_Injection__char_listen_socket_popen_18_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_listen_socket_popen_18_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_listen_socket_popen_18_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_65b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_65b_badSink(char * data)
{
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_65b_goodG2BSink(char * data)
{
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_execlp_63b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_execlp_63b_badSink(char * * dataPtr)
{
    char * data = *dataPtr;
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_listen_socket_execlp_63b_goodG2BSink(char * * dataPtr)
{
    char * data = *dataPtr;
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_system_61a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#define SYSTEM _wsystem
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_system_61b_badSource(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_listen_socket_system_61_bad()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    data = CWE78_OS_Command_Injection__wchar_t_listen_socket_system_61b_badSource(data);
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif 
#ifndef OMITGOOD
wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_system_61b_goodG2BSource(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    data = CWE78_OS_Command_Injection__wchar_t_listen_socket_system_61b_goodG2BSource(data);
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_system_61_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_system_61_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_system_61_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_popen_54d.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#define POPEN _popen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_popen_54e_badSink(char * data);
void CWE78_OS_Command_Injection__char_console_popen_54d_badSink(char * data)
{
    CWE78_OS_Command_Injection__char_console_popen_54e_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_console_popen_54e_goodG2BSink(char * data);
void CWE78_OS_Command_Injection__char_console_popen_54d_goodG2BSink(char * data)
{
    CWE78_OS_Command_Injection__char_console_popen_54e_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_10.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_10_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(char)] = '\0';
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalTrue)
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_10_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_10_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_10_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_66b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_66b_badSink(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_66b_goodG2BSink(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_22b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#ifndef OMITBAD
extern int CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_22_badGlobal;
wchar_t * CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_22_badSource(wchar_t * data)
{
    if(CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_22_badGlobal)
    {
        {
            size_t dataLen = wcslen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgetws() failed"");
                        data[dataLen] = L'\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    return data;
}
#endif 
#ifndef OMITGOOD
extern int CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_22_goodG2B1Global;
extern int CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_22_goodG2B2Global;
wchar_t * CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_22_goodG2B1Source(wchar_t * data)
{
    if(CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_22_goodG2B1Global)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    return data;
}
wchar_t * CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_22_goodG2B2Source(wchar_t * data)
{
    if(CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_22_goodG2B2Global)
    {
        wcscat(data, L""*.*"");
    }
    return data;
}
#endif"
CWE78_OS_Command_Injection__char_environment_w32_spawnlp_01.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_w32_spawnlp_01_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_environment_w32_spawnlp_01_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_environment_w32_spawnlp_01_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_environment_w32_spawnlp_01_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_w32_spawnv_61a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
char * CWE78_OS_Command_Injection__char_console_w32_spawnv_61b_badSource(char * data);
void CWE78_OS_Command_Injection__char_console_w32_spawnv_61_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    data = CWE78_OS_Command_Injection__char_console_w32_spawnv_61b_badSource(data);
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
char * CWE78_OS_Command_Injection__char_console_w32_spawnv_61b_goodG2BSource(char * data);
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    data = CWE78_OS_Command_Injection__char_console_w32_spawnv_61b_goodG2BSource(data);
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__char_console_w32_spawnv_61_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_console_w32_spawnv_61_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_console_w32_spawnv_61_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_53b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#define EXECV _wexecv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_53c_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_53b_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_53c_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_53c_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_53b_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_53c_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_popen_22b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifndef OMITBAD
extern int CWE78_OS_Command_Injection__char_connect_socket_popen_22_badGlobal;
char * CWE78_OS_Command_Injection__char_connect_socket_popen_22_badSource(char * data)
{
    if(CWE78_OS_Command_Injection__char_connect_socket_popen_22_badGlobal)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(char)] = '\0';
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    return data;
}
#endif 
#ifndef OMITGOOD
extern int CWE78_OS_Command_Injection__char_connect_socket_popen_22_goodG2B1Global;
extern int CWE78_OS_Command_Injection__char_connect_socket_popen_22_goodG2B2Global;
char * CWE78_OS_Command_Injection__char_connect_socket_popen_22_goodG2B1Source(char * data)
{
    if(CWE78_OS_Command_Injection__char_connect_socket_popen_22_goodG2B1Global)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    return data;
}
char * CWE78_OS_Command_Injection__char_connect_socket_popen_22_goodG2B2Source(char * data)
{
    if(CWE78_OS_Command_Injection__char_connect_socket_popen_22_goodG2B2Global)
    {
        strcat(data, ""*.*"");
    }
    return data;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_54c.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_54d_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_54c_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_54d_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_54d_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_54c_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_54d_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_53b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#include <process.h>
#define EXECL _wexecl
#else 
#define EXECL execl
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_53c_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_53b_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_53c_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_53c_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_53b_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_53c_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_execl_34.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif
typedef union
{
    char * unionFirst;
    char * unionSecond;
} CWE78_OS_Command_Injection__char_connect_socket_execl_34_unionType;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_execl_34_bad()
{
    char * data;
    CWE78_OS_Command_Injection__char_connect_socket_execl_34_unionType myUnion;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    CWE78_OS_Command_Injection__char_connect_socket_execl_34_unionType myUnion;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
    }
}
void CWE78_OS_Command_Injection__char_connect_socket_execl_34_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_execl_34_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_execl_34_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_system_22b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifndef OMITBAD
extern int CWE78_OS_Command_Injection__char_console_system_22_badGlobal;
char * CWE78_OS_Command_Injection__char_console_system_22_badSource(char * data)
{
    if(CWE78_OS_Command_Injection__char_console_system_22_badGlobal)
    {
        {
            size_t dataLen = strlen(data);
            if (100-dataLen > 1)
            {
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    data[dataLen] = '\0';
                }
            }
        }
    }
    return data;
}
#endif 
#ifndef OMITGOOD
extern int CWE78_OS_Command_Injection__char_console_system_22_goodG2B1Global;
extern int CWE78_OS_Command_Injection__char_console_system_22_goodG2B2Global;
char * CWE78_OS_Command_Injection__char_console_system_22_goodG2B1Source(char * data)
{
    if(CWE78_OS_Command_Injection__char_console_system_22_goodG2B1Global)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    return data;
}
char * CWE78_OS_Command_Injection__char_console_system_22_goodG2B2Source(char * data)
{
    if(CWE78_OS_Command_Injection__char_console_system_22_goodG2B2Global)
    {
        strcat(data, ""*.*"");
    }
    return data;
}
#endif"
CWE78_OS_Command_Injection__char_environment_execl_65a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_execl_65b_badSink(char * data);
void CWE78_OS_Command_Injection__char_environment_execl_65_bad()
{
    char * data;
    void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_environment_execl_65b_badSink;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_environment_execl_65b_goodG2BSink(char * data);
static void goodG2B()
{
    char * data;
    void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_environment_execl_65b_goodG2BSink;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    funcPtr(data);
}
void CWE78_OS_Command_Injection__char_environment_execl_65_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_environment_execl_65_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_environment_execl_65_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_09.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_09_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        {
            size_t dataLen = wcslen(data);
            wchar_t * environment = GETENV(ENV_VARIABLE);
            if (environment != NULL)
            {
                wcsncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        wcscat(data, L""*.*"");
    }
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_09_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_09_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_09_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_63a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#define EXECVP _execvp
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_63b_badSink(char * * dataPtr);
void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_63_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_63b_badSink(&data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_63b_goodG2BSink(char * * data);
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_63b_goodG2BSink(&data);
}
void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_63_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_63_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_63_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_system_10.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#define SYSTEM system
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_system_10_bad()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(char)] = '\0';
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
static void goodG2B2()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalTrue)
    {
        strcat(data, ""*.*"");
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
void CWE78_OS_Command_Injection__char_connect_socket_system_10_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_system_10_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_system_10_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_63b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#define POPEN _wpopen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_63b_badSink(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    {
        FILE *pipe;
        pipe = POPEN(data, L""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_63b_goodG2BSink(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    {
        FILE *pipe;
        pipe = POPEN(data, L""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_popen_61a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#ifdef _WIN32
#define POPEN _wpopen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
wchar_t * CWE78_OS_Command_Injection__wchar_t_file_popen_61b_badSource(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_file_popen_61_bad()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    data = CWE78_OS_Command_Injection__wchar_t_file_popen_61b_badSource(data);
    {
        FILE *pipe;
        pipe = POPEN(data, L""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif 
#ifndef OMITGOOD
wchar_t * CWE78_OS_Command_Injection__wchar_t_file_popen_61b_goodG2BSource(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    data = CWE78_OS_Command_Injection__wchar_t_file_popen_61b_goodG2BSource(data);
    {
        FILE *pipe;
        pipe = POPEN(data, L""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
void CWE78_OS_Command_Injection__wchar_t_file_popen_61_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_file_popen_61_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_file_popen_61_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_08.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#include <process.h>
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_08_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        {
            size_t dataLen = wcslen(data);
            wchar_t * environment = GETENV(ENV_VARIABLE);
            if (environment != NULL)
            {
                wcsncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_08_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_08_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_08_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_52a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_52b_badSink(char * data);
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_52_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_52b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_52b_goodG2BSink(char * data);
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_52b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_52_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_52_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_52_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_53c.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_53d_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_53c_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_53d_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_53d_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_53c_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_53d_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_popen_66b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#define POPEN _wpopen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_popen_66b_badSink(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    {
        FILE *pipe;
        pipe = POPEN(data, L""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_environment_popen_66b_goodG2BSink(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    {
        FILE *pipe;
        pipe = POPEN(data, L""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif"
CWE78_OS_Command_Injection__char_console_execlp_11.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_execlp_11_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        {
            size_t dataLen = strlen(data);
            if (100-dataLen > 1)
            {
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    data[dataLen] = '\0';
                }
            }
        }
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        strcat(data, ""*.*"");
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_console_execlp_11_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_console_execlp_11_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_console_execlp_11_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_16.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_16_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    while(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(char)] = '\0';
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        break;
    }
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    while(1)
    {
        strcat(data, ""*.*"");
        break;
    }
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_16_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_16_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_16_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_31.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_31_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = wcslen(data);
        if (100-dataLen > 1)
        {
            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                dataLen = wcslen(data);
                if (dataLen > 0 && data[dataLen-1] == L'\n')
                {
                    data[dataLen-1] = L'\0';
                }
            }
            else
            {
                printLine(""fgetws() failed"");
                data[dataLen] = L'\0';
            }
        }
    }
    {
        wchar_t * dataCopy = data;
        wchar_t * data = dataCopy;
        {
            wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
            _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    {
        wchar_t * dataCopy = data;
        wchar_t * data = dataCopy;
        {
            wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
            _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
        }
    }
}
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_31_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_31_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_31_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_execlp_53b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <process.h>
#define EXECLP _wexeclp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_execlp_53c_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_console_execlp_53b_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_console_execlp_53c_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_console_execlp_53c_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_console_execlp_53b_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_console_execlp_53c_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_54d.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_54e_badSink(char * data);
void CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_54d_badSink(char * data)
{
    CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_54e_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_54e_goodG2BSink(char * data);
void CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_54d_goodG2BSink(char * data)
{
    CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_54e_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_system_42.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#define SYSTEM _wsystem
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
static wchar_t * badSource(wchar_t * data)
{
    {
        size_t dataLen = wcslen(data);
        if (100-dataLen > 1)
        {
            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                dataLen = wcslen(data);
                if (dataLen > 0 && data[dataLen-1] == L'\n')
                {
                    data[dataLen-1] = L'\0';
                }
            }
            else
            {
                printLine(""fgetws() failed"");
                data[dataLen] = L'\0';
            }
        }
    }
    return data;
}
void CWE78_OS_Command_Injection__wchar_t_console_system_42_bad()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    data = badSource(data);
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif 
#ifndef OMITGOOD
static wchar_t * goodG2BSource(wchar_t * data)
{
    wcscat(data, L""*.*"");
    return data;
}
static void goodG2B()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    data = goodG2BSource(data);
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
void CWE78_OS_Command_Injection__wchar_t_console_system_42_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_console_system_42_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_console_system_42_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_11.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#define EXECVP _execvp
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_11_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(char)] = '\0';
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_11_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_11_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_11_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_w32spawnl_54a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_w32spawnl_54b_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_console_w32spawnl_54_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = wcslen(data);
        if (100-dataLen > 1)
        {
            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                dataLen = wcslen(data);
                if (dataLen > 0 && data[dataLen-1] == L'\n')
                {
                    data[dataLen-1] = L'\0';
                }
            }
            else
            {
                printLine(""fgetws() failed"");
                data[dataLen] = L'\0';
            }
        }
    }
    CWE78_OS_Command_Injection__wchar_t_console_w32spawnl_54b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_console_w32spawnl_54b_goodG2BSink(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_console_w32spawnl_54b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__wchar_t_console_w32spawnl_54_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_console_w32spawnl_54_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_console_w32spawnl_54_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_05.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_05_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    _wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    _wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticTrue)
    {
        wcscat(data, L""*.*"");
    }
    _wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_05_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_05_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_05_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_popen_42.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#define POPEN _popen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
static char * badSource(char * data)
{
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    return data;
}
void CWE78_OS_Command_Injection__char_listen_socket_popen_42_bad()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    data = badSource(data);
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif 
#ifndef OMITGOOD
static char * goodG2BSource(char * data)
{
    strcat(data, ""*.*"");
    return data;
}
static void goodG2B()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    data = goodG2BSource(data);
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
void CWE78_OS_Command_Injection__char_listen_socket_popen_42_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_listen_socket_popen_42_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_listen_socket_popen_42_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_file_w32_execv_10.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#define EXECV _execv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_w32_execv_10_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalTrue)
    {
        {
            size_t dataLen = strlen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalTrue)
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__char_file_w32_execv_10_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_file_w32_execv_10_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_file_w32_execv_10_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_system_08.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#ifdef _WIN32
#define SYSTEM _wsystem
#else 
#define SYSTEM system
#endif
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_system_08_bad()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(staticReturnsTrue())
    {
        {
            size_t dataLen = wcslen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgetws() failed"");
                        data[dataLen] = L'\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(staticReturnsTrue())
    {
        wcscat(data, L""*.*"");
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
void CWE78_OS_Command_Injection__wchar_t_file_system_08_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_file_system_08_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_file_system_08_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_system_11.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#define SYSTEM system
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_system_11_bad()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(char)] = '\0';
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
static void goodG2B2()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalReturnsTrue())
    {
        strcat(data, ""*.*"");
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
void CWE78_OS_Command_Injection__char_listen_socket_system_11_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_listen_socket_system_11_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_listen_socket_system_11_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_w32_execvp_54d.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#define EXECVP _wexecvp
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_w32_execvp_54e_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_console_w32_execvp_54d_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_console_w32_execvp_54e_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_console_w32_execvp_54e_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_console_w32_execvp_54d_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_console_w32_execvp_54e_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__char_file_w32_spawnlp_32.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_w32_spawnlp_32_bad()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        {
            size_t dataLen = strlen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        strcat(data, ""*.*"");
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
    }
}
void CWE78_OS_Command_Injection__char_file_w32_spawnlp_32_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_file_w32_spawnlp_32_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_file_w32_spawnlp_32_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_system_54a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#define SYSTEM _wsystem
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_system_54b_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_console_system_54_bad()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        size_t dataLen = wcslen(data);
        if (100-dataLen > 1)
        {
            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                dataLen = wcslen(data);
                if (dataLen > 0 && data[dataLen-1] == L'\n')
                {
                    data[dataLen-1] = L'\0';
                }
            }
            else
            {
                printLine(""fgetws() failed"");
                data[dataLen] = L'\0';
            }
        }
    }
    CWE78_OS_Command_Injection__wchar_t_console_system_54b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_console_system_54b_goodG2BSink(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_console_system_54b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__wchar_t_console_system_54_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_console_system_54_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_console_system_54_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_system_10.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#define SYSTEM _wsystem
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_system_10_bad()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalTrue)
    {
        wcscat(data, L""*.*"");
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
void CWE78_OS_Command_Injection__wchar_t_connect_socket_system_10_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_system_10_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_system_10_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_w32spawnl_09.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_w32spawnl_09_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        {
            size_t dataLen = wcslen(data);
            if (100-dataLen > 1)
            {
                if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    dataLen = wcslen(data);
                    if (dataLen > 0 && data[dataLen-1] == L'\n')
                    {
                        data[dataLen-1] = L'\0';
                    }
                }
                else
                {
                    printLine(""fgetws() failed"");
                    data[dataLen] = L'\0';
                }
            }
        }
    }
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        wcscat(data, L""*.*"");
    }
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_console_w32spawnl_09_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_console_w32spawnl_09_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_console_w32spawnl_09_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_file_w32_execvp_66a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#define EXECVP _execvp
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_w32_execvp_66b_badSink(char * dataArray[]);
void CWE78_OS_Command_Injection__char_file_w32_execvp_66_bad()
{
    char * data;
    char * dataArray[5];
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        FILE * pFile;
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    dataArray[2] = data;
    CWE78_OS_Command_Injection__char_file_w32_execvp_66b_badSink(dataArray);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_file_w32_execvp_66b_goodG2BSink(char * dataArray[]);
static void goodG2B()
{
    char * data;
    char * dataArray[5];
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    dataArray[2] = data;
    CWE78_OS_Command_Injection__char_file_w32_execvp_66b_goodG2BSink(dataArray);
}
void CWE78_OS_Command_Injection__char_file_w32_execvp_66_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_file_w32_execvp_66_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_file_w32_execvp_66_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_14.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#include <process.h>
#define EXECLP _wexeclp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_14_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalFive==5)
    {
        wcscat(data, L""*.*"");
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_14_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_14_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_14_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_01.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_01_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = wcslen(data);
        FILE * pFile;
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgetws() failed"");
                    data[dataLen] = L'\0';
                }
                fclose(pFile);
            }
        }
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_01_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_01_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_01_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_w32spawnl_10.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_w32spawnl_10_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalTrue)
    {
        {
            size_t dataLen = strlen(data);
            if (100-dataLen > 1)
            {
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    data[dataLen] = '\0';
                }
            }
        }
    }
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalTrue)
    {
        strcat(data, ""*.*"");
    }
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_console_w32spawnl_10_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_console_w32spawnl_10_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_console_w32spawnl_10_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_16.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_16_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    while(1)
    {
        {
            size_t dataLen = wcslen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgetws() failed"");
                        data[dataLen] = L'\0';
                    }
                    fclose(pFile);
                }
            }
        }
        break;
    }
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    while(1)
    {
        wcscat(data, L""*.*"");
        break;
    }
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_16_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_16_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_16_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_system_65a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#define SYSTEM system
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_system_65b_badSink(char * data);
void CWE78_OS_Command_Injection__char_console_system_65_bad()
{
    char * data;
    void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_console_system_65b_badSink;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        size_t dataLen = strlen(data);
        if (100-dataLen > 1)
        {
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                data[dataLen] = '\0';
            }
        }
    }
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_console_system_65b_goodG2BSink(char * data);
static void goodG2B()
{
    char * data;
    void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_console_system_65b_goodG2BSink;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    strcat(data, ""*.*"");
    funcPtr(data);
}
void CWE78_OS_Command_Injection__char_console_system_65_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_console_system_65_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_console_system_65_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_10.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#include <process.h>
#define EXECL _wexecl
#else 
#define EXECL execl
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_10_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalTrue)
    {
        wcscat(data, L""*.*"");
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_10_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_10_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_10_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_64a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_64b_badSink(void * dataVoidPtr);
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_64_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        wchar_t *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = wcslen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
            replace = wcschr(data, L'\r');
            if (replace)
            {
                *replace = L'\0';
            }
            replace = wcschr(data, L'\n');
            if (replace)
            {
                *replace = L'\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_64b_badSink(&data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_64b_goodG2BSink(void * dataVoidPtr);
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_64b_goodG2BSink(&data);
}
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_64_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_64_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_64_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_08.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_08_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_08_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_08_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_08_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_w32_spawnv_12.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_w32_spawnv_12_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        {
            size_t dataLen = wcslen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgetws() failed"");
                        data[dataLen] = L'\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        wcscat(data, L""*.*"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_file_w32_spawnv_12_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_spawnv_12_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_spawnv_12_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_file_execlp_22b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#ifndef OMITBAD
extern int CWE78_OS_Command_Injection__char_file_execlp_22_badGlobal;
char * CWE78_OS_Command_Injection__char_file_execlp_22_badSource(char * data)
{
    if(CWE78_OS_Command_Injection__char_file_execlp_22_badGlobal)
    {
        {
            size_t dataLen = strlen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    return data;
}
#endif 
#ifndef OMITGOOD
extern int CWE78_OS_Command_Injection__char_file_execlp_22_goodG2B1Global;
extern int CWE78_OS_Command_Injection__char_file_execlp_22_goodG2B2Global;
char * CWE78_OS_Command_Injection__char_file_execlp_22_goodG2B1Source(char * data)
{
    if(CWE78_OS_Command_Injection__char_file_execlp_22_goodG2B1Global)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    return data;
}
char * CWE78_OS_Command_Injection__char_file_execlp_22_goodG2B2Source(char * data)
{
    if(CWE78_OS_Command_Injection__char_file_execlp_22_goodG2B2Global)
    {
        strcat(data, ""*.*"");
    }
    return data;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_06.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#define EXECVP _execvp
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_06_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(char)] = '\0';
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
void CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_06_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_06_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_06_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_execl_53b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#include <process.h>
#define EXECL _wexecl
#else 
#define EXECL execl
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_execl_53c_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_environment_execl_53b_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_environment_execl_53c_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_environment_execl_53c_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_environment_execl_53b_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_environment_execl_53c_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_execl_52b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_execl_52c_badSink(char * data);
void CWE78_OS_Command_Injection__char_listen_socket_execl_52b_badSink(char * data)
{
    CWE78_OS_Command_Injection__char_listen_socket_execl_52c_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_listen_socket_execl_52c_goodG2BSink(char * data);
void CWE78_OS_Command_Injection__char_listen_socket_execl_52b_goodG2BSink(char * data)
{
    CWE78_OS_Command_Injection__char_listen_socket_execl_52c_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_popen_22b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifndef OMITBAD
extern int CWE78_OS_Command_Injection__char_listen_socket_popen_22_badGlobal;
char * CWE78_OS_Command_Injection__char_listen_socket_popen_22_badSource(char * data)
{
    if(CWE78_OS_Command_Injection__char_listen_socket_popen_22_badGlobal)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(char)] = '\0';
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    return data;
}
#endif 
#ifndef OMITGOOD
extern int CWE78_OS_Command_Injection__char_listen_socket_popen_22_goodG2B1Global;
extern int CWE78_OS_Command_Injection__char_listen_socket_popen_22_goodG2B2Global;
char * CWE78_OS_Command_Injection__char_listen_socket_popen_22_goodG2B1Source(char * data)
{
    if(CWE78_OS_Command_Injection__char_listen_socket_popen_22_goodG2B1Global)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    return data;
}
char * CWE78_OS_Command_Injection__char_listen_socket_popen_22_goodG2B2Source(char * data)
{
    if(CWE78_OS_Command_Injection__char_listen_socket_popen_22_goodG2B2Global)
    {
        strcat(data, ""*.*"");
    }
    return data;
}
#endif"
CWE78_OS_Command_Injection__char_environment_execlp_11.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_execlp_11_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        {
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            if (environment != NULL)
            {
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        strcat(data, ""*.*"");
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_environment_execlp_11_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_environment_execlp_11_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_environment_execlp_11_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_08.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#include <process.h>
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_08_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        {
            size_t dataLen = wcslen(data);
            wchar_t * environment = GETENV(ENV_VARIABLE);
            if (environment != NULL)
            {
                wcsncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_08_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_08_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_08_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_environment_w32_execv_65b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#include <process.h>
#define EXECV _execv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_w32_execv_65b_badSink(char * data)
{
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_environment_w32_execv_65b_goodG2BSink(char * data)
{
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif"
CWE78_OS_Command_Injection__char_console_system_54a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#define SYSTEM system
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_system_54b_badSink(char * data);
void CWE78_OS_Command_Injection__char_console_system_54_bad()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        size_t dataLen = strlen(data);
        if (100-dataLen > 1)
        {
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                data[dataLen] = '\0';
            }
        }
    }
    CWE78_OS_Command_Injection__char_console_system_54b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_console_system_54b_goodG2BSink(char * data);
static void goodG2B()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_console_system_54b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__char_console_system_54_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_console_system_54_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_console_system_54_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_environment_execlp_61b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
char * CWE78_OS_Command_Injection__char_environment_execlp_61b_badSource(char * data)
{
    {
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    return data;
}
#endif 
#ifndef OMITGOOD
char * CWE78_OS_Command_Injection__char_environment_execlp_61b_goodG2BSource(char * data)
{
    strcat(data, ""*.*"");
    return data;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_05.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#include <process.h>
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_05_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticTrue)
    {
        {
            size_t dataLen = wcslen(data);
            wchar_t * environment = GETENV(ENV_VARIABLE);
            if (environment != NULL)
            {
                wcsncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    _wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    _wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticTrue)
    {
        wcscat(data, L""*.*"");
    }
    _wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_05_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_05_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_05_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_popen_51a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#ifdef _WIN32
#define POPEN _wpopen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_popen_51b_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_file_popen_51_bad()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        size_t dataLen = wcslen(data);
        FILE * pFile;
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgetws() failed"");
                    data[dataLen] = L'\0';
                }
                fclose(pFile);
            }
        }
    }
    CWE78_OS_Command_Injection__wchar_t_file_popen_51b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_file_popen_51b_goodG2BSink(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_file_popen_51b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__wchar_t_file_popen_51_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_file_popen_51_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_file_popen_51_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_21.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#define EXECV _wexecv
#ifndef OMITBAD
static int badStatic = 0;
static wchar_t * badSource(wchar_t * data)
{
    if(badStatic)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    return data;
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_21_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    badStatic = 1; 
    data = badSource(data);
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static int goodG2B1Static = 0;
static int goodG2B2Static = 0;
static wchar_t * goodG2B1Source(wchar_t * data)
{
    if(goodG2B1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    return data;
}
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goodG2B1Static = 0; 
    data = goodG2B1Source(data);
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
static wchar_t * goodG2B2Source(wchar_t * data)
{
    if(goodG2B2Static)
    {
        wcscat(data, L""*.*"");
    }
    return data;
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goodG2B2Static = 1; 
    data = goodG2B2Source(data);
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_21_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_21_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_21_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_63b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#define EXECVP _execvp
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_63b_badSink(char * * dataPtr)
{
    char * data = *dataPtr;
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_63b_goodG2BSink(char * * dataPtr)
{
    char * data = *dataPtr;
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_68b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#define EXECV _wexecv
extern wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_68_badData;
extern wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_68_goodG2BData;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_68b_badSink()
{
    wchar_t * data = CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_68_badData;
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_68b_goodG2BSink()
{
    wchar_t * data = CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_68_goodG2BData;
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif"
CWE78_OS_Command_Injection__char_file_w32_spawnvp_67a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
typedef struct _CWE78_OS_Command_Injection__char_file_w32_spawnvp_67_structType
{
    char * structFirst;
} CWE78_OS_Command_Injection__char_file_w32_spawnvp_67_structType;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_w32_spawnvp_67b_badSink(CWE78_OS_Command_Injection__char_file_w32_spawnvp_67_structType myStruct);
void CWE78_OS_Command_Injection__char_file_w32_spawnvp_67_bad()
{
    char * data;
    CWE78_OS_Command_Injection__char_file_w32_spawnvp_67_structType myStruct;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        FILE * pFile;
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    myStruct.structFirst = data;
    CWE78_OS_Command_Injection__char_file_w32_spawnvp_67b_badSink(myStruct);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_file_w32_spawnvp_67b_goodG2BSink(CWE78_OS_Command_Injection__char_file_w32_spawnvp_67_structType myStruct);
static void goodG2B()
{
    char * data;
    CWE78_OS_Command_Injection__char_file_w32_spawnvp_67_structType myStruct;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    myStruct.structFirst = data;
    CWE78_OS_Command_Injection__char_file_w32_spawnvp_67b_goodG2BSink(myStruct);
}
void CWE78_OS_Command_Injection__char_file_w32_spawnvp_67_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_file_w32_spawnvp_67_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_file_w32_spawnvp_67_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_execl_09.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_execl_09_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(char)] = '\0';
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        strcat(data, ""*.*"");
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_connect_socket_execl_09_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_execl_09_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_execl_09_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_w32_spawnvp_54b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_w32_spawnvp_54c_badSink(char * data);
void CWE78_OS_Command_Injection__char_console_w32_spawnvp_54b_badSink(char * data)
{
    CWE78_OS_Command_Injection__char_console_w32_spawnvp_54c_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_console_w32_spawnvp_54c_goodG2BSink(char * data);
void CWE78_OS_Command_Injection__char_console_w32_spawnvp_54b_goodG2BSink(char * data)
{
    CWE78_OS_Command_Injection__char_console_w32_spawnvp_54c_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_66b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_66b_badSink(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_66b_goodG2BSink(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_system_53c.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#ifdef _WIN32
#define SYSTEM _wsystem
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_system_53d_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_file_system_53c_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_file_system_53d_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_file_system_53d_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_file_system_53c_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_file_system_53d_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_53b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_53c_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_53b_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_53c_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_53c_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_53b_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_53c_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_w32_execv_07.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#define EXECV _wexecv
static int staticFive = 5;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_w32_execv_07_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFive==5)
    {
        {
            size_t dataLen = wcslen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgetws() failed"");
                        data[dataLen] = L'\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFive==5)
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_file_w32_execv_07_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_execv_07_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_execv_07_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_file_w32_spawnvp_64b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_w32_spawnvp_64b_badSink(void * dataVoidPtr)
{
    char * * dataPtr = (char * *)dataVoidPtr;
    char * data = (*dataPtr);
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_file_w32_spawnvp_64b_goodG2BSink(void * dataVoidPtr)
{
    char * * dataPtr = (char * *)dataVoidPtr;
    char * data = (*dataPtr);
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_67b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
typedef struct _CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_67_structType
{
    wchar_t * structFirst;
} CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_67_structType;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_67b_badSink(CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_67_structType myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_67b_goodG2BSink(CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_67_structType myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_execl_07.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <process.h>
#define EXECL _wexecl
#else 
#define EXECL execl
#endif
static int staticFive = 5;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_execl_07_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFive==5)
    {
        {
            size_t dataLen = wcslen(data);
            if (100-dataLen > 1)
            {
                if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    dataLen = wcslen(data);
                    if (dataLen > 0 && data[dataLen-1] == L'\n')
                    {
                        data[dataLen-1] = L'\0';
                    }
                }
                else
                {
                    printLine(""fgetws() failed"");
                    data[dataLen] = L'\0';
                }
            }
        }
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFive==5)
    {
        wcscat(data, L""*.*"");
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_console_execl_07_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_console_execl_07_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_console_execl_07_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_execl_15.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#ifdef _WIN32
#include <process.h>
#define EXECL _wexecl
#else 
#define EXECL execl
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_execl_15_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    switch(6)
    {
    case 6:
    {
        size_t dataLen = wcslen(data);
        FILE * pFile;
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgetws() failed"");
                    data[dataLen] = L'\0';
                }
                fclose(pFile);
            }
        }
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        wcscat(data, L""*.*"");
        break;
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    switch(6)
    {
    case 6:
        wcscat(data, L""*.*"");
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_file_execl_15_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_file_execl_15_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_file_execl_15_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_41.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#define EXECVP _wexecvp
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_41_badSink(wchar_t * data)
{
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_41_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        wchar_t *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = wcslen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
            replace = wcschr(data, L'\r');
            if (replace)
            {
                *replace = L'\0';
            }
            replace = wcschr(data, L'\n');
            if (replace)
            {
                *replace = L'\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_41_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_41_goodG2BSink(wchar_t * data)
{
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_41_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_41_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_41_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_41_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_system_66a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#define SYSTEM _wsystem
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_system_66b_badSink(wchar_t * dataArray[]);
void CWE78_OS_Command_Injection__wchar_t_environment_system_66_bad()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        size_t dataLen = wcslen(data);
        wchar_t * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            wcsncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    dataArray[2] = data;
    CWE78_OS_Command_Injection__wchar_t_environment_system_66b_badSink(dataArray);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_environment_system_66b_goodG2BSink(wchar_t * dataArray[]);
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    wcscat(data, L""*.*"");
    dataArray[2] = data;
    CWE78_OS_Command_Injection__wchar_t_environment_system_66b_goodG2BSink(dataArray);
}
void CWE78_OS_Command_Injection__wchar_t_environment_system_66_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_system_66_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_system_66_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_execlp_04.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <process.h>
#define EXECLP _wexeclp
#else 
#define EXECLP execlp
#endif
static const int STATIC_CONST_TRUE = 1; 
static const int STATIC_CONST_FALSE = 0; 
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_execlp_04_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        {
            size_t dataLen = wcslen(data);
            if (100-dataLen > 1)
            {
                if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    dataLen = wcslen(data);
                    if (dataLen > 0 && data[dataLen-1] == L'\n')
                    {
                        data[dataLen-1] = L'\0';
                    }
                }
                else
                {
                    printLine(""fgetws() failed"");
                    data[dataLen] = L'\0';
                }
            }
        }
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        wcscat(data, L""*.*"");
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_console_execlp_04_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_console_execlp_04_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_console_execlp_04_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_06.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#include <process.h>
#define EXECL _wexecl
#else 
#define EXECL execl
#endif
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_06_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        wcscat(data, L""*.*"");
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_06_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_06_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_06_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_execl_53a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_execl_53b_badSink(char * data);
void CWE78_OS_Command_Injection__char_connect_socket_execl_53_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__char_connect_socket_execl_53b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_connect_socket_execl_53b_goodG2BSink(char * data);
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_connect_socket_execl_53b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__char_connect_socket_execl_53_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_execl_53_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_execl_53_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_09.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_09_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_09_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_09_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_09_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_54a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_54b_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_54_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        wchar_t *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = wcslen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
            replace = wcschr(data, L'\r');
            if (replace)
            {
                *replace = L'\0';
            }
            replace = wcschr(data, L'\n');
            if (replace)
            {
                *replace = L'\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_54b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_54b_goodG2BSink(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_54b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_54_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_54_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_54_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_w32_spawnlp_53d.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_w32_spawnlp_53d_badSink(char * data)
{
    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_console_w32_spawnlp_53d_goodG2BSink(char * data)
{
    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_21.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
static int badStatic = 0;
static char * badSource(char * data)
{
    if(badStatic)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(char)] = '\0';
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    return data;
}
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_21_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    badStatic = 1; 
    data = badSource(data);
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static int goodG2B1Static = 0;
static int goodG2B2Static = 0;
static char * goodG2B1Source(char * data)
{
    if(goodG2B1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    return data;
}
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goodG2B1Static = 0; 
    data = goodG2B1Source(data);
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
static char * goodG2B2Source(char * data)
{
    if(goodG2B2Static)
    {
        strcat(data, ""*.*"");
    }
    return data;
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goodG2B2Static = 1; 
    data = goodG2B2Source(data);
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_21_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_21_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_21_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_execlp_08.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <process.h>
#define EXECLP _wexeclp
#else 
#define EXECLP execlp
#endif
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_execlp_08_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        {
            size_t dataLen = wcslen(data);
            if (100-dataLen > 1)
            {
                if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    dataLen = wcslen(data);
                    if (dataLen > 0 && data[dataLen-1] == L'\n')
                    {
                        data[dataLen-1] = L'\0';
                    }
                }
                else
                {
                    printLine(""fgetws() failed"");
                    data[dataLen] = L'\0';
                }
            }
        }
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        wcscat(data, L""*.*"");
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_console_execlp_08_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_console_execlp_08_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_console_execlp_08_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_64a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_64b_badSink(void * dataVoidPtr);
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_64_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        wchar_t *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = wcslen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
            replace = wcschr(data, L'\r');
            if (replace)
            {
                *replace = L'\0';
            }
            replace = wcschr(data, L'\n');
            if (replace)
            {
                *replace = L'\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_64b_badSink(&data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_64b_goodG2BSink(void * dataVoidPtr);
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_64b_goodG2BSink(&data);
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_64_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_64_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_64_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_45.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#include <process.h>
static wchar_t * CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_45_badData;
static wchar_t * CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_45_goodG2BData;
#ifndef OMITBAD
static void badSink()
{
    wchar_t * data = CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_45_badData;
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_45_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = wcslen(data);
        wchar_t * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            wcsncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_45_badData = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    wchar_t * data = CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_45_goodG2BData;
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_45_goodG2BData = data;
    goodG2BSink();
}
void CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_45_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_45_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_45_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_file_w32spawnl_07.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
static int staticFive = 5;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_w32spawnl_07_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFive==5)
    {
        {
            size_t dataLen = strlen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFive==5)
    {
        strcat(data, ""*.*"");
    }
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_file_w32spawnl_07_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_file_w32spawnl_07_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_file_w32spawnl_07_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_64a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#include <process.h>
#define EXECLP _wexeclp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_64b_badSink(void * dataVoidPtr);
void CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_64_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        wchar_t *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = wcslen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
            replace = wcschr(data, L'\r');
            if (replace)
            {
                *replace = L'\0';
            }
            replace = wcschr(data, L'\n');
            if (replace)
            {
                *replace = L'\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_64b_badSink(&data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_64b_goodG2BSink(void * dataVoidPtr);
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_64b_goodG2BSink(&data);
}
void CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_64_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_64_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_64_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_environment_w32_execvp_31.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#include <process.h>
#define EXECVP _execvp
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_w32_execvp_31_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
            EXECVP(COMMAND_INT, args);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
            EXECVP(COMMAND_INT, args);
        }
    }
}
void CWE78_OS_Command_Injection__char_environment_w32_execvp_31_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_environment_w32_execvp_31_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_environment_w32_execvp_31_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_file_w32spawnl_51a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_w32spawnl_51b_badSink(char * data);
void CWE78_OS_Command_Injection__char_file_w32spawnl_51_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        FILE * pFile;
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    CWE78_OS_Command_Injection__char_file_w32spawnl_51b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_file_w32spawnl_51b_goodG2BSink(char * data);
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_file_w32spawnl_51b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__char_file_w32spawnl_51_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_file_w32spawnl_51_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_file_w32spawnl_51_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_67b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#include <process.h>
typedef struct _CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_67_structType
{
    wchar_t * structFirst;
} CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_67_structType;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_67b_badSink(CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_67_structType myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_67b_goodG2BSink(CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_67_structType myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif"
CWE78_OS_Command_Injection__char_environment_w32_execvp_22b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#ifndef OMITBAD
extern int CWE78_OS_Command_Injection__char_environment_w32_execvp_22_badGlobal;
char * CWE78_OS_Command_Injection__char_environment_w32_execvp_22_badSource(char * data)
{
    if(CWE78_OS_Command_Injection__char_environment_w32_execvp_22_badGlobal)
    {
        {
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            if (environment != NULL)
            {
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    return data;
}
#endif 
#ifndef OMITGOOD
extern int CWE78_OS_Command_Injection__char_environment_w32_execvp_22_goodG2B1Global;
extern int CWE78_OS_Command_Injection__char_environment_w32_execvp_22_goodG2B2Global;
char * CWE78_OS_Command_Injection__char_environment_w32_execvp_22_goodG2B1Source(char * data)
{
    if(CWE78_OS_Command_Injection__char_environment_w32_execvp_22_goodG2B1Global)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    return data;
}
char * CWE78_OS_Command_Injection__char_environment_w32_execvp_22_goodG2B2Source(char * data)
{
    if(CWE78_OS_Command_Injection__char_environment_w32_execvp_22_goodG2B2Global)
    {
        strcat(data, ""*.*"");
    }
    return data;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_54a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_54b_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_54_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        wchar_t *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = wcslen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
            replace = wcschr(data, L'\r');
            if (replace)
            {
                *replace = L'\0';
            }
            replace = wcschr(data, L'\n');
            if (replace)
            {
                *replace = L'\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_54b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_54b_goodG2BSink(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_54b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_54_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_54_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_54_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_53c.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_53d_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_53c_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_53d_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_53d_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_53c_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_53d_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_08.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#define EXECV _wexecv
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_08_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_08_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_08_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_08_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_22b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifndef OMITBAD
extern int CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_22_badGlobal;
wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_22_badSource(wchar_t * data)
{
    if(CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_22_badGlobal)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    return data;
}
#endif 
#ifndef OMITGOOD
extern int CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_22_goodG2B1Global;
extern int CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_22_goodG2B2Global;
wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_22_goodG2B1Source(wchar_t * data)
{
    if(CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_22_goodG2B1Global)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    return data;
}
wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_22_goodG2B2Source(wchar_t * data)
{
    if(CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_22_goodG2B2Global)
    {
        wcscat(data, L""*.*"");
    }
    return data;
}
#endif"
CWE78_OS_Command_Injection__char_environment_popen_53d.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#define POPEN _popen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_popen_53d_badSink(char * data)
{
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_environment_popen_53d_goodG2BSink(char * data)
{
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_53b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_53c_badSink(char * data);
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_53b_badSink(char * data)
{
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_53c_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_53c_goodG2BSink(char * data);
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_53b_goodG2BSink(char * data)
{
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_53c_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__char_file_w32_spawnvp_08.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_w32_spawnvp_08_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        {
            size_t dataLen = strlen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
void CWE78_OS_Command_Injection__char_file_w32_spawnvp_08_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_file_w32_spawnvp_08_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_file_w32_spawnvp_08_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_w32_execv_13.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#define EXECV _execv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_w32_execv_13_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(char)] = '\0';
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_FIVE==5)
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__char_listen_socket_w32_execv_13_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_listen_socket_w32_execv_13_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_listen_socket_w32_execv_13_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_environment_execlp_53a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_execlp_53b_badSink(char * data);
void CWE78_OS_Command_Injection__char_environment_execlp_53_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    CWE78_OS_Command_Injection__char_environment_execlp_53b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_environment_execlp_53b_goodG2BSink(char * data);
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_environment_execlp_53b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__char_environment_execlp_53_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_environment_execlp_53_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_environment_execlp_53_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_execl_66b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_execl_66b_badSink(char * dataArray[])
{
    char * data = dataArray[2];
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_console_execl_66b_goodG2BSink(char * dataArray[])
{
    char * data = dataArray[2];
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_22a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
int CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_22_badGlobal = 0;
char * CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_22_badSource(char * data);
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_22_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_22_badGlobal = 1; 
    data = CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_22_badSource(data);
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
int CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_22_goodG2B1Global = 0;
int CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_22_goodG2B2Global = 0;
char * CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_22_goodG2B1Source(char * data);
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_22_goodG2B1Global = 0; 
    data = CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_22_goodG2B1Source(data);
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
char * CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_22_goodG2B2Source(char * data);
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_22_goodG2B2Global = 1; 
    data = CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_22_goodG2B2Source(data);
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_22_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_22_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_22_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_66b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_66b_badSink(char * dataArray[])
{
    char * data = dataArray[2];
    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_66b_goodG2BSink(char * dataArray[])
{
    char * data = dataArray[2];
    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__char_console_execl_54b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_execl_54c_badSink(char * data);
void CWE78_OS_Command_Injection__char_console_execl_54b_badSink(char * data)
{
    CWE78_OS_Command_Injection__char_console_execl_54c_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_console_execl_54c_goodG2BSink(char * data);
void CWE78_OS_Command_Injection__char_console_execl_54b_goodG2BSink(char * data)
{
    CWE78_OS_Command_Injection__char_console_execl_54c_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_03.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#define EXECV _wexecv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_03_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(5==5)
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_03_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_03_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_03_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_07.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#define POPEN _wpopen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
static int staticFive = 5;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_07_bad()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(staticFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        FILE *pipe;
        pipe = POPEN(data, L""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    {
        FILE *pipe;
        pipe = POPEN(data, L""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(staticFive==5)
    {
        wcscat(data, L""*.*"");
    }
    {
        FILE *pipe;
        pipe = POPEN(data, L""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_07_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_07_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_07_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_execl_63a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_execl_63b_badSink(char * * dataPtr);
void CWE78_OS_Command_Injection__char_listen_socket_execl_63_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__char_listen_socket_execl_63b_badSink(&data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_listen_socket_execl_63b_goodG2BSink(char * * data);
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_listen_socket_execl_63b_goodG2BSink(&data);
}
void CWE78_OS_Command_Injection__char_listen_socket_execl_63_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_listen_socket_execl_63_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_listen_socket_execl_63_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_w32spawnl_32.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_w32spawnl_32_bad()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        {
            size_t dataLen = strlen(data);
            if (100-dataLen > 1)
            {
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    data[dataLen] = '\0';
                }
            }
        }
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        strcat(data, ""*.*"");
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
    }
}
void CWE78_OS_Command_Injection__char_console_w32spawnl_32_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_console_w32spawnl_32_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_console_w32spawnl_32_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_popen_66a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#define POPEN _popen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_popen_66b_badSink(char * dataArray[]);
void CWE78_OS_Command_Injection__char_listen_socket_popen_66_bad()
{
    char * data;
    char * dataArray[5];
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    dataArray[2] = data;
    CWE78_OS_Command_Injection__char_listen_socket_popen_66b_badSink(dataArray);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_listen_socket_popen_66b_goodG2BSink(char * dataArray[]);
static void goodG2B()
{
    char * data;
    char * dataArray[5];
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    strcat(data, ""*.*"");
    dataArray[2] = data;
    CWE78_OS_Command_Injection__char_listen_socket_popen_66b_goodG2BSink(dataArray);
}
void CWE78_OS_Command_Injection__char_listen_socket_popen_66_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_listen_socket_popen_66_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_listen_socket_popen_66_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_51b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_51b_badSink(wchar_t * data)
{
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_51b_goodG2BSink(wchar_t * data)
{
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_18.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_18_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goto source;
source:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goto source;
source:
    strcat(data, ""*.*"");
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_18_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_18_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_18_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_53c.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_53d_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_53c_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_53d_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_53d_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_53c_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_53d_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_execl_32.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#include <process.h>
#define EXECL _wexecl
#else 
#define EXECL execl
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_execl_32_bad()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        wchar_t * data = *dataPtr1;
        {
            size_t dataLen = wcslen(data);
            wchar_t * environment = GETENV(ENV_VARIABLE);
            if (environment != NULL)
            {
                wcsncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        wchar_t * data = *dataPtr1;
        wcscat(data, L""*.*"");
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
    }
}
void CWE78_OS_Command_Injection__wchar_t_environment_execl_32_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_execl_32_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_execl_32_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_w32_execvp_05.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#define EXECVP _wexecvp
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_w32_execvp_05_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticTrue)
    {
        {
            size_t dataLen = wcslen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgetws() failed"");
                        data[dataLen] = L'\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticTrue)
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_file_w32_execvp_05_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_execvp_05_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_execvp_05_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_44.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#ifndef OMITBAD
static void badSink(char * data)
{
    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_44_bad()
{
    char * data;
    void (*funcPtr) (char *) = badSink;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(char * data)
{
    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B()
{
    char * data;
    void (*funcPtr) (char *) = goodG2BSink;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    funcPtr(data);
}
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_44_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_44_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_44_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_popen_66a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#define POPEN _wpopen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_popen_66b_badSink(wchar_t * dataArray[]);
void CWE78_OS_Command_Injection__wchar_t_environment_popen_66_bad()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        size_t dataLen = wcslen(data);
        wchar_t * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            wcsncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    dataArray[2] = data;
    CWE78_OS_Command_Injection__wchar_t_environment_popen_66b_badSink(dataArray);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_environment_popen_66b_goodG2BSink(wchar_t * dataArray[]);
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    wcscat(data, L""*.*"");
    dataArray[2] = data;
    CWE78_OS_Command_Injection__wchar_t_environment_popen_66b_goodG2BSink(dataArray);
}
void CWE78_OS_Command_Injection__wchar_t_environment_popen_66_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_popen_66_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_popen_66_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_file_w32spawnl_21.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#ifndef OMITBAD
static int badStatic = 0;
static char * badSource(char * data)
{
    if(badStatic)
    {
        {
            size_t dataLen = strlen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    return data;
}
void CWE78_OS_Command_Injection__char_file_w32spawnl_21_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    badStatic = 1; 
    data = badSource(data);
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static int goodG2B1Static = 0;
static int goodG2B2Static = 0;
static char * goodG2B1Source(char * data)
{
    if(goodG2B1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    return data;
}
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goodG2B1Static = 0; 
    data = goodG2B1Source(data);
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static char * goodG2B2Source(char * data)
{
    if(goodG2B2Static)
    {
        strcat(data, ""*.*"");
    }
    return data;
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goodG2B2Static = 1; 
    data = goodG2B2Source(data);
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_file_w32spawnl_21_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_file_w32spawnl_21_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_file_w32spawnl_21_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_w32_execv_54c.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#define EXECV _wexecv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_w32_execv_54d_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_file_w32_execv_54c_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_file_w32_execv_54d_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_file_w32_execv_54d_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_file_w32_execv_54c_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_file_w32_execv_54d_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_execl_67a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif
typedef struct _CWE78_OS_Command_Injection__char_listen_socket_execl_67_structType
{
    char * structFirst;
} CWE78_OS_Command_Injection__char_listen_socket_execl_67_structType;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_execl_67b_badSink(CWE78_OS_Command_Injection__char_listen_socket_execl_67_structType myStruct);
void CWE78_OS_Command_Injection__char_listen_socket_execl_67_bad()
{
    char * data;
    CWE78_OS_Command_Injection__char_listen_socket_execl_67_structType myStruct;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myStruct.structFirst = data;
    CWE78_OS_Command_Injection__char_listen_socket_execl_67b_badSink(myStruct);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_listen_socket_execl_67b_goodG2BSink(CWE78_OS_Command_Injection__char_listen_socket_execl_67_structType myStruct);
static void goodG2B()
{
    char * data;
    CWE78_OS_Command_Injection__char_listen_socket_execl_67_structType myStruct;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    myStruct.structFirst = data;
    CWE78_OS_Command_Injection__char_listen_socket_execl_67b_goodG2BSink(myStruct);
}
void CWE78_OS_Command_Injection__char_listen_socket_execl_67_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_listen_socket_execl_67_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_listen_socket_execl_67_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_system_61b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#define SYSTEM system
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
char * CWE78_OS_Command_Injection__char_listen_socket_system_61b_badSource(char * data)
{
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    return data;
}
#endif 
#ifndef OMITGOOD
char * CWE78_OS_Command_Injection__char_listen_socket_system_61b_goodG2BSource(char * data)
{
    strcat(data, ""*.*"");
    return data;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_execlp_17.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_execlp_17_bad()
{
    int i;
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(char)] = '\0';
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int h;
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    for(h = 0; h < 1; h++)
    {
        strcat(data, ""*.*"");
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_listen_socket_execlp_17_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_listen_socket_execlp_17_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_listen_socket_execlp_17_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_67b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#define EXECVP _execvp
typedef struct _CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_67_structType
{
    char * structFirst;
} CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_67_structType;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_67b_badSink(CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_67b_goodG2BSink(CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_w32_execv_66b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#define EXECV _wexecv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_w32_execv_66b_badSink(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_file_w32_execv_66b_goodG2BSink(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif"
CWE78_OS_Command_Injection__char_file_popen_64b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#ifdef _WIN32
#define POPEN _popen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_popen_64b_badSink(void * dataVoidPtr)
{
    char * * dataPtr = (char * *)dataVoidPtr;
    char * data = (*dataPtr);
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_file_popen_64b_goodG2BSink(void * dataVoidPtr)
{
    char * * dataPtr = (char * *)dataVoidPtr;
    char * data = (*dataPtr);
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif"
CWE78_OS_Command_Injection__char_file_execlp_54a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_execlp_54b_badSink(char * data);
void CWE78_OS_Command_Injection__char_file_execlp_54_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        FILE * pFile;
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    CWE78_OS_Command_Injection__char_file_execlp_54b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_file_execlp_54b_goodG2BSink(char * data);
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_file_execlp_54b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__char_file_execlp_54_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_file_execlp_54_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_file_execlp_54_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_w32_spawnv_32.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_w32_spawnv_32_bad()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        wchar_t * data = *dataPtr1;
        {
            size_t dataLen = wcslen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgetws() failed"");
                        data[dataLen] = L'\0';
                    }
                    fclose(pFile);
                }
            }
        }
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
            _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        wchar_t * data = *dataPtr1;
        wcscat(data, L""*.*"");
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
            _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
        }
    }
}
void CWE78_OS_Command_Injection__wchar_t_file_w32_spawnv_32_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_spawnv_32_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_spawnv_32_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_w32_execv_06.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#define EXECV _wexecv
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_w32_execv_06_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        {
            size_t dataLen = wcslen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgetws() failed"");
                        data[dataLen] = L'\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_file_w32_execv_06_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_execv_06_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_execv_06_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_64b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_64b_badSink(void * dataVoidPtr)
{
    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;
    wchar_t * data = (*dataPtr);
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_64b_goodG2BSink(void * dataVoidPtr)
{
    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;
    wchar_t * data = (*dataPtr);
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__char_console_w32_spawnv_18.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_w32_spawnv_18_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goto source;
source:
    {
        size_t dataLen = strlen(data);
        if (100-dataLen > 1)
        {
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                data[dataLen] = '\0';
            }
        }
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goto source;
source:
    strcat(data, ""*.*"");
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__char_console_w32_spawnv_18_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_console_w32_spawnv_18_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_console_w32_spawnv_18_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_system_01.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#define SYSTEM _wsystem
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_system_01_bad()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        wchar_t *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = wcslen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
            replace = wcschr(data, L'\r');
            if (replace)
            {
                *replace = L'\0';
            }
            replace = wcschr(data, L'\n');
            if (replace)
            {
                *replace = L'\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    wcscat(data, L""*.*"");
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_system_01_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_system_01_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_system_01_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_w32_spawnvp_68a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
wchar_t * CWE78_OS_Command_Injection__wchar_t_console_w32_spawnvp_68_badData;
wchar_t * CWE78_OS_Command_Injection__wchar_t_console_w32_spawnvp_68_goodG2BData;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnvp_68b_badSink();
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnvp_68_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = wcslen(data);
        if (100-dataLen > 1)
        {
            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                dataLen = wcslen(data);
                if (dataLen > 0 && data[dataLen-1] == L'\n')
                {
                    data[dataLen-1] = L'\0';
                }
            }
            else
            {
                printLine(""fgetws() failed"");
                data[dataLen] = L'\0';
            }
        }
    }
    CWE78_OS_Command_Injection__wchar_t_console_w32_spawnvp_68_badData = data;
    CWE78_OS_Command_Injection__wchar_t_console_w32_spawnvp_68b_badSink();
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnvp_68b_goodG2BSink();
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_console_w32_spawnvp_68_goodG2BData = data;
    CWE78_OS_Command_Injection__wchar_t_console_w32_spawnvp_68b_goodG2BSink();
}
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnvp_68_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_console_w32_spawnvp_68_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_console_w32_spawnvp_68_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_68b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
extern wchar_t * CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_68_badData;
extern wchar_t * CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_68_goodG2BData;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_68b_badSink()
{
    wchar_t * data = CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_68_badData;
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_68b_goodG2BSink()
{
    wchar_t * data = CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_68_goodG2BData;
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__char_console_popen_12.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#define POPEN _popen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_popen_12_bad()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalReturnsTrueOrFalse())
    {
        {
            size_t dataLen = strlen(data);
            if (100-dataLen > 1)
            {
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    data[dataLen] = '\0';
                }
            }
        }
    }
    else
    {
        strcat(data, ""*.*"");
    }
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalReturnsTrueOrFalse())
    {
        strcat(data, ""*.*"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
void CWE78_OS_Command_Injection__char_console_popen_12_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_console_popen_12_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_console_popen_12_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_34.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
typedef union
{
    char * unionFirst;
    char * unionSecond;
} CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_34_unionType;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_34_bad()
{
    char * data;
    CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_34_unionType myUnion;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_34_unionType myUnion;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
    }
}
void CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_34_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_34_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_34_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_popen_44.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#define POPEN _wpopen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
static void badSink(wchar_t * data)
{
    {
        FILE *pipe;
        pipe = POPEN(data, L""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
void CWE78_OS_Command_Injection__wchar_t_console_popen_44_bad()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = badSink;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        size_t dataLen = wcslen(data);
        if (100-dataLen > 1)
        {
            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                dataLen = wcslen(data);
                if (dataLen > 0 && data[dataLen-1] == L'\n')
                {
                    data[dataLen-1] = L'\0';
                }
            }
            else
            {
                printLine(""fgetws() failed"");
                data[dataLen] = L'\0';
            }
        }
    }
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(wchar_t * data)
{
    {
        FILE *pipe;
        pipe = POPEN(data, L""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
static void goodG2B()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = goodG2BSink;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    wcscat(data, L""*.*"");
    funcPtr(data);
}
void CWE78_OS_Command_Injection__wchar_t_console_popen_44_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_console_popen_44_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_console_popen_44_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_44.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
static void badSink(char * data)
{
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_44_bad()
{
    char * data;
    void (*funcPtr) (char *) = badSink;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(char * data)
{
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B()
{
    char * data;
    void (*funcPtr) (char *) = goodG2BSink;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    funcPtr(data);
}
void CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_44_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_44_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_44_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_53c.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#define EXECVP _execvp
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_53d_badSink(char * data);
void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_53c_badSink(char * data)
{
    CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_53d_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_53d_goodG2BSink(char * data);
void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_53c_goodG2BSink(char * data)
{
    CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_53d_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__char_environment_w32_spawnv_45.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#include <process.h>
static char * CWE78_OS_Command_Injection__char_environment_w32_spawnv_45_badData;
static char * CWE78_OS_Command_Injection__char_environment_w32_spawnv_45_goodG2BData;
#ifndef OMITBAD
static void badSink()
{
    char * data = CWE78_OS_Command_Injection__char_environment_w32_spawnv_45_badData;
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__char_environment_w32_spawnv_45_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    CWE78_OS_Command_Injection__char_environment_w32_spawnv_45_badData = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    char * data = CWE78_OS_Command_Injection__char_environment_w32_spawnv_45_goodG2BData;
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_environment_w32_spawnv_45_goodG2BData = data;
    goodG2BSink();
}
void CWE78_OS_Command_Injection__char_environment_w32_spawnv_45_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_environment_w32_spawnv_45_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_environment_w32_spawnv_45_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_61a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#ifndef OMITBAD
wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_61b_badSource(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_61_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    data = CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_61b_badSource(data);
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_61b_goodG2BSource(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    data = CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_61b_goodG2BSource(data);
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_61_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_61_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_61_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_w32_execv_53a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#include <process.h>
#define EXECV _wexecv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_execv_53b_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_environment_w32_execv_53_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = wcslen(data);
        wchar_t * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            wcsncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    CWE78_OS_Command_Injection__wchar_t_environment_w32_execv_53b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_execv_53b_goodG2BSink(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_execv_53b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__wchar_t_environment_w32_execv_53_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_execv_53_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_execv_53_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_execlp_54c.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_execlp_54d_badSink(char * data);
void CWE78_OS_Command_Injection__char_console_execlp_54c_badSink(char * data)
{
    CWE78_OS_Command_Injection__char_console_execlp_54d_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_console_execlp_54d_goodG2BSink(char * data);
void CWE78_OS_Command_Injection__char_console_execlp_54c_goodG2BSink(char * data)
{
    CWE78_OS_Command_Injection__char_console_execlp_54d_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__char_file_execlp_03.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_execlp_03_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(5==5)
    {
        {
            size_t dataLen = strlen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(5==5)
    {
        strcat(data, ""*.*"");
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_file_execlp_03_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_file_execlp_03_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_file_execlp_03_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_52c.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#define EXECVP _wexecvp
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_52c_badSink(wchar_t * data)
{
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_52c_goodG2BSink(wchar_t * data)
{
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_64b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_64b_badSink(void * dataVoidPtr)
{
    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;
    wchar_t * data = (*dataPtr);
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_64b_goodG2BSink(void * dataVoidPtr)
{
    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;
    wchar_t * data = (*dataPtr);
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif"
CWE78_OS_Command_Injection__char_console_execlp_09.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_execlp_09_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        {
            size_t dataLen = strlen(data);
            if (100-dataLen > 1)
            {
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    data[dataLen] = '\0';
                }
            }
        }
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        strcat(data, ""*.*"");
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_console_execlp_09_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_console_execlp_09_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_console_execlp_09_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_03.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_03_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(5==5)
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_03_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_03_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_03_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_execl_16.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_execl_16_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    while(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(char)] = '\0';
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        break;
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    while(1)
    {
        strcat(data, ""*.*"");
        break;
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_connect_socket_execl_16_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_execl_16_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_execl_16_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_w32_execvp_54a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#define EXECVP _execvp
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_w32_execvp_54b_badSink(char * data);
void CWE78_OS_Command_Injection__char_console_w32_execvp_54_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        if (100-dataLen > 1)
        {
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                data[dataLen] = '\0';
            }
        }
    }
    CWE78_OS_Command_Injection__char_console_w32_execvp_54b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_console_w32_execvp_54b_goodG2BSink(char * data);
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_console_w32_execvp_54b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__char_console_w32_execvp_54_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_console_w32_execvp_54_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_console_w32_execvp_54_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_w32_spawnvp_64b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_w32_spawnvp_64b_badSink(void * dataVoidPtr)
{
    char * * dataPtr = (char * *)dataVoidPtr;
    char * data = (*dataPtr);
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_console_w32_spawnvp_64b_goodG2BSink(void * dataVoidPtr)
{
    char * * dataPtr = (char * *)dataVoidPtr;
    char * data = (*dataPtr);
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif"
CWE78_OS_Command_Injection__char_file_w32_spawnvp_18.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_w32_spawnvp_18_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goto source;
source:
    {
        size_t dataLen = strlen(data);
        FILE * pFile;
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goto source;
source:
    strcat(data, ""*.*"");
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
void CWE78_OS_Command_Injection__char_file_w32_spawnvp_18_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_file_w32_spawnvp_18_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_file_w32_spawnvp_18_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_file_w32_spawnv_04.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
static const int STATIC_CONST_TRUE = 1; 
static const int STATIC_CONST_FALSE = 0; 
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_w32_spawnv_04_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        {
            size_t dataLen = strlen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__char_file_w32_spawnv_04_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_file_w32_spawnv_04_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_file_w32_spawnv_04_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_54c.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#define EXECV _wexecv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_54d_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_54c_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_54d_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_54d_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_54c_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_54d_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_execlp_53b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#ifdef _WIN32
#include <process.h>
#define EXECLP _wexeclp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_execlp_53c_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_file_execlp_53b_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_file_execlp_53c_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_file_execlp_53c_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_file_execlp_53b_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_file_execlp_53c_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_54d.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_54e_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_54d_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_54e_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_54e_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_54d_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_54e_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_execlp_53a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#ifdef _WIN32
#include <process.h>
#define EXECLP _wexeclp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_execlp_53b_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_file_execlp_53_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = wcslen(data);
        FILE * pFile;
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgetws() failed"");
                    data[dataLen] = L'\0';
                }
                fclose(pFile);
            }
        }
    }
    CWE78_OS_Command_Injection__wchar_t_file_execlp_53b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_file_execlp_53b_goodG2BSink(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_file_execlp_53b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__wchar_t_file_execlp_53_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_file_execlp_53_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_file_execlp_53_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_system_52c.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#define SYSTEM _wsystem
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_system_52c_badSink(wchar_t * data)
{
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_system_52c_goodG2BSink(wchar_t * data)
{
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_63b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_63b_badSink(char * * dataPtr)
{
    char * data = *dataPtr;
    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_63b_goodG2BSink(char * * dataPtr)
{
    char * data = *dataPtr;
    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_66a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#define EXECVP _wexecvp
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_66b_badSink(wchar_t * dataArray[]);
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_66_bad()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        wchar_t *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = wcslen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
            replace = wcschr(data, L'\r');
            if (replace)
            {
                *replace = L'\0';
            }
            replace = wcschr(data, L'\n');
            if (replace)
            {
                *replace = L'\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    dataArray[2] = data;
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_66b_badSink(dataArray);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_66b_goodG2BSink(wchar_t * dataArray[]);
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    dataArray[2] = data;
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_66b_goodG2BSink(dataArray);
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_66_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_66_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_66_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_execlp_16.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_execlp_16_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    while(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(char)] = '\0';
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        break;
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    while(1)
    {
        strcat(data, ""*.*"");
        break;
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_listen_socket_execlp_16_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_listen_socket_execlp_16_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_listen_socket_execlp_16_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_01.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#define EXECV _wexecv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_01_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        wchar_t *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = wcslen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
            replace = wcschr(data, L'\r');
            if (replace)
            {
                *replace = L'\0';
            }
            replace = wcschr(data, L'\n');
            if (replace)
            {
                *replace = L'\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_01_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_01_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_01_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_popen_54c.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#define POPEN _popen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_popen_54d_badSink(char * data);
void CWE78_OS_Command_Injection__char_console_popen_54c_badSink(char * data)
{
    CWE78_OS_Command_Injection__char_console_popen_54d_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_console_popen_54d_goodG2BSink(char * data);
void CWE78_OS_Command_Injection__char_console_popen_54c_goodG2BSink(char * data)
{
    CWE78_OS_Command_Injection__char_console_popen_54d_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_execlp_51a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_execlp_51b_badSink(char * data);
void CWE78_OS_Command_Injection__char_connect_socket_execlp_51_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__char_connect_socket_execlp_51b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_connect_socket_execlp_51b_goodG2BSink(char * data);
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_connect_socket_execlp_51b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__char_connect_socket_execlp_51_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_execlp_51_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_execlp_51_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_system_10.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#define SYSTEM system
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_system_10_bad()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalTrue)
    {
        {
            size_t dataLen = strlen(data);
            if (100-dataLen > 1)
            {
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    data[dataLen] = '\0';
                }
            }
        }
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
static void goodG2B2()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalTrue)
    {
        strcat(data, ""*.*"");
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
void CWE78_OS_Command_Injection__char_console_system_10_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_console_system_10_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_console_system_10_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_w32spawnl_67b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
typedef struct _CWE78_OS_Command_Injection__char_console_w32spawnl_67_structType
{
    char * structFirst;
} CWE78_OS_Command_Injection__char_console_w32spawnl_67_structType;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_w32spawnl_67b_badSink(CWE78_OS_Command_Injection__char_console_w32spawnl_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_console_w32spawnl_67b_goodG2BSink(CWE78_OS_Command_Injection__char_console_w32spawnl_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_w32_execv_63b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#define EXECV _wexecv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_w32_execv_63b_badSink(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_console_w32_execv_63b_goodG2BSink(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_53d.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#define POPEN _wpopen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_53d_badSink(wchar_t * data)
{
    {
        FILE *pipe;
        pipe = POPEN(data, L""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_53d_goodG2BSink(wchar_t * data)
{
    {
        FILE *pipe;
        pipe = POPEN(data, L""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_54c.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#define POPEN _wpopen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_54d_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_54c_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_54d_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_54d_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_54c_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_54d_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_w32_execv_31.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#define EXECV _wexecv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_w32_execv_31_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = wcslen(data);
        FILE * pFile;
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgetws() failed"");
                    data[dataLen] = L'\0';
                }
                fclose(pFile);
            }
        }
    }
    {
        wchar_t * dataCopy = data;
        wchar_t * data = dataCopy;
        {
            wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
            EXECV(COMMAND_INT_PATH, args);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    {
        wchar_t * dataCopy = data;
        wchar_t * data = dataCopy;
        {
            wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
            EXECV(COMMAND_INT_PATH, args);
        }
    }
}
void CWE78_OS_Command_Injection__wchar_t_file_w32_execv_31_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_execv_31_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_execv_31_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_execl_32.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <process.h>
#define EXECL _wexecl
#else 
#define EXECL execl
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_execl_32_bad()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        wchar_t * data = *dataPtr1;
        {
            size_t dataLen = wcslen(data);
            if (100-dataLen > 1)
            {
                if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    dataLen = wcslen(data);
                    if (dataLen > 0 && data[dataLen-1] == L'\n')
                    {
                        data[dataLen-1] = L'\0';
                    }
                }
                else
                {
                    printLine(""fgetws() failed"");
                    data[dataLen] = L'\0';
                }
            }
        }
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        wchar_t * data = *dataPtr1;
        wcscat(data, L""*.*"");
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
    }
}
void CWE78_OS_Command_Injection__wchar_t_console_execl_32_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_console_execl_32_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_console_execl_32_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_52b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_52c_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_52b_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_52c_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_52c_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_52b_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_52c_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_w32_execv_63b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#include <process.h>
#define EXECV _wexecv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_execv_63b_badSink(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_execv_63b_goodG2BSink(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_system_01.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#define SYSTEM system
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_system_01_bad()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    strcat(data, ""*.*"");
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
void CWE78_OS_Command_Injection__char_connect_socket_system_01_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_system_01_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_system_01_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_w32spawnl_34.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
typedef union
{
    char * unionFirst;
    char * unionSecond;
} CWE78_OS_Command_Injection__char_console_w32spawnl_34_unionType;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_w32spawnl_34_bad()
{
    char * data;
    CWE78_OS_Command_Injection__char_console_w32spawnl_34_unionType myUnion;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        if (100-dataLen > 1)
        {
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                data[dataLen] = '\0';
            }
        }
    }
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    CWE78_OS_Command_Injection__char_console_w32spawnl_34_unionType myUnion;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
    }
}
void CWE78_OS_Command_Injection__char_console_w32spawnl_34_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_console_w32spawnl_34_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_console_w32spawnl_34_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_w32_execv_53b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#define EXECV _wexecv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_w32_execv_53c_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_console_w32_execv_53b_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_console_w32_execv_53c_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_console_w32_execv_53c_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_console_w32_execv_53b_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_console_w32_execv_53c_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_61a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#include <process.h>
#define EXECLP _wexeclp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_61b_badSource(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_61_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    data = CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_61b_badSource(data);
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_61b_goodG2BSource(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    data = CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_61b_goodG2BSource(data);
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_61_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_61_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_61_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_file_w32_spawnv_44.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#ifndef OMITBAD
static void badSink(char * data)
{
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__char_file_w32_spawnv_44_bad()
{
    char * data;
    void (*funcPtr) (char *) = badSink;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        FILE * pFile;
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(char * data)
{
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
static void goodG2B()
{
    char * data;
    void (*funcPtr) (char *) = goodG2BSink;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    funcPtr(data);
}
void CWE78_OS_Command_Injection__char_file_w32_spawnv_44_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_file_w32_spawnv_44_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_file_w32_spawnv_44_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_popen_17.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#define POPEN _wpopen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_popen_17_bad()
{
    int i;
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    for(i = 0; i < 1; i++)
    {
        {
            size_t dataLen = wcslen(data);
            wchar_t * environment = GETENV(ENV_VARIABLE);
            if (environment != NULL)
            {
                wcsncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    {
        FILE *pipe;
        pipe = POPEN(data, L""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int h;
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    for(h = 0; h < 1; h++)
    {
        wcscat(data, L""*.*"");
    }
    {
        FILE *pipe;
        pipe = POPEN(data, L""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
void CWE78_OS_Command_Injection__wchar_t_environment_popen_17_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_popen_17_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_popen_17_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_system_31.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#define SYSTEM _wsystem
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_system_31_bad()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        wchar_t *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = wcslen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
            replace = wcschr(data, L'\r');
            if (replace)
            {
                *replace = L'\0';
            }
            replace = wcschr(data, L'\n');
            if (replace)
            {
                *replace = L'\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        wchar_t * dataCopy = data;
        wchar_t * data = dataCopy;
        if (SYSTEM(data) != 0)
        {
            printLine(""command execution failed!"");
            exit(1);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    wcscat(data, L""*.*"");
    {
        wchar_t * dataCopy = data;
        wchar_t * data = dataCopy;
        if (SYSTEM(data) != 0)
        {
            printLine(""command execution failed!"");
            exit(1);
        }
    }
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_system_31_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_system_31_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_system_31_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_16.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#define EXECV _wexecv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_16_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    while(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        break;
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    while(1)
    {
        wcscat(data, L""*.*"");
        break;
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_16_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_16_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_16_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_environment_execlp_65a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_execlp_65b_badSink(char * data);
void CWE78_OS_Command_Injection__char_environment_execlp_65_bad()
{
    char * data;
    void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_environment_execlp_65b_badSink;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_environment_execlp_65b_goodG2BSink(char * data);
static void goodG2B()
{
    char * data;
    void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_environment_execlp_65b_goodG2BSink;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    funcPtr(data);
}
void CWE78_OS_Command_Injection__char_environment_execlp_65_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_environment_execlp_65_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_environment_execlp_65_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_file_w32_spawnlp_22a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
int CWE78_OS_Command_Injection__char_file_w32_spawnlp_22_badGlobal = 0;
char * CWE78_OS_Command_Injection__char_file_w32_spawnlp_22_badSource(char * data);
void CWE78_OS_Command_Injection__char_file_w32_spawnlp_22_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    CWE78_OS_Command_Injection__char_file_w32_spawnlp_22_badGlobal = 1; 
    data = CWE78_OS_Command_Injection__char_file_w32_spawnlp_22_badSource(data);
    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
int CWE78_OS_Command_Injection__char_file_w32_spawnlp_22_goodG2B1Global = 0;
int CWE78_OS_Command_Injection__char_file_w32_spawnlp_22_goodG2B2Global = 0;
char * CWE78_OS_Command_Injection__char_file_w32_spawnlp_22_goodG2B1Source(char * data);
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    CWE78_OS_Command_Injection__char_file_w32_spawnlp_22_goodG2B1Global = 0; 
    data = CWE78_OS_Command_Injection__char_file_w32_spawnlp_22_goodG2B1Source(data);
    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
char * CWE78_OS_Command_Injection__char_file_w32_spawnlp_22_goodG2B2Source(char * data);
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    CWE78_OS_Command_Injection__char_file_w32_spawnlp_22_goodG2B2Global = 1; 
    data = CWE78_OS_Command_Injection__char_file_w32_spawnlp_22_goodG2B2Source(data);
    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_file_w32_spawnlp_22_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_file_w32_spawnlp_22_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_file_w32_spawnlp_22_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_file_w32spawnl_14.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_w32spawnl_14_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalFive==5)
    {
        {
            size_t dataLen = strlen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalFive==5)
    {
        strcat(data, ""*.*"");
    }
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_file_w32spawnl_14_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_file_w32spawnl_14_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_file_w32spawnl_14_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_environment_popen_13.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#define POPEN _popen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_popen_13_bad()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            if (environment != NULL)
            {
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
static void goodG2B2()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(GLOBAL_CONST_FIVE==5)
    {
        strcat(data, ""*.*"");
    }
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
void CWE78_OS_Command_Injection__char_environment_popen_13_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_environment_popen_13_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_environment_popen_13_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_08.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#include <process.h>
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_08_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        {
            size_t dataLen = wcslen(data);
            wchar_t * environment = GETENV(ENV_VARIABLE);
            if (environment != NULL)
            {
                wcsncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    _wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    _wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        wcscat(data, L""*.*"");
    }
    _wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_08_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_08_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnlp_08_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_34.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#define EXECVP _execvp
typedef union
{
    char * unionFirst;
    char * unionSecond;
} CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_34_unionType;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_34_bad()
{
    char * data;
    CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_34_unionType myUnion;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
            EXECVP(COMMAND_INT, args);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_34_unionType myUnion;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
            EXECVP(COMMAND_INT, args);
        }
    }
}
void CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_34_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_34_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_34_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_environment_execl_02.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_execl_02_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(1)
    {
        {
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            if (environment != NULL)
            {
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(1)
    {
        strcat(data, ""*.*"");
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_environment_execl_02_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_environment_execl_02_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_environment_execl_02_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_environment_w32_spawnvp_13.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_13_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            if (environment != NULL)
            {
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_FIVE==5)
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_13_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_environment_w32_spawnvp_13_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_environment_w32_spawnvp_13_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_execlp_53b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#include <process.h>
#define EXECLP _wexeclp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_execlp_53c_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_environment_execlp_53b_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_environment_execlp_53c_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_environment_execlp_53c_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_environment_execlp_53b_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_environment_execlp_53c_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__char_environment_w32_spawnvp_45.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#include <process.h>
static char * CWE78_OS_Command_Injection__char_environment_w32_spawnvp_45_badData;
static char * CWE78_OS_Command_Injection__char_environment_w32_spawnvp_45_goodG2BData;
#ifndef OMITBAD
static void badSink()
{
    char * data = CWE78_OS_Command_Injection__char_environment_w32_spawnvp_45_badData;
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_45_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    CWE78_OS_Command_Injection__char_environment_w32_spawnvp_45_badData = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    char * data = CWE78_OS_Command_Injection__char_environment_w32_spawnvp_45_goodG2BData;
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_environment_w32_spawnvp_45_goodG2BData = data;
    goodG2BSink();
}
void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_45_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_environment_w32_spawnvp_45_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_environment_w32_spawnvp_45_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_03.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_03_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(5==5)
    {
        {
            size_t dataLen = wcslen(data);
            wchar_t * environment = GETENV(ENV_VARIABLE);
            if (environment != NULL)
            {
                wcsncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(5==5)
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_03_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_03_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_03_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_53b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_53c_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_53b_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_53c_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_53c_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_53b_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_53c_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_system_61a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#define SYSTEM _wsystem
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
wchar_t * CWE78_OS_Command_Injection__wchar_t_console_system_61b_badSource(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_console_system_61_bad()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    data = CWE78_OS_Command_Injection__wchar_t_console_system_61b_badSource(data);
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif 
#ifndef OMITGOOD
wchar_t * CWE78_OS_Command_Injection__wchar_t_console_system_61b_goodG2BSource(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    data = CWE78_OS_Command_Injection__wchar_t_console_system_61b_goodG2BSource(data);
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
void CWE78_OS_Command_Injection__wchar_t_console_system_61_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_console_system_61_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_console_system_61_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_17.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#define EXECVP _execvp
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_17_bad()
{
    int i;
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(char)] = '\0';
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int h;
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    for(h = 0; h < 1; h++)
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_17_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_17_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_17_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_52a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_52b_badSink(char * data);
void CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_52_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_52b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_52b_goodG2BSink(char * data);
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_52b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_52_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_52_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_52_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_environment_w32_spawnv_03.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_w32_spawnv_03_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(5==5)
    {
        {
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            if (environment != NULL)
            {
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(5==5)
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__char_environment_w32_spawnv_03_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_environment_w32_spawnv_03_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_environment_w32_spawnv_03_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_file_w32_spawnlp_52c.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_w32_spawnlp_52c_badSink(char * data)
{
    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_file_w32_spawnlp_52c_goodG2BSink(char * data)
{
    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__char_environment_w32spawnl_65a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_w32spawnl_65b_badSink(char * data);
void CWE78_OS_Command_Injection__char_environment_w32spawnl_65_bad()
{
    char * data;
    void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_environment_w32spawnl_65b_badSink;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_environment_w32spawnl_65b_goodG2BSink(char * data);
static void goodG2B()
{
    char * data;
    void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_environment_w32spawnl_65b_goodG2BSink;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    funcPtr(data);
}
void CWE78_OS_Command_Injection__char_environment_w32spawnl_65_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_environment_w32spawnl_65_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_environment_w32spawnl_65_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_01.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_01_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = wcslen(data);
        wchar_t * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            wcsncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_01_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_01_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_01_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_w32_spawnvp_54c.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_w32_spawnvp_54d_badSink(char * data);
void CWE78_OS_Command_Injection__char_console_w32_spawnvp_54c_badSink(char * data)
{
    CWE78_OS_Command_Injection__char_console_w32_spawnvp_54d_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_console_w32_spawnvp_54d_goodG2BSink(char * data);
void CWE78_OS_Command_Injection__char_console_w32_spawnvp_54c_goodG2BSink(char * data)
{
    CWE78_OS_Command_Injection__char_console_w32_spawnvp_54d_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_06.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_06_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(char)] = '\0';
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_06_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_06_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_06_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_68b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
extern char * CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_68_badData;
extern char * CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_68_goodG2BData;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_68b_badSink()
{
    char * data = CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_68_badData;
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_68b_goodG2BSink()
{
    char * data = CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_68_goodG2BData;
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_system_02.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#ifdef _WIN32
#define SYSTEM _wsystem
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_system_02_bad()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(1)
    {
        {
            size_t dataLen = wcslen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgetws() failed"");
                        data[dataLen] = L'\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(1)
    {
        wcscat(data, L""*.*"");
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
void CWE78_OS_Command_Injection__wchar_t_file_system_02_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_file_system_02_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_file_system_02_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_51b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#include <process.h>
#define EXECLP _wexeclp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_51b_badSink(wchar_t * data)
{
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_51b_goodG2BSink(wchar_t * data)
{
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_02.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_02_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(char)] = '\0';
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(1)
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_02_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_02_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_02_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_65b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_65b_badSink(wchar_t * data)
{
    _wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_65b_goodG2BSink(wchar_t * data)
{
    _wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_17.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_17_bad()
{
    int i;
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int h;
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    for(h = 0; h < 1; h++)
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_17_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_17_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_17_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_system_10.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#ifdef _WIN32
#define SYSTEM _wsystem
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_system_10_bad()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalTrue)
    {
        {
            size_t dataLen = wcslen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgetws() failed"");
                        data[dataLen] = L'\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalTrue)
    {
        wcscat(data, L""*.*"");
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
void CWE78_OS_Command_Injection__wchar_t_file_system_10_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_file_system_10_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_file_system_10_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_w32_execv_67b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#define EXECV _wexecv
typedef struct _CWE78_OS_Command_Injection__wchar_t_file_w32_execv_67_structType
{
    wchar_t * structFirst;
} CWE78_OS_Command_Injection__wchar_t_file_w32_execv_67_structType;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_w32_execv_67b_badSink(CWE78_OS_Command_Injection__wchar_t_file_w32_execv_67_structType myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_file_w32_execv_67b_goodG2BSink(CWE78_OS_Command_Injection__wchar_t_file_w32_execv_67_structType myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_execl_52c.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <process.h>
#define EXECL _wexecl
#else 
#define EXECL execl
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_execl_52c_badSink(wchar_t * data)
{
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_console_execl_52c_goodG2BSink(wchar_t * data)
{
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_09.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_09_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_09_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_09_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_09_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_environment_system_05.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#define SYSTEM system
#else 
#define SYSTEM system
#endif
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_system_05_bad()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(staticTrue)
    {
        {
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            if (environment != NULL)
            {
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
static void goodG2B2()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(staticTrue)
    {
        strcat(data, ""*.*"");
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
void CWE78_OS_Command_Injection__char_environment_system_05_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_environment_system_05_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_environment_system_05_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_68b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
extern wchar_t * CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_68_badData;
extern wchar_t * CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_68_goodG2BData;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_68b_badSink()
{
    wchar_t * data = CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_68_badData;
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_68b_goodG2BSink()
{
    wchar_t * data = CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_68_goodG2BData;
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_31.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#define POPEN _wpopen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_31_bad()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        wchar_t *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = wcslen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
            replace = wcschr(data, L'\r');
            if (replace)
            {
                *replace = L'\0';
            }
            replace = wcschr(data, L'\n');
            if (replace)
            {
                *replace = L'\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        wchar_t * dataCopy = data;
        wchar_t * data = dataCopy;
        {
            FILE *pipe;
            pipe = POPEN(data, L""w"");
            if (pipe != NULL)
            {
                PCLOSE(pipe);
            }
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    wcscat(data, L""*.*"");
    {
        wchar_t * dataCopy = data;
        wchar_t * data = dataCopy;
        {
            FILE *pipe;
            pipe = POPEN(data, L""w"");
            if (pipe != NULL)
            {
                PCLOSE(pipe);
            }
        }
    }
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_31_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_31_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_31_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_68a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#include <process.h>
wchar_t * CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_68_badData;
wchar_t * CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_68_goodG2BData;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_68b_badSink();
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_68_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = wcslen(data);
        wchar_t * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            wcsncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_68_badData = data;
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_68b_badSink();
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_68b_goodG2BSink();
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_68_goodG2BData = data;
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_68b_goodG2BSink();
}
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_68_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_68_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_68_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_18.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_18_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goto source;
source:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        wchar_t *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = wcslen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
            replace = wcschr(data, L'\r');
            if (replace)
            {
                *replace = L'\0';
            }
            replace = wcschr(data, L'\n');
            if (replace)
            {
                *replace = L'\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goto source;
source:
    wcscat(data, L""*.*"");
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_18_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_18_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_18_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_65b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_65b_badSink(wchar_t * data)
{
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_65b_goodG2BSink(wchar_t * data)
{
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_system_14.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#define SYSTEM _wsystem
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_system_14_bad()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalFive==5)
    {
        wcscat(data, L""*.*"");
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
void CWE78_OS_Command_Injection__wchar_t_connect_socket_system_14_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_system_14_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_system_14_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_environment_w32_spawnv_66a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_w32_spawnv_66b_badSink(char * dataArray[]);
void CWE78_OS_Command_Injection__char_environment_w32_spawnv_66_bad()
{
    char * data;
    char * dataArray[5];
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    dataArray[2] = data;
    CWE78_OS_Command_Injection__char_environment_w32_spawnv_66b_badSink(dataArray);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_environment_w32_spawnv_66b_goodG2BSink(char * dataArray[]);
static void goodG2B()
{
    char * data;
    char * dataArray[5];
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    dataArray[2] = data;
    CWE78_OS_Command_Injection__char_environment_w32_spawnv_66b_goodG2BSink(dataArray);
}
void CWE78_OS_Command_Injection__char_environment_w32_spawnv_66_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_environment_w32_spawnv_66_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_environment_w32_spawnv_66_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_environment_popen_31.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#define POPEN _popen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_popen_31_bad()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            FILE *pipe;
            pipe = POPEN(data, ""w"");
            if (pipe != NULL)
            {
                PCLOSE(pipe);
            }
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    strcat(data, ""*.*"");
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            FILE *pipe;
            pipe = POPEN(data, ""w"");
            if (pipe != NULL)
            {
                PCLOSE(pipe);
            }
        }
    }
}
void CWE78_OS_Command_Injection__char_environment_popen_31_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_environment_popen_31_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_environment_popen_31_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_w32_spawnvp_52a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_w32_spawnvp_52b_badSink(char * data);
void CWE78_OS_Command_Injection__char_console_w32_spawnvp_52_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        if (100-dataLen > 1)
        {
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                data[dataLen] = '\0';
            }
        }
    }
    CWE78_OS_Command_Injection__char_console_w32_spawnvp_52b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_console_w32_spawnvp_52b_goodG2BSink(char * data);
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_console_w32_spawnvp_52b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__char_console_w32_spawnvp_52_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_console_w32_spawnvp_52_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_console_w32_spawnvp_52_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_execlp_66b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_execlp_66b_badSink(char * dataArray[])
{
    char * data = dataArray[2];
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_listen_socket_execlp_66b_goodG2BSink(char * dataArray[])
{
    char * data = dataArray[2];
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__char_file_w32_spawnvp_65a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_w32_spawnvp_65b_badSink(char * data);
void CWE78_OS_Command_Injection__char_file_w32_spawnvp_65_bad()
{
    char * data;
    void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_file_w32_spawnvp_65b_badSink;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        FILE * pFile;
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_file_w32_spawnvp_65b_goodG2BSink(char * data);
static void goodG2B()
{
    char * data;
    void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_file_w32_spawnvp_65b_goodG2BSink;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    funcPtr(data);
}
void CWE78_OS_Command_Injection__char_file_w32_spawnvp_65_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_file_w32_spawnvp_65_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_file_w32_spawnvp_65_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_environment_execlp_64b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_execlp_64b_badSink(void * dataVoidPtr)
{
    char * * dataPtr = (char * *)dataVoidPtr;
    char * data = (*dataPtr);
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_environment_execlp_64b_goodG2BSink(void * dataVoidPtr)
{
    char * * dataPtr = (char * *)dataVoidPtr;
    char * data = (*dataPtr);
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_01.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_01_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = wcslen(data);
        wchar_t * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            wcsncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_01_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_01_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_01_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_54d.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_54e_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_54d_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_54e_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_54e_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_54d_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_54e_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_w32_execv_63b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#define EXECV _wexecv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_w32_execv_63b_badSink(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_file_w32_execv_63b_goodG2BSink(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_65a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#define POPEN _wpopen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_65b_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_65_bad()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_65b_badSink;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        wchar_t *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = wcslen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
            replace = wcschr(data, L'\r');
            if (replace)
            {
                *replace = L'\0';
            }
            replace = wcschr(data, L'\n');
            if (replace)
            {
                *replace = L'\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_65b_goodG2BSink(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_65b_goodG2BSink;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    wcscat(data, L""*.*"");
    funcPtr(data);
}
void CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_65_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_65_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_65_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_61b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#define POPEN _wpopen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_61b_badSource(wchar_t * data)
{
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        wchar_t *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = wcslen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
            replace = wcschr(data, L'\r');
            if (replace)
            {
                *replace = L'\0';
            }
            replace = wcschr(data, L'\n');
            if (replace)
            {
                *replace = L'\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    return data;
}
#endif 
#ifndef OMITGOOD
wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_61b_goodG2BSource(wchar_t * data)
{
    wcscat(data, L""*.*"");
    return data;
}
#endif"
CWE78_OS_Command_Injection__char_environment_w32_spawnvp_52b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_52c_badSink(char * data);
void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_52b_badSink(char * data)
{
    CWE78_OS_Command_Injection__char_environment_w32_spawnvp_52c_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_52c_goodG2BSink(char * data);
void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_52b_goodG2BSink(char * data)
{
    CWE78_OS_Command_Injection__char_environment_w32_spawnvp_52c_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_68b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
extern wchar_t * CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_68_badData;
extern wchar_t * CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_68_goodG2BData;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_68b_badSink()
{
    wchar_t * data = CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_68_badData;
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_68b_goodG2BSink()
{
    wchar_t * data = CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_68_goodG2BData;
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__char_file_w32_spawnvp_53b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_w32_spawnvp_53c_badSink(char * data);
void CWE78_OS_Command_Injection__char_file_w32_spawnvp_53b_badSink(char * data)
{
    CWE78_OS_Command_Injection__char_file_w32_spawnvp_53c_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_file_w32_spawnvp_53c_goodG2BSink(char * data);
void CWE78_OS_Command_Injection__char_file_w32_spawnvp_53b_goodG2BSink(char * data)
{
    CWE78_OS_Command_Injection__char_file_w32_spawnvp_53c_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__char_console_execl_51b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_execl_51b_badSink(char * data)
{
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_console_execl_51b_goodG2BSink(char * data)
{
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__char_file_execl_54a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_execl_54b_badSink(char * data);
void CWE78_OS_Command_Injection__char_file_execl_54_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        FILE * pFile;
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    CWE78_OS_Command_Injection__char_file_execl_54b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_file_execl_54b_goodG2BSink(char * data);
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_file_execl_54b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__char_file_execl_54_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_file_execl_54_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_file_execl_54_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_67a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#define EXECVP _wexecvp
typedef struct _CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_67_structType
{
    wchar_t * structFirst;
} CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_67_structType;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_67b_badSink(CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_67_structType myStruct);
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_67_bad()
{
    wchar_t * data;
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_67_structType myStruct;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        wchar_t *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = wcslen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
            replace = wcschr(data, L'\r');
            if (replace)
            {
                *replace = L'\0';
            }
            replace = wcschr(data, L'\n');
            if (replace)
            {
                *replace = L'\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myStruct.structFirst = data;
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_67b_badSink(myStruct);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_67b_goodG2BSink(CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_67_structType myStruct);
static void goodG2B()
{
    wchar_t * data;
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_67_structType myStruct;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    myStruct.structFirst = data;
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_67b_goodG2BSink(myStruct);
}
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_67_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_67_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_67_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_16.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_16_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    while(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(char)] = '\0';
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        break;
    }
    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    while(1)
    {
        strcat(data, ""*.*"");
        break;
    }
    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_16_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_16_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_16_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_execl_52a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#include <process.h>
#define EXECL _wexecl
#else 
#define EXECL execl
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_execl_52b_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_environment_execl_52_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = wcslen(data);
        wchar_t * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            wcsncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    CWE78_OS_Command_Injection__wchar_t_environment_execl_52b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_environment_execl_52b_goodG2BSink(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_environment_execl_52b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__wchar_t_environment_execl_52_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_execl_52_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_execl_52_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_54b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_54c_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_54b_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_54c_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_54c_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_54b_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_54c_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__char_file_w32_execv_14.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#define EXECV _execv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_w32_execv_14_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalFive==5)
    {
        {
            size_t dataLen = strlen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalFive==5)
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__char_file_w32_execv_14_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_file_w32_execv_14_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_file_w32_execv_14_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_07.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
static int staticFive = 5;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_07_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    _wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    _wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFive==5)
    {
        wcscat(data, L""*.*"");
    }
    _wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_07_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_07_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_07_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_environment_w32_execvp_12.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#include <process.h>
#define EXECVP _execvp
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_w32_execvp_12_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        {
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            if (environment != NULL)
            {
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    else
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        strcat(data, ""*.*"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
void CWE78_OS_Command_Injection__char_environment_w32_execvp_12_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_environment_w32_execvp_12_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_environment_w32_execvp_12_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_w32_execvp_32.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#include <process.h>
#define EXECVP _wexecvp
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_execvp_32_bad()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        wchar_t * data = *dataPtr1;
        {
            size_t dataLen = wcslen(data);
            wchar_t * environment = GETENV(ENV_VARIABLE);
            if (environment != NULL)
            {
                wcsncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
            EXECVP(COMMAND_INT, args);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        wchar_t * data = *dataPtr1;
        wcscat(data, L""*.*"");
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
            EXECVP(COMMAND_INT, args);
        }
    }
}
void CWE78_OS_Command_Injection__wchar_t_environment_w32_execvp_32_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_execvp_32_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_execvp_32_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_file_popen_42.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#ifdef _WIN32
#define POPEN _popen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
static char * badSource(char * data)
{
    {
        size_t dataLen = strlen(data);
        FILE * pFile;
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    return data;
}
void CWE78_OS_Command_Injection__char_file_popen_42_bad()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    data = badSource(data);
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif 
#ifndef OMITGOOD
static char * goodG2BSource(char * data)
{
    strcat(data, ""*.*"");
    return data;
}
static void goodG2B()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    data = goodG2BSource(data);
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
void CWE78_OS_Command_Injection__char_file_popen_42_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_file_popen_42_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_file_popen_42_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_w32_execv_51a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#define EXECV _execv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_w32_execv_51b_badSink(char * data);
void CWE78_OS_Command_Injection__char_console_w32_execv_51_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        if (100-dataLen > 1)
        {
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                data[dataLen] = '\0';
            }
        }
    }
    CWE78_OS_Command_Injection__char_console_w32_execv_51b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_console_w32_execv_51b_goodG2BSink(char * data);
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_console_w32_execv_51b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__char_console_w32_execv_51_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_console_w32_execv_51_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_console_w32_execv_51_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_system_66b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#define SYSTEM system
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_system_66b_badSink(char * dataArray[])
{
    char * data = dataArray[2];
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_listen_socket_system_66b_goodG2BSink(char * dataArray[])
{
    char * data = dataArray[2];
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_17.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_17_bad()
{
    int i;
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int h;
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    for(h = 0; h < 1; h++)
    {
        wcscat(data, L""*.*"");
    }
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_17_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_17_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_17_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_05.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_05_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticTrue)
    {
        {
            size_t dataLen = wcslen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgetws() failed"");
                        data[dataLen] = L'\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticTrue)
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_05_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_05_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_05_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_w32_execv_52b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#define EXECV _wexecv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_w32_execv_52c_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_console_w32_execv_52b_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_console_w32_execv_52c_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_console_w32_execv_52c_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_console_w32_execv_52b_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_console_w32_execv_52c_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_execv_68b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#define EXECV _execv
extern char * CWE78_OS_Command_Injection__char_connect_socket_w32_execv_68_badData;
extern char * CWE78_OS_Command_Injection__char_connect_socket_w32_execv_68_goodG2BData;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32_execv_68b_badSink()
{
    char * data = CWE78_OS_Command_Injection__char_connect_socket_w32_execv_68_badData;
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_connect_socket_w32_execv_68b_goodG2BSink()
{
    char * data = CWE78_OS_Command_Injection__char_connect_socket_w32_execv_68_goodG2BData;
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_popen_34.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#define POPEN _popen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
typedef union
{
    char * unionFirst;
    char * unionSecond;
} CWE78_OS_Command_Injection__char_connect_socket_popen_34_unionType;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_popen_34_bad()
{
    char * data;
    CWE78_OS_Command_Injection__char_connect_socket_popen_34_unionType myUnion;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            FILE *pipe;
            pipe = POPEN(data, ""w"");
            if (pipe != NULL)
            {
                PCLOSE(pipe);
            }
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    CWE78_OS_Command_Injection__char_connect_socket_popen_34_unionType myUnion;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    strcat(data, ""*.*"");
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            FILE *pipe;
            pipe = POPEN(data, ""w"");
            if (pipe != NULL)
            {
                PCLOSE(pipe);
            }
        }
    }
}
void CWE78_OS_Command_Injection__char_connect_socket_popen_34_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_popen_34_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_popen_34_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_04.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#define EXECVP _execvp
static const int STATIC_CONST_TRUE = 1; 
static const int STATIC_CONST_FALSE = 0; 
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_04_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(char)] = '\0';
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
void CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_04_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_04_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_04_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_53a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_53b_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_53_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = wcslen(data);
        FILE * pFile;
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgetws() failed"");
                    data[dataLen] = L'\0';
                }
                fclose(pFile);
            }
        }
    }
    CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_53b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_53b_goodG2BSink(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_53b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_53_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_53_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_53_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_54e.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_54e_badSink(wchar_t * data)
{
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_54e_goodG2BSink(wchar_t * data)
{
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_54c.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_54d_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_54c_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_54d_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_54d_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_54c_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_54d_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__char_file_popen_67a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#ifdef _WIN32
#define POPEN _popen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
typedef struct _CWE78_OS_Command_Injection__char_file_popen_67_structType
{
    char * structFirst;
} CWE78_OS_Command_Injection__char_file_popen_67_structType;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_popen_67b_badSink(CWE78_OS_Command_Injection__char_file_popen_67_structType myStruct);
void CWE78_OS_Command_Injection__char_file_popen_67_bad()
{
    char * data;
    CWE78_OS_Command_Injection__char_file_popen_67_structType myStruct;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
        size_t dataLen = strlen(data);
        FILE * pFile;
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    myStruct.structFirst = data;
    CWE78_OS_Command_Injection__char_file_popen_67b_badSink(myStruct);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_file_popen_67b_goodG2BSink(CWE78_OS_Command_Injection__char_file_popen_67_structType myStruct);
static void goodG2B()
{
    char * data;
    CWE78_OS_Command_Injection__char_file_popen_67_structType myStruct;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    strcat(data, ""*.*"");
    myStruct.structFirst = data;
    CWE78_OS_Command_Injection__char_file_popen_67b_goodG2BSink(myStruct);
}
void CWE78_OS_Command_Injection__char_file_popen_67_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_file_popen_67_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_file_popen_67_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_environment_w32_spawnv_68a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#include <process.h>
char * CWE78_OS_Command_Injection__char_environment_w32_spawnv_68_badData;
char * CWE78_OS_Command_Injection__char_environment_w32_spawnv_68_goodG2BData;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_w32_spawnv_68b_badSink();
void CWE78_OS_Command_Injection__char_environment_w32_spawnv_68_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    CWE78_OS_Command_Injection__char_environment_w32_spawnv_68_badData = data;
    CWE78_OS_Command_Injection__char_environment_w32_spawnv_68b_badSink();
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_environment_w32_spawnv_68b_goodG2BSink();
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_environment_w32_spawnv_68_goodG2BData = data;
    CWE78_OS_Command_Injection__char_environment_w32_spawnv_68b_goodG2BSink();
}
void CWE78_OS_Command_Injection__char_environment_w32_spawnv_68_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_environment_w32_spawnv_68_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_environment_w32_spawnv_68_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_file_execlp_53b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_execlp_53c_badSink(char * data);
void CWE78_OS_Command_Injection__char_file_execlp_53b_badSink(char * data)
{
    CWE78_OS_Command_Injection__char_file_execlp_53c_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_file_execlp_53c_goodG2BSink(char * data);
void CWE78_OS_Command_Injection__char_file_execlp_53b_goodG2BSink(char * data)
{
    CWE78_OS_Command_Injection__char_file_execlp_53c_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__char_environment_system_52b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#define SYSTEM system
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_system_52c_badSink(char * data);
void CWE78_OS_Command_Injection__char_environment_system_52b_badSink(char * data)
{
    CWE78_OS_Command_Injection__char_environment_system_52c_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_environment_system_52c_goodG2BSink(char * data);
void CWE78_OS_Command_Injection__char_environment_system_52b_goodG2BSink(char * data)
{
    CWE78_OS_Command_Injection__char_environment_system_52c_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_52c.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#define POPEN _wpopen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_52c_badSink(wchar_t * data)
{
    {
        FILE *pipe;
        pipe = POPEN(data, L""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_52c_goodG2BSink(wchar_t * data)
{
    {
        FILE *pipe;
        pipe = POPEN(data, L""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_system_10.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#define SYSTEM _wsystem
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_system_10_bad()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalTrue)
    {
        {
            size_t dataLen = wcslen(data);
            if (100-dataLen > 1)
            {
                if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    dataLen = wcslen(data);
                    if (dataLen > 0 && data[dataLen-1] == L'\n')
                    {
                        data[dataLen-1] = L'\0';
                    }
                }
                else
                {
                    printLine(""fgetws() failed"");
                    data[dataLen] = L'\0';
                }
            }
        }
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalTrue)
    {
        wcscat(data, L""*.*"");
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
void CWE78_OS_Command_Injection__wchar_t_console_system_10_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_console_system_10_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_console_system_10_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_21.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#include <process.h>
#define EXECLP _wexeclp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
static int badStatic = 0;
static wchar_t * badSource(wchar_t * data)
{
    if(badStatic)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    return data;
}
void CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_21_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    badStatic = 1; 
    data = badSource(data);
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static int goodG2B1Static = 0;
static int goodG2B2Static = 0;
static wchar_t * goodG2B1Source(wchar_t * data)
{
    if(goodG2B1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    return data;
}
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goodG2B1Static = 0; 
    data = goodG2B1Source(data);
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static wchar_t * goodG2B2Source(wchar_t * data)
{
    if(goodG2B2Static)
    {
        wcscat(data, L""*.*"");
    }
    return data;
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goodG2B2Static = 1; 
    data = goodG2B2Source(data);
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_21_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_21_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_21_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_popen_66b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#define POPEN _wpopen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_popen_66b_badSink(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    {
        FILE *pipe;
        pipe = POPEN(data, L""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_console_popen_66b_goodG2BSink(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    {
        FILE *pipe;
        pipe = POPEN(data, L""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif"
CWE78_OS_Command_Injection__char_file_w32spawnl_06.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_w32spawnl_06_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        {
            size_t dataLen = strlen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        strcat(data, ""*.*"");
    }
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_file_w32spawnl_06_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_file_w32spawnl_06_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_file_w32spawnl_06_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_w32spawnl_11.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_w32spawnl_11_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        {
            size_t dataLen = strlen(data);
            if (100-dataLen > 1)
            {
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    data[dataLen] = '\0';
                }
            }
        }
    }
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrue())
    {
        strcat(data, ""*.*"");
    }
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_console_w32spawnl_11_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_console_w32spawnl_11_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_console_w32spawnl_11_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_18.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#include <process.h>
#define EXECLP _wexeclp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_18_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goto source;
source:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        wchar_t *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = wcslen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
            replace = wcschr(data, L'\r');
            if (replace)
            {
                *replace = L'\0';
            }
            replace = wcschr(data, L'\n');
            if (replace)
            {
                *replace = L'\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goto source;
source:
    wcscat(data, L""*.*"");
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_18_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_18_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_18_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_w32spawnl_16.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_w32spawnl_16_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    while(1)
    {
        {
            size_t dataLen = wcslen(data);
            if (100-dataLen > 1)
            {
                if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    dataLen = wcslen(data);
                    if (dataLen > 0 && data[dataLen-1] == L'\n')
                    {
                        data[dataLen-1] = L'\0';
                    }
                }
                else
                {
                    printLine(""fgetws() failed"");
                    data[dataLen] = L'\0';
                }
            }
        }
        break;
    }
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    while(1)
    {
        wcscat(data, L""*.*"");
        break;
    }
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_console_w32spawnl_16_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_console_w32spawnl_16_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_console_w32spawnl_16_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_65a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_65b_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_65_bad()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_65b_badSink;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        wchar_t *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = wcslen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
            replace = wcschr(data, L'\r');
            if (replace)
            {
                *replace = L'\0';
            }
            replace = wcschr(data, L'\n');
            if (replace)
            {
                *replace = L'\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_65b_goodG2BSink(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_65b_goodG2BSink;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    funcPtr(data);
}
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_65_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_65_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_65_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_w32_execvp_54c.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#define EXECVP _execvp
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_w32_execvp_54d_badSink(char * data);
void CWE78_OS_Command_Injection__char_console_w32_execvp_54c_badSink(char * data)
{
    CWE78_OS_Command_Injection__char_console_w32_execvp_54d_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_console_w32_execvp_54d_goodG2BSink(char * data);
void CWE78_OS_Command_Injection__char_console_w32_execvp_54c_goodG2BSink(char * data)
{
    CWE78_OS_Command_Injection__char_console_w32_execvp_54d_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_execl_18.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#ifdef _WIN32
#include <process.h>
#define EXECL _wexecl
#else 
#define EXECL execl
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_execl_18_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goto source;
source:
    {
        size_t dataLen = wcslen(data);
        FILE * pFile;
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgetws() failed"");
                    data[dataLen] = L'\0';
                }
                fclose(pFile);
            }
        }
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goto source;
source:
    wcscat(data, L""*.*"");
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_file_execl_18_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_file_execl_18_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_file_execl_18_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_w32_execv_66b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#define EXECV _execv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_w32_execv_66b_badSink(char * dataArray[])
{
    char * data = dataArray[2];
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_listen_socket_w32_execv_66b_goodG2BSink(char * dataArray[])
{
    char * data = dataArray[2];
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_system_07.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#define SYSTEM _wsystem
#else 
#define SYSTEM system
#endif
static int staticFive = 5;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_system_07_bad()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(staticFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(staticFive==5)
    {
        wcscat(data, L""*.*"");
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
void CWE78_OS_Command_Injection__wchar_t_connect_socket_system_07_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_system_07_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_system_07_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_63b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_63b_badSink(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_63b_goodG2BSink(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_popen_10.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#define POPEN _popen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_popen_10_bad()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(char)] = '\0';
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
static void goodG2B2()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalTrue)
    {
        strcat(data, ""*.*"");
    }
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
void CWE78_OS_Command_Injection__char_connect_socket_popen_10_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_popen_10_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_popen_10_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_w32_execv_61a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#define EXECV _wexecv
#ifndef OMITBAD
wchar_t * CWE78_OS_Command_Injection__wchar_t_console_w32_execv_61b_badSource(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_console_w32_execv_61_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    data = CWE78_OS_Command_Injection__wchar_t_console_w32_execv_61b_badSource(data);
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
wchar_t * CWE78_OS_Command_Injection__wchar_t_console_w32_execv_61b_goodG2BSource(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    data = CWE78_OS_Command_Injection__wchar_t_console_w32_execv_61b_goodG2BSource(data);
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_console_w32_execv_61_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_console_w32_execv_61_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_console_w32_execv_61_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_environment_w32_execv_67b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#include <process.h>
#define EXECV _execv
typedef struct _CWE78_OS_Command_Injection__char_environment_w32_execv_67_structType
{
    char * structFirst;
} CWE78_OS_Command_Injection__char_environment_w32_execv_67_structType;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_w32_execv_67b_badSink(CWE78_OS_Command_Injection__char_environment_w32_execv_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_environment_w32_execv_67b_goodG2BSink(CWE78_OS_Command_Injection__char_environment_w32_execv_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_execl_34.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif
typedef union
{
    char * unionFirst;
    char * unionSecond;
} CWE78_OS_Command_Injection__char_listen_socket_execl_34_unionType;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_execl_34_bad()
{
    char * data;
    CWE78_OS_Command_Injection__char_listen_socket_execl_34_unionType myUnion;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    CWE78_OS_Command_Injection__char_listen_socket_execl_34_unionType myUnion;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
    }
}
void CWE78_OS_Command_Injection__char_listen_socket_execl_34_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_listen_socket_execl_34_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_listen_socket_execl_34_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_53a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#define POPEN _wpopen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_53b_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_53_bad()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        wchar_t *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = wcslen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
            replace = wcschr(data, L'\r');
            if (replace)
            {
                *replace = L'\0';
            }
            replace = wcschr(data, L'\n');
            if (replace)
            {
                *replace = L'\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_53b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_53b_goodG2BSink(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_53b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_53_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_53_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_53_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_34.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
typedef union
{
    wchar_t * unionFirst;
    wchar_t * unionSecond;
} CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_34_unionType;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_34_bad()
{
    wchar_t * data;
    CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_34_unionType myUnion;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = wcslen(data);
        FILE * pFile;
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgetws() failed"");
                    data[dataLen] = L'\0';
                }
                fclose(pFile);
            }
        }
    }
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
            _wspawnvp(_P_WAIT, COMMAND_INT, args);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_34_unionType myUnion;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
            _wspawnvp(_P_WAIT, COMMAND_INT, args);
        }
    }
}
void CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_34_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_34_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_34_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_04.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#include <process.h>
static const int STATIC_CONST_TRUE = 1; 
static const int STATIC_CONST_FALSE = 0; 
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_04_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        {
            size_t dataLen = wcslen(data);
            wchar_t * environment = GETENV(ENV_VARIABLE);
            if (environment != NULL)
            {
                wcsncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_04_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_04_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnv_04_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_file_execlp_53a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#ifdef _WIN32
#include <process.h>
#define EXECLP _execlp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_execlp_53b_badSink(char * data);
void CWE78_OS_Command_Injection__char_file_execlp_53_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        FILE * pFile;
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    CWE78_OS_Command_Injection__char_file_execlp_53b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_file_execlp_53b_goodG2BSink(char * data);
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_file_execlp_53b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__char_file_execlp_53_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_file_execlp_53_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_file_execlp_53_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_w32_spawnlp_12.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_w32_spawnlp_12_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        {
            size_t dataLen = strlen(data);
            if (100-dataLen > 1)
            {
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    data[dataLen] = '\0';
                }
            }
        }
    }
    else
    {
        strcat(data, ""*.*"");
    }
    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        strcat(data, ""*.*"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_console_w32_spawnlp_12_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_console_w32_spawnlp_12_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_console_w32_spawnlp_12_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_file_w32_execv_61b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#define EXECV _execv
#ifndef OMITBAD
char * CWE78_OS_Command_Injection__char_file_w32_execv_61b_badSource(char * data)
{
    {
        size_t dataLen = strlen(data);
        FILE * pFile;
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    return data;
}
#endif 
#ifndef OMITGOOD
char * CWE78_OS_Command_Injection__char_file_w32_execv_61b_goodG2BSource(char * data)
{
    strcat(data, ""*.*"");
    return data;
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_54a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_54b_badSink(char * data);
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_54_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_54b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_54b_goodG2BSink(char * data);
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_54b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_54_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_54_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_54_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_system_22b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifndef OMITBAD
extern int CWE78_OS_Command_Injection__wchar_t_console_system_22_badGlobal;
wchar_t * CWE78_OS_Command_Injection__wchar_t_console_system_22_badSource(wchar_t * data)
{
    if(CWE78_OS_Command_Injection__wchar_t_console_system_22_badGlobal)
    {
        {
            size_t dataLen = wcslen(data);
            if (100-dataLen > 1)
            {
                if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    dataLen = wcslen(data);
                    if (dataLen > 0 && data[dataLen-1] == L'\n')
                    {
                        data[dataLen-1] = L'\0';
                    }
                }
                else
                {
                    printLine(""fgetws() failed"");
                    data[dataLen] = L'\0';
                }
            }
        }
    }
    return data;
}
#endif 
#ifndef OMITGOOD
extern int CWE78_OS_Command_Injection__wchar_t_console_system_22_goodG2B1Global;
extern int CWE78_OS_Command_Injection__wchar_t_console_system_22_goodG2B2Global;
wchar_t * CWE78_OS_Command_Injection__wchar_t_console_system_22_goodG2B1Source(wchar_t * data)
{
    if(CWE78_OS_Command_Injection__wchar_t_console_system_22_goodG2B1Global)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    return data;
}
wchar_t * CWE78_OS_Command_Injection__wchar_t_console_system_22_goodG2B2Source(wchar_t * data)
{
    if(CWE78_OS_Command_Injection__wchar_t_console_system_22_goodG2B2Global)
    {
        wcscat(data, L""*.*"");
    }
    return data;
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_64b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_64b_badSink(void * dataVoidPtr)
{
    char * * dataPtr = (char * *)dataVoidPtr;
    char * data = (*dataPtr);
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_64b_goodG2BSink(void * dataVoidPtr)
{
    char * * dataPtr = (char * *)dataVoidPtr;
    char * data = (*dataPtr);
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif"
CWE78_OS_Command_Injection__char_environment_popen_04.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#define POPEN _popen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
static const int STATIC_CONST_TRUE = 1; 
static const int STATIC_CONST_FALSE = 0; 
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_popen_04_bad()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(STATIC_CONST_TRUE)
    {
        {
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            if (environment != NULL)
            {
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
static void goodG2B2()
{
    char * data;
    char data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(STATIC_CONST_TRUE)
    {
        strcat(data, ""*.*"");
    }
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
void CWE78_OS_Command_Injection__char_environment_popen_04_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_environment_popen_04_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_environment_popen_04_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_execl_41.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_execl_41_badSink(char * data)
{
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_listen_socket_execl_41_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__char_listen_socket_execl_41_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_listen_socket_execl_41_goodG2BSink(char * data)
{
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_listen_socket_execl_41_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__char_listen_socket_execl_41_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_listen_socket_execl_41_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_listen_socket_execl_41_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_w32_spawnlp_34.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
typedef union
{
    wchar_t * unionFirst;
    wchar_t * unionSecond;
} CWE78_OS_Command_Injection__wchar_t_console_w32_spawnlp_34_unionType;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnlp_34_bad()
{
    wchar_t * data;
    CWE78_OS_Command_Injection__wchar_t_console_w32_spawnlp_34_unionType myUnion;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = wcslen(data);
        if (100-dataLen > 1)
        {
            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                dataLen = wcslen(data);
                if (dataLen > 0 && data[dataLen-1] == L'\n')
                {
                    data[dataLen-1] = L'\0';
                }
            }
            else
            {
                printLine(""fgetws() failed"");
                data[dataLen] = L'\0';
            }
        }
    }
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        _wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    CWE78_OS_Command_Injection__wchar_t_console_w32_spawnlp_34_unionType myUnion;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        _wspawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
    }
}
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnlp_34_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_console_w32_spawnlp_34_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_console_w32_spawnlp_34_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_54c.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#define POPEN _wpopen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_54d_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_54c_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_54d_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_54d_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_54c_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_54d_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__char_file_w32spawnl_52c.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_w32spawnl_52c_badSink(char * data)
{
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_file_w32spawnl_52c_goodG2BSink(char * data)
{
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_53b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_53c_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_53b_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_53c_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_53c_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_53b_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_53c_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_w32_execv_67a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#define EXECV _wexecv
typedef struct _CWE78_OS_Command_Injection__wchar_t_file_w32_execv_67_structType
{
    wchar_t * structFirst;
} CWE78_OS_Command_Injection__wchar_t_file_w32_execv_67_structType;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_w32_execv_67b_badSink(CWE78_OS_Command_Injection__wchar_t_file_w32_execv_67_structType myStruct);
void CWE78_OS_Command_Injection__wchar_t_file_w32_execv_67_bad()
{
    wchar_t * data;
    CWE78_OS_Command_Injection__wchar_t_file_w32_execv_67_structType myStruct;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = wcslen(data);
        FILE * pFile;
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgetws() failed"");
                    data[dataLen] = L'\0';
                }
                fclose(pFile);
            }
        }
    }
    myStruct.structFirst = data;
    CWE78_OS_Command_Injection__wchar_t_file_w32_execv_67b_badSink(myStruct);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_file_w32_execv_67b_goodG2BSink(CWE78_OS_Command_Injection__wchar_t_file_w32_execv_67_structType myStruct);
static void goodG2B()
{
    wchar_t * data;
    CWE78_OS_Command_Injection__wchar_t_file_w32_execv_67_structType myStruct;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    myStruct.structFirst = data;
    CWE78_OS_Command_Injection__wchar_t_file_w32_execv_67b_goodG2BSink(myStruct);
}
void CWE78_OS_Command_Injection__wchar_t_file_w32_execv_67_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_execv_67_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_execv_67_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_environment_w32_spawnvp_61b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#include <process.h>
#ifndef OMITBAD
char * CWE78_OS_Command_Injection__char_environment_w32_spawnvp_61b_badSource(char * data)
{
    {
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    return data;
}
#endif 
#ifndef OMITGOOD
char * CWE78_OS_Command_Injection__char_environment_w32_spawnvp_61b_goodG2BSource(char * data)
{
    strcat(data, ""*.*"");
    return data;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_system_02.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#define SYSTEM _wsystem
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_system_02_bad()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(1)
    {
        {
            size_t dataLen = wcslen(data);
            if (100-dataLen > 1)
            {
                if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    dataLen = wcslen(data);
                    if (dataLen > 0 && data[dataLen-1] == L'\n')
                    {
                        data[dataLen-1] = L'\0';
                    }
                }
                else
                {
                    printLine(""fgetws() failed"");
                    data[dataLen] = L'\0';
                }
            }
        }
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(1)
    {
        wcscat(data, L""*.*"");
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
void CWE78_OS_Command_Injection__wchar_t_console_system_02_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_console_system_02_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_console_system_02_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_system_16.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#define SYSTEM _wsystem
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_system_16_bad()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    while(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        break;
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    while(1)
    {
        wcscat(data, L""*.*"");
        break;
    }
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_system_16_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_system_16_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_system_16_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_63b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_63b_badSink(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_63b_goodG2BSink(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif"
CWE78_OS_Command_Injection__char_environment_w32_spawnv_15.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_w32_spawnv_15_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    switch(6)
    {
    case 6:
    {
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        strcat(data, ""*.*"");
        break;
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    switch(6)
    {
    case 6:
        strcat(data, ""*.*"");
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__char_environment_w32_spawnv_15_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_environment_w32_spawnv_15_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_environment_w32_spawnv_15_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_popen_68b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#define POPEN _popen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
extern char * CWE78_OS_Command_Injection__char_listen_socket_popen_68_badData;
extern char * CWE78_OS_Command_Injection__char_listen_socket_popen_68_goodG2BData;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_popen_68b_badSink()
{
    char * data = CWE78_OS_Command_Injection__char_listen_socket_popen_68_badData;
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_listen_socket_popen_68b_goodG2BSink()
{
    char * data = CWE78_OS_Command_Injection__char_listen_socket_popen_68_goodG2BData;
    {
        FILE *pipe;
        pipe = POPEN(data, ""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_system_68b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#define SYSTEM system
#else 
#define SYSTEM system
#endif
extern char * CWE78_OS_Command_Injection__char_listen_socket_system_68_badData;
extern char * CWE78_OS_Command_Injection__char_listen_socket_system_68_goodG2BData;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_system_68b_badSink()
{
    char * data = CWE78_OS_Command_Injection__char_listen_socket_system_68_badData;
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_listen_socket_system_68b_goodG2BSink()
{
    char * data = CWE78_OS_Command_Injection__char_listen_socket_system_68_goodG2BData;
    if (SYSTEM(data) != 0)
    {
        printLine(""command execution failed!"");
        exit(1);
    }
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_execv_17.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#define EXECV _execv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32_execv_17_bad()
{
    int i;
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(char)] = '\0';
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int h;
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    for(h = 0; h < 1; h++)
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__char_connect_socket_w32_execv_17_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_execv_17_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_execv_17_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_44.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#ifndef OMITBAD
static void badSink(wchar_t * data)
{
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_44_bad()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = badSink;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = wcslen(data);
        if (100-dataLen > 1)
        {
            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                dataLen = wcslen(data);
                if (dataLen > 0 && data[dataLen-1] == L'\n')
                {
                    data[dataLen-1] = L'\0';
                }
            }
            else
            {
                printLine(""fgetws() failed"");
                data[dataLen] = L'\0';
            }
        }
    }
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(wchar_t * data)
{
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
static void goodG2B()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = goodG2BSink;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    funcPtr(data);
}
void CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_44_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_44_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_console_w32_spawnv_44_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_environment_w32_execv_65a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#include <process.h>
#define EXECV _execv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_w32_execv_65b_badSink(char * data);
void CWE78_OS_Command_Injection__char_environment_w32_execv_65_bad()
{
    char * data;
    void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_environment_w32_execv_65b_badSink;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_environment_w32_execv_65b_goodG2BSink(char * data);
static void goodG2B()
{
    char * data;
    void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_environment_w32_execv_65b_goodG2BSink;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    funcPtr(data);
}
void CWE78_OS_Command_Injection__char_environment_w32_execv_65_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_environment_w32_execv_65_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_environment_w32_execv_65_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_54a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#include <process.h>
#define EXECLP _wexeclp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_54b_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_54_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        wchar_t *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = wcslen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
            replace = wcschr(data, L'\r');
            if (replace)
            {
                *replace = L'\0';
            }
            replace = wcschr(data, L'\n');
            if (replace)
            {
                *replace = L'\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_54b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_54b_goodG2BSink(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_54b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_54_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_54_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_54_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_w32_execv_17.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#define EXECV _execv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_w32_execv_17_bad()
{
    int i;
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        {
            size_t dataLen = strlen(data);
            if (100-dataLen > 1)
            {
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    data[dataLen] = '\0';
                }
            }
        }
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int h;
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    for(h = 0; h < 1; h++)
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__char_console_w32_execv_17_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_console_w32_execv_17_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_console_w32_execv_17_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_execl_41.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_execl_41_badSink(char * data)
{
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_console_execl_41_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        if (100-dataLen > 1)
        {
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                data[dataLen] = '\0';
            }
        }
    }
    CWE78_OS_Command_Injection__char_console_execl_41_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_console_execl_41_goodG2BSink(char * data)
{
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_console_execl_41_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__char_console_execl_41_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_console_execl_41_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_console_execl_41_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_w32_execv_45.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#define EXECV _execv
static char * CWE78_OS_Command_Injection__char_console_w32_execv_45_badData;
static char * CWE78_OS_Command_Injection__char_console_w32_execv_45_goodG2BData;
#ifndef OMITBAD
static void badSink()
{
    char * data = CWE78_OS_Command_Injection__char_console_w32_execv_45_badData;
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__char_console_w32_execv_45_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        if (100-dataLen > 1)
        {
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                data[dataLen] = '\0';
            }
        }
    }
    CWE78_OS_Command_Injection__char_console_w32_execv_45_badData = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    char * data = CWE78_OS_Command_Injection__char_console_w32_execv_45_goodG2BData;
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_console_w32_execv_45_goodG2BData = data;
    goodG2BSink();
}
void CWE78_OS_Command_Injection__char_console_w32_execv_45_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_console_w32_execv_45_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_console_w32_execv_45_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_execl_12.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#include <process.h>
#define EXECL _execl
#else 
#define EXECL execl
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_execl_12_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(char)] = '\0';
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        strcat(data, ""*.*"");
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        strcat(data, ""*.*"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_listen_socket_execl_12_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_listen_socket_execl_12_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_listen_socket_execl_12_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_67b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
typedef struct _CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_67_structType
{
    char * structFirst;
} CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_67_structType;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_67b_badSink(CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_67b_goodG2BSink(CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif"
CWE78_OS_Command_Injection__char_environment_w32_execv_18.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#include <process.h>
#define EXECV _execv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_w32_execv_18_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goto source;
source:
    {
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goto source;
source:
    strcat(data, ""*.*"");
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__char_environment_w32_execv_18_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_environment_w32_execv_18_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_environment_w32_execv_18_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_66b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#define EXECVP _execvp
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_66b_badSink(char * dataArray[])
{
    char * data = dataArray[2];
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_66b_goodG2BSink(char * dataArray[])
{
    char * data = dataArray[2];
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
#endif"
CWE78_OS_Command_Injection__wchar_t_console_w32_execvp_10.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#define EXECVP _wexecvp
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_console_w32_execvp_10_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalTrue)
    {
        {
            size_t dataLen = wcslen(data);
            if (100-dataLen > 1)
            {
                if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    dataLen = wcslen(data);
                    if (dataLen > 0 && data[dataLen-1] == L'\n')
                    {
                        data[dataLen-1] = L'\0';
                    }
                }
                else
                {
                    printLine(""fgetws() failed"");
                    data[dataLen] = L'\0';
                }
            }
        }
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalTrue)
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_console_w32_execvp_10_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_console_w32_execvp_10_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_console_w32_execvp_10_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_12.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#define POPEN _wpopen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_12_bad()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    {
        FILE *pipe;
        pipe = POPEN(data, L""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(globalReturnsTrueOrFalse())
    {
        wcscat(data, L""*.*"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    {
        FILE *pipe;
        pipe = POPEN(data, L""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_12_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_12_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_12_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_execlp_08.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#ifdef _WIN32
#include <process.h>
#define EXECLP _wexeclp
#else 
#define EXECLP execlp
#endif
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_execlp_08_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        {
            size_t dataLen = wcslen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgetws() failed"");
                        data[dataLen] = L'\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        wcscat(data, L""*.*"");
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_file_execlp_08_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_file_execlp_08_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_file_execlp_08_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_file_w32_execvp_52a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#define EXECVP _execvp
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_w32_execvp_52b_badSink(char * data);
void CWE78_OS_Command_Injection__char_file_w32_execvp_52_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = strlen(data);
        FILE * pFile;
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    CWE78_OS_Command_Injection__char_file_w32_execvp_52b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_file_w32_execvp_52b_goodG2BSink(char * data);
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_file_w32_execvp_52b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__char_file_w32_execvp_52_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_file_w32_execvp_52_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_file_w32_execvp_52_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_execlp_54b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#include <process.h>
#define EXECLP _wexeclp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_execlp_54c_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_environment_execlp_54b_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_environment_execlp_54c_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_environment_execlp_54c_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_environment_execlp_54b_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_environment_execlp_54c_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_15.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_15_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    switch(6)
    {
    case 6:
    {
        size_t dataLen = wcslen(data);
        wchar_t * environment = GETENV(ENV_VARIABLE);
        if (environment != NULL)
        {
            wcsncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        wcscat(data, L""*.*"");
        break;
    }
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    switch(6)
    {
    case 6:
        wcscat(data, L""*.*"");
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_15_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_15_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_15_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_66b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_66b_badSink(char * dataArray[])
{
    char * data = dataArray[2];
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_66b_goodG2BSink(char * dataArray[])
{
    char * data = dataArray[2];
    _spawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__char_environment_w32_spawnvp_64b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_64b_badSink(void * dataVoidPtr)
{
    char * * dataPtr = (char * *)dataVoidPtr;
    char * data = (*dataPtr);
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_64b_goodG2BSink(void * dataVoidPtr)
{
    char * * dataPtr = (char * *)dataVoidPtr;
    char * data = (*dataPtr);
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif"
CWE78_OS_Command_Injection__char_file_w32_spawnlp_51b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_w32_spawnlp_51b_badSink(char * data)
{
    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_file_w32_spawnlp_51b_goodG2BSink(char * data)
{
    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_54e.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#define EXECV _wexecv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_54e_badSink(wchar_t * data)
{
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_54e_goodG2BSink(wchar_t * data)
{
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_31.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_31_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
            _spawnvp(_P_WAIT, COMMAND_INT, args);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
            _spawnvp(_P_WAIT, COMMAND_INT, args);
        }
    }
}
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_31_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_31_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_31_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_51a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#define EXECV _wexecv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_51b_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_51_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        wchar_t *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = wcslen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
            replace = wcschr(data, L'\r');
            if (replace)
            {
                *replace = L'\0';
            }
            replace = wcschr(data, L'\n');
            if (replace)
            {
                *replace = L'\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_51b_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_51b_goodG2BSink(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_51b_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_51_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_51_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_51_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_63b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_63b_badSink(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_environment_w32spawnl_63b_goodG2BSink(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_badData;
wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_goodG2BData;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68b_badSink();
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        wchar_t *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = wcslen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
            replace = wcschr(data, L'\r');
            if (replace)
            {
                *replace = L'\0';
            }
            replace = wcschr(data, L'\n');
            if (replace)
            {
                *replace = L'\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_badData = data;
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68b_badSink();
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68b_goodG2BSink();
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_goodG2BData = data;
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68b_goodG2BSink();
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_system_54d.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND ""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND ""ls ""
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#define SYSTEM system
#else 
#define SYSTEM system
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_system_54e_badSink(char * data);
void CWE78_OS_Command_Injection__char_connect_socket_system_54d_badSink(char * data)
{
    CWE78_OS_Command_Injection__char_connect_socket_system_54e_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_connect_socket_system_54e_goodG2BSink(char * data);
void CWE78_OS_Command_Injection__char_connect_socket_system_54d_goodG2BSink(char * data)
{
    CWE78_OS_Command_Injection__char_connect_socket_system_54e_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__char_file_w32_spawnv_08.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_w32_spawnv_08_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        {
            size_t dataLen = strlen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__char_file_w32_spawnv_08_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_file_w32_spawnv_08_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_file_w32_spawnv_08_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_54b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#define EXECVP _wexecvp
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_54c_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_54b_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_54c_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_54c_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_54b_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_54c_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_05.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_05_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(char)] = '\0';
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticTrue)
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_05_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_05_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_05_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_connect_socket_w32_execv_41.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#define EXECV _execv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_connect_socket_w32_execv_41_badSink(char * data)
{
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__char_connect_socket_w32_execv_41_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    CWE78_OS_Command_Injection__char_connect_socket_w32_execv_41_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_connect_socket_w32_execv_41_goodG2BSink(char * data)
{
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
static void goodG2B()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    strcat(data, ""*.*"");
    CWE78_OS_Command_Injection__char_connect_socket_w32_execv_41_goodG2BSink(data);
}
void CWE78_OS_Command_Injection__char_connect_socket_w32_execv_41_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_execv_41_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_connect_socket_w32_execv_41_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_file_w32_spawnv_51b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_w32_spawnv_51b_badSink(char * data)
{
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_file_w32_spawnv_51b_goodG2BSink(char * data)
{
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnv(_P_WAIT, COMMAND_INT_PATH, args);
    }
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_42.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#include <process.h>
#define EXECV _wexecv
#ifndef OMITBAD
static wchar_t * badSource(wchar_t * data)
{
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        wchar_t *replace;
        SOCKET connectSocket = INVALID_SOCKET;
        size_t dataLen = wcslen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
            replace = wcschr(data, L'\r');
            if (replace)
            {
                *replace = L'\0';
            }
            replace = wcschr(data, L'\n');
            if (replace)
            {
                *replace = L'\0';
            }
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    return data;
}
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_42_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    data = badSource(data);
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static wchar_t * goodG2BSource(wchar_t * data)
{
    wcscat(data, L""*.*"");
    return data;
}
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    data = goodG2BSource(data);
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_42_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_42_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_42_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_10.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#ifdef _WIN32
#include <process.h>
#define EXECLP _wexeclp
#else 
#define EXECLP execlp
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_10_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(globalTrue)
    {
        wcscat(data, L""*.*"");
    }
    EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_10_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_10_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_10_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_07.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
static int staticFive = 5;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_07_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFive==5)
    {
        {
            size_t dataLen = wcslen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgetws() failed"");
                        data[dataLen] = L'\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFive==5)
    {
        wcscat(data, L""*.*"");
    }
    _wspawnl(_P_WAIT, COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_07_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_07_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32spawnl_07_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_w32_execv_17.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#define EXECV _execv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_w32_execv_17_bad()
{
    int i;
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            char *replace;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            size_t dataLen = strlen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(char)] = '\0';
                replace = strchr(data, '\r');
                if (replace)
                {
                    *replace = '\0';
                }
                replace = strchr(data, '\n');
                if (replace)
                {
                    *replace = '\0';
                }
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int h;
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    for(h = 0; h < 1; h++)
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
void CWE78_OS_Command_Injection__char_listen_socket_w32_execv_17_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_listen_socket_w32_execv_17_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_listen_socket_w32_execv_17_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_21.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#ifdef _WIN32
#include <process.h>
#define EXECL _wexecl
#else 
#define EXECL execl
#endif
#ifndef OMITBAD
static int badStatic = 0;
static wchar_t * badSource(wchar_t * data)
{
    if(badStatic)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            wchar_t *replace;
            SOCKET connectSocket = INVALID_SOCKET;
            size_t dataLen = wcslen(data);
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
                replace = wcschr(data, L'\r');
                if (replace)
                {
                    *replace = L'\0';
                }
                replace = wcschr(data, L'\n');
                if (replace)
                {
                    *replace = L'\0';
                }
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    return data;
}
void CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_21_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    badStatic = 1; 
    data = badSource(data);
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static int goodG2B1Static = 0;
static int goodG2B2Static = 0;
static wchar_t * goodG2B1Source(wchar_t * data)
{
    if(goodG2B1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    return data;
}
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goodG2B1Static = 0; 
    data = goodG2B1Source(data);
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static wchar_t * goodG2B2Source(wchar_t * data)
{
    if(goodG2B2Static)
    {
        wcscat(data, L""*.*"");
    }
    return data;
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    goodG2B2Static = 1; 
    data = goodG2B2Source(data);
    EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_21_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_21_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_21_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_03.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_03_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(5==5)
    {
        {
            size_t dataLen = wcslen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgetws() failed"");
                        data[dataLen] = L'\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(5==5)
    {
        wcscat(data, L""*.*"");
    }
    {
        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _wspawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
void CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_03_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_03_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_spawnvp_03_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_file_w32_spawnlp_06.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_file_w32_spawnlp_06_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        {
            size_t dataLen = strlen(data);
            FILE * pFile;
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        strcat(data, ""*.*"");
    }
    _spawnlp(_P_WAIT, COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL);
}
void CWE78_OS_Command_Injection__char_file_w32_spawnlp_06_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_file_w32_spawnlp_06_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_file_w32_spawnlp_06_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_console_w32_execv_63b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#include <process.h>
#define EXECV _execv
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_console_w32_execv_63b_badSink(char * * dataPtr)
{
    char * data = *dataPtr;
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__char_console_w32_execv_63b_goodG2BSink(char * * dataPtr)
{
    char * data = *dataPtr;
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECV(COMMAND_INT_PATH, args);
    }
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_54b.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_54c_badSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_54b_badSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_54c_badSink(data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_54c_goodG2BSink(wchar_t * data);
void CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_54b_goodG2BSink(wchar_t * data)
{
    CWE78_OS_Command_Injection__wchar_t_environment_w32_spawnvp_54c_goodG2BSink(data);
}
#endif"
CWE78_OS_Command_Injection__wchar_t_environment_popen_09.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define FULL_COMMAND L""dir ""
#else
#include <unistd.h>
#define FULL_COMMAND L""ls ""
#endif
#define ENV_VARIABLE L""ADD""
#ifdef _WIN32
#define GETENV _wgetenv
#else
#define GETENV getenv
#endif
#ifdef _WIN32
#define POPEN _wpopen
#define PCLOSE _pclose
#else 
#define POPEN popen
#define PCLOSE pclose
#endif
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_environment_popen_09_bad()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(GLOBAL_CONST_TRUE)
    {
        {
            size_t dataLen = wcslen(data);
            wchar_t * environment = GETENV(ENV_VARIABLE);
            if (environment != NULL)
            {
                wcsncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    {
        FILE *pipe;
        pipe = POPEN(data, L""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wcscat(data, L""*.*"");
    }
    {
        FILE *pipe;
        pipe = POPEN(data, L""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
static void goodG2B2()
{
    wchar_t * data;
    wchar_t data_buf[100] = FULL_COMMAND;
    data = data_buf;
    if(GLOBAL_CONST_TRUE)
    {
        wcscat(data, L""*.*"");
    }
    {
        FILE *pipe;
        pipe = POPEN(data, L""w"");
        if (pipe != NULL)
        {
            PCLOSE(pipe);
        }
    }
}
void CWE78_OS_Command_Injection__wchar_t_environment_popen_09_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_popen_09_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_environment_popen_09_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_environment_w32_execvp_07.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#define ENV_VARIABLE ""ADD""
#ifdef _WIN32
#define GETENV getenv
#else
#define GETENV getenv
#endif
#include <process.h>
#define EXECVP _execvp
static int staticFive = 5;
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_environment_w32_execvp_07_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFive==5)
    {
        {
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            if (environment != NULL)
            {
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    if(staticFive==5)
    {
        strcat(data, ""*.*"");
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        EXECVP(COMMAND_INT, args);
    }
}
void CWE78_OS_Command_Injection__char_environment_w32_execvp_07_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_environment_w32_execvp_07_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_environment_w32_execvp_07_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_63a.c,CWE78,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH L""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT L""cmd.exe""
#define COMMAND_ARG1 L""/c""
#define COMMAND_ARG2 L""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH L""/bin/sh""
#define COMMAND_INT L""sh""
#define COMMAND_ARG1 L""-c""
#define COMMAND_ARG2 L""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#define FILENAME ""C:\\temp\\file.txt""
#else
#define FILENAME ""/tmp/file.txt""
#endif
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_63b_badSink(wchar_t * * dataPtr);
void CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_63_bad()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    {
        size_t dataLen = wcslen(data);
        FILE * pFile;
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgetws() failed"");
                    data[dataLen] = L'\0';
                }
                fclose(pFile);
            }
        }
    }
    CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_63b_badSink(&data);
}
#endif 
#ifndef OMITGOOD
void CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_63b_goodG2BSink(wchar_t * * data);
static void goodG2B()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    wcscat(data, L""*.*"");
    CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_63b_goodG2BSink(&data);
}
void CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_63_good()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_63_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__wchar_t_file_w32_spawnlp_63_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_15.c,CWE78,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe""
#define COMMAND_INT ""cmd.exe""
#define COMMAND_ARG1 ""/c""
#define COMMAND_ARG2 ""dir ""
#define COMMAND_ARG3 data
#else 
#include <unistd.h>
#define COMMAND_INT_PATH ""/bin/sh""
#define COMMAND_INT ""sh""
#define COMMAND_ARG1 ""-c""
#define COMMAND_ARG2 ""ls ""
#define COMMAND_ARG3 data
#endif
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#include <process.h>
#ifndef OMITBAD
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_15_bad()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    switch(6)
    {
    case 6:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        char *replace;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        size_t dataLen = strlen(data);
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            data[dataLen + recvResult / sizeof(char)] = '\0';
            replace = strchr(data, '\r');
            if (replace)
            {
                *replace = '\0';
            }
            replace = strchr(data, '\n');
            if (replace)
            {
                *replace = '\0';
            }
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        strcat(data, ""*.*"");
        break;
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
static void goodG2B2()
{
    char * data;
    char dataBuffer[100] = COMMAND_ARG2;
    data = dataBuffer;
    switch(6)
    {
    case 6:
        strcat(data, ""*.*"");
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};
        _spawnvp(_P_WAIT, COMMAND_INT, args);
    }
}
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_15_good()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_15_good();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_15_bad();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_fscanf_square_63a.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var(short * dataPtr);
void var()
{
    short data;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(short * data);
static void goodG2B()
{
    short data;
    data = 0;
    data = 2;
    var(&data);
}
void var(short * data);
static void goodB2G()
{
    short data;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    var(&data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_max_add_34.c,CWE190,good,"#include ""std_testcase.h""
typedef union
{
    int64_t unionFirst;
    int64_t unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    int64_t data;
    var myUnion;
    data = 0LL;
    data = LLONG_MAX;
    myUnion.unionFirst = data;
    {
        int64_t data = myUnion.unionSecond;
        {
            int64_t result = data + 1;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int64_t data;
    var myUnion;
    data = 0LL;
    data = 2;
    myUnion.unionFirst = data;
    {
        int64_t data = myUnion.unionSecond;
        {
            int64_t result = data + 1;
            printLongLongLine(result);
        }
    }
}
static void goodB2G()
{
    int64_t data;
    var myUnion;
    data = 0LL;
    data = LLONG_MAX;
    myUnion.unionFirst = data;
    {
        int64_t data = myUnion.unionSecond;
        if (data < LLONG_MAX)
        {
            int64_t result = data + 1;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_fscanf_preinc_32.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    char *dataPtr1 = &data;
    char *dataPtr2 = &data;
    data = ' ';
    {
        char data = *dataPtr1;
        fscanf (stdin, ""%c"", &data);
        *dataPtr1 = data;
    }
    {
        char data = *dataPtr2;
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char data;
    char *dataPtr1 = &data;
    char *dataPtr2 = &data;
    data = ' ';
    {
        char data = *dataPtr1;
        data = 2;
        *dataPtr1 = data;
    }
    {
        char data = *dataPtr2;
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
static void goodB2G()
{
    char data;
    char *dataPtr1 = &data;
    char *dataPtr2 = &data;
    data = ' ';
    {
        char data = *dataPtr1;
        fscanf (stdin, ""%c"", &data);
        *dataPtr1 = data;
    }
    {
        char data = *dataPtr2;
        if (data < CHAR_MAX)
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_max_square_65a.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var(char data);
void var()
{
    char data;
    void (*funcPtr) (char) = var;
    data = ' ';
    data = CHAR_MAX;
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(char data);
static void goodG2B()
{
    char data;
    void (*funcPtr) (char) = var;
    data = ' ';
    data = 2;
    funcPtr(data);
}
void var(char data);
static void goodB2G()
{
    char data;
    void (*funcPtr) (char) = var;
    data = ' ';
    data = CHAR_MAX;
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_max_add_51b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data)
{
    {
        int64_t result = data + 1;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int64_t data)
{
    {
        int64_t result = data + 1;
        printLongLongLine(result);
    }
}
void var(int64_t data)
{
    if (data < LLONG_MAX)
    {
        int64_t result = data + 1;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int_max_multiply_44.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
static void badSink(int data)
{
    if(data > 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
void var()
{
    int data;
    void (*funcPtr) (int) = badSink;
    data = 0;
    data = INT_MAX;
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(int data)
{
    if(data > 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
static void goodG2B()
{
    int data;
    void (*funcPtr) (int) = goodG2BSink;
    data = 0;
    data = 2;
    funcPtr(data);
}
static void goodB2GSink(int data)
{
    if(data > 0) 
    {
        if (data < (INT_MAX/2))
        {
            int result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G()
{
    int data;
    void (*funcPtr) (int) = goodB2GSink;
    data = 0;
    data = INT_MAX;
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_connect_socket_square_22b.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
extern int var;
void var(int data)
{
    if(var)
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
extern int var;
extern int var;
extern int var;
void var(int data)
{
    if(var)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var(int data)
{
    if(var)
    {
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var(int data)
{
    if(var)
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
#endif"
CWE190_Integer_Overflow__int_fgets_multiply_13.c,CWE190,bad,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data > 0) 
        {
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = 2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_fscanf_add_14.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(globalFive==5)
    {
        fscanf (stdin, ""%u"", &data);
    }
    if(globalFive==5)
    {
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(globalFive==5)
    {
        fscanf (stdin, ""%u"", &data);
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < UINT_MAX)
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(globalFive==5)
    {
        fscanf (stdin, ""%u"", &data);
    }
    if(globalFive==5)
    {
        if (data < UINT_MAX)
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(globalFive==5)
    {
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(globalFive==5)
    {
        data = 2;
    }
    if(globalFive==5)
    {
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_connect_socket_square_22a.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
int var = 0;
void var(int data);
void var()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var = 1; 
    var(data);
}
#endif 
#ifndef OMITGOOD
int var = 0;
int var = 0;
int var = 0;
void var(int data);
static void goodB2G1()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var = 0; 
    var(data);
}
void var(int data);
static void goodB2G2()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var = 1; 
    var(data);
}
void var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    var = 1; 
    var(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_rand_add_12.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        data = RAND32();
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
    else
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        data = RAND32();
    }
    else
    {
        data = RAND32();
    }
    if(globalReturnsTrueOrFalse())
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
    else
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        data = 2;
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
    else
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_square_10.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#include <inttypes.h>
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(globalTrue)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(globalTrue)
    {
        {
            int64_t result = data * data;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(globalTrue)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (imaxabs((intmax_t)data) <= sqrtl(LLONG_MAX))
        {
            int64_t result = data * data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(globalTrue)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(globalTrue)
    {
        if (imaxabs((intmax_t)data) <= sqrtl(LLONG_MAX))
        {
            int64_t result = data * data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(globalTrue)
    {
        {
            int64_t result = data * data;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(globalTrue)
    {
        data = 2;
    }
    if(globalTrue)
    {
        {
            int64_t result = data * data;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fscanf_square_06.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        data = 2;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_max_square_61b.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
short var(short data)
{
    data = SHRT_MAX;
    return data;
}
#endif 
#ifndef OMITGOOD
short var(short data)
{
    data = 2;
    return data;
}
short var(short data)
{
    data = SHRT_MAX;
    return data;
}
#endif"
CWE190_Integer_Overflow__char_rand_multiply_06.c,CWE190,good,"#include ""std_testcase.h""
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(STATIC_CONST_FIVE==5)
    {
        data = (char)RAND32();
    }
    if(STATIC_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            char result = data * 2;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(STATIC_CONST_FIVE==5)
    {
        data = (char)RAND32();
    }
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data > 0) 
        {
            if (data < (CHAR_MAX/2))
            {
                char result = data * 2;
                printHexCharLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(STATIC_CONST_FIVE==5)
    {
        data = (char)RAND32();
    }
    if(STATIC_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            if (data < (CHAR_MAX/2))
            {
                char result = data * 2;
                printHexCharLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(STATIC_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            char result = data * 2;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(STATIC_CONST_FIVE==5)
    {
        data = 2;
    }
    if(STATIC_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            char result = data * 2;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_multiply_06.c,CWE190,good,"#include <inttypes.h>
#include ""std_testcase.h""
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(STATIC_CONST_FIVE==5)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(STATIC_CONST_FIVE==5)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data > 0) 
        {
            if (data < (LLONG_MAX/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(STATIC_CONST_FIVE==5)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            if (data < (LLONG_MAX/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(STATIC_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(STATIC_CONST_FIVE==5)
    {
        data = 2;
    }
    if(STATIC_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_rand_add_53a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data);
void var()
{
    int data;
    data = 0;
    data = RAND32();
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    var(data);
}
void var(int data);
static void goodB2G()
{
    int data;
    data = 0;
    data = RAND32();
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_rand_multiply_13.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = (int64_t)RAND64();
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = (int64_t)RAND64();
    }
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data > 0) 
        {
            if (data < (LLONG_MAX/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = (int64_t)RAND64();
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            if (data < (LLONG_MAX/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = 2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_rand_add_54c.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data);
void var(char data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char data);
void var(char data)
{
    var(data);
}
void var(char data);
void var(char data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__int_connect_socket_multiply_11.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsTrue())
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data > 0) 
        {
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsTrue())
    {
        if(data > 0) 
        {
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrue())
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(globalReturnsTrue())
    {
        data = 2;
    }
    if(globalReturnsTrue())
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_rand_postinc_41.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
static void badSink(char data)
{
    {
        data++;
        char result = data;
        printHexCharLine(result);
    }
}
void var()
{
    char data;
    data = ' ';
    data = (char)RAND32();
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(char data)
{
    {
        data++;
        char result = data;
        printHexCharLine(result);
    }
}
static void goodG2B()
{
    char data;
    data = ' ';
    data = 2;
    goodG2BSink(data);
}
static void goodB2GSink(char data)
{
    if (data < CHAR_MAX)
    {
        data++;
        char result = data;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodB2G()
{
    char data;
    data = ' ';
    data = (char)RAND32();
    goodB2GSink(data);
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_connect_socket_multiply_64a.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(void * dataVoidPtr);
void var()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr);
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    var(&data);
}
void var(void * dataVoidPtr);
static void goodB2G()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var(&data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_postinc_09.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        data = (unsigned int)RAND32();
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        data = (unsigned int)RAND32();
    }
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < UINT_MAX)
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        data = (unsigned int)RAND32();
    }
    if(GLOBAL_CONST_TRUE)
    {
        if (data < UINT_MAX)
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        data = 2;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_preinc_07.c,CWE190,bad,"#include <inttypes.h>
#include ""std_testcase.h""
static int staticFive = 5;
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(staticFive==5)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(staticFive==5)
    {
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(staticFive==5)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < LLONG_MAX)
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(staticFive==5)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(staticFive==5)
    {
        if (data < LLONG_MAX)
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(staticFive==5)
    {
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(staticFive==5)
    {
        data = 2;
    }
    if(staticFive==5)
    {
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fscanf_multiply_12.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        fscanf(stdin, ""%d"", &data);
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
    else
    {
        if(data > 0) 
        {
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        fscanf(stdin, ""%d"", &data);
    }
    else
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(globalReturnsTrueOrFalse())
    {
        if(data > 0) 
        {
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
    else
    {
        if(data > 0) 
        {
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        data = 2;
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
    else
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_rand_add_51a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data);
void var()
{
    int data;
    data = 0;
    data = RAND32();
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    var(data);
}
void var(int data);
static void goodB2G()
{
    int data;
    data = 0;
    data = RAND32();
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_postinc_54e.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data)
{
    {
        data++;
        int64_t result = data;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int64_t data)
{
    {
        data++;
        int64_t result = data;
        printLongLongLine(result);
    }
}
void var(int64_t data)
{
    if (data < LLONG_MAX)
    {
        data++;
        int64_t result = data;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_add_08.c,CWE190,good,"#include ""std_testcase.h""
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(staticReturnsTrue())
    {
        data = (unsigned int)RAND32();
    }
    if(staticReturnsTrue())
    {
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(staticReturnsTrue())
    {
        data = (unsigned int)RAND32();
    }
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < UINT_MAX)
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(staticReturnsTrue())
    {
        data = (unsigned int)RAND32();
    }
    if(staticReturnsTrue())
    {
        if (data < UINT_MAX)
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(staticReturnsTrue())
    {
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(staticReturnsTrue())
    {
        data = 2;
    }
    if(staticReturnsTrue())
    {
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_rand_multiply_67b.c,CWE190,good,"#include ""std_testcase.h""
typedef struct _CWE190_Integer_Overflow__char_rand_multiply_67_structType
{
    char structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct)
{
    char data = myStruct.structFirst;
    if(data > 0) 
    {
        char result = data * 2;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(var myStruct)
{
    char data = myStruct.structFirst;
    if(data > 0) 
    {
        char result = data * 2;
        printHexCharLine(result);
    }
}
void var(var myStruct)
{
    char data = myStruct.structFirst;
    if(data > 0) 
    {
        if (data < (CHAR_MAX/2))
        {
            char result = data * 2;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif"
CWE190_Integer_Overflow__char_rand_postinc_14.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(globalFive==5)
    {
        data = (char)RAND32();
    }
    if(globalFive==5)
    {
        {
            data++;
            char result = data;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(globalFive==5)
    {
        data = (char)RAND32();
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < CHAR_MAX)
        {
            data++;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(globalFive==5)
    {
        data = (char)RAND32();
    }
    if(globalFive==5)
    {
        if (data < CHAR_MAX)
        {
            data++;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(globalFive==5)
    {
        {
            data++;
            char result = data;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(globalFive==5)
    {
        data = 2;
    }
    if(globalFive==5)
    {
        {
            data++;
            char result = data;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_connect_socket_postinc_03.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(5==5)
    {
        {
            data++;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < INT_MAX)
        {
            data++;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(5==5)
    {
        if (data < INT_MAX)
        {
            data++;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(5==5)
    {
        {
            data++;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(5==5)
    {
        data = 2;
    }
    if(5==5)
    {
        {
            data++;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_rand_preinc_63b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char * dataPtr)
{
    char data = *dataPtr;
    {
        ++data;
        char result = data;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * dataPtr)
{
    char data = *dataPtr;
    {
        ++data;
        char result = data;
        printHexCharLine(result);
    }
}
void var(char * dataPtr)
{
    char data = *dataPtr;
    if (data < CHAR_MAX)
    {
        ++data;
        char result = data;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_68a.c,CWE190,good,"#include ""std_testcase.h""
unsigned int var;
unsigned int var;
unsigned int var;
#ifndef OMITBAD
void var();
void var()
{
    unsigned int data;
    data = 0;
    fscanf (stdin, ""%u"", &data);
    var = data;
    var();
}
#endif 
#ifndef OMITGOOD
void var();
void var();
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = 2;
    var = data;
    var();
}
static void goodB2G()
{
    unsigned int data;
    data = 0;
    fscanf (stdin, ""%u"", &data);
    var = data;
    var();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_add_54c.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_add_53c.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_05.c,CWE190,good,"#include ""std_testcase.h""
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(staticTrue)
    {
        fscanf (stdin, ""%u"", &data);
    }
    if(staticTrue)
    {
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(staticTrue)
    {
        fscanf (stdin, ""%u"", &data);
    }
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < UINT_MAX)
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(staticTrue)
    {
        fscanf (stdin, ""%u"", &data);
    }
    if(staticTrue)
    {
        if (data < UINT_MAX)
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(staticTrue)
    {
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(staticTrue)
    {
        data = 2;
    }
    if(staticTrue)
    {
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_rand_square_53a.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var(int64_t data);
void var()
{
    int64_t data;
    data = 0LL;
    data = (int64_t)RAND64();
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t data);
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = 2;
    var(data);
}
void var(int64_t data);
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    data = (int64_t)RAND64();
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_listen_socket_add_08.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticReturnsTrue())
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticReturnsTrue())
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(staticReturnsTrue())
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        data = 2;
    }
    if(staticReturnsTrue())
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_listen_socket_square_64a.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#include <math.h>
#ifndef OMITBAD
void var(void * dataVoidPtr);
void var()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr);
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    var(&data);
}
void var(void * dataVoidPtr);
static void goodB2G()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var(&data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_listen_socket_preinc_32.c,CWE190,bad,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    data = 0;
    {
        int data = *dataPtr1;
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    data = 0;
    {
        int data = *dataPtr1;
        data = 2;
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodB2G()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    data = 0;
    {
        int data = *dataPtr1;
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        if (data < INT_MAX)
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_max_multiply_52c.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data)
{
    if(data > 0) 
    {
        unsigned int result = data * 2;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data)
{
    if(data > 0) 
    {
        unsigned int result = data * 2;
        printUnsignedLine(result);
    }
}
void var(unsigned int data)
{
    if(data > 0) 
    {
        if (data < (UINT_MAX/2))
        {
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif"
CWE190_Integer_Overflow__int64_t_max_preinc_63b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * dataPtr)
{
    int64_t data = *dataPtr;
    {
        ++data;
        int64_t result = data;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int64_t * dataPtr)
{
    int64_t data = *dataPtr;
    {
        ++data;
        int64_t result = data;
        printLongLongLine(result);
    }
}
void var(int64_t * dataPtr)
{
    int64_t data = *dataPtr;
    if (data < LLONG_MAX)
    {
        ++data;
        int64_t result = data;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__char_fscanf_postinc_21.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
static int badStatic = 0;
static void badSink(char data)
{
    if(badStatic)
    {
        {
            data++;
            char result = data;
            printHexCharLine(result);
        }
    }
}
void var()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    badStatic = 1; 
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static int goodB2G1Static = 0;
static int goodB2G2Static = 0;
static int goodG2BStatic = 0;
static void goodB2G1Sink(char data)
{
    if(goodB2G1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < CHAR_MAX)
        {
            data++;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G1()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    goodB2G1Static = 0; 
    goodB2G1Sink(data);
}
static void goodB2G2Sink(char data)
{
    if(goodB2G2Static)
    {
        if (data < CHAR_MAX)
        {
            data++;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    goodB2G2Static = 1; 
    goodB2G2Sink(data);
}
static void goodG2BSink(char data)
{
    if(goodG2BStatic)
    {
        {
            data++;
            char result = data;
            printHexCharLine(result);
        }
    }
}
static void goodG2B()
{
    char data;
    data = ' ';
    data = 2;
    goodG2BStatic = 1; 
    goodG2BSink(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_fscanf_multiply_68b.c,CWE190,good,"#include ""std_testcase.h""
extern char var;
extern char var;
extern char var;
#ifndef OMITBAD
void var()
{
    char data = var;
    if(data > 0) 
    {
        char result = data * 2;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    char data = var;
    if(data > 0) 
    {
        char result = data * 2;
        printHexCharLine(result);
    }
}
void var()
{
    char data = var;
    if(data > 0) 
    {
        if (data < (CHAR_MAX/2))
        {
            char result = data * 2;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif"
CWE190_Integer_Overflow__unsigned_int_max_add_51a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data);
void var()
{
    unsigned int data;
    data = 0;
    data = UINT_MAX;
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data);
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = 2;
    var(data);
}
void var(unsigned int data);
static void goodB2G()
{
    unsigned int data;
    data = 0;
    data = UINT_MAX;
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_rand_multiply_18.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    goto source;
source:
    data = (int64_t)RAND64();
    goto sink;
sink:
    if(data > 0) 
    {
        int64_t result = data * 2;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    goto source;
source:
    data = (int64_t)RAND64();
    goto sink;
sink:
    if(data > 0) 
    {
        if (data < (LLONG_MAX/2))
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    goto source;
source:
    data = 2;
    goto sink;
sink:
    if(data > 0) 
    {
        int64_t result = data * 2;
        printLongLongLine(result);
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_52a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data);
void var()
{
    unsigned int data;
    data = 0;
    fscanf (stdin, ""%u"", &data);
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data);
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = 2;
    var(data);
}
void var(unsigned int data);
static void goodB2G()
{
    unsigned int data;
    data = 0;
    fscanf (stdin, ""%u"", &data);
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fscanf_multiply_65a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data);
void var()
{
    int data;
    void (*funcPtr) (int) = var;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
static void goodG2B()
{
    int data;
    void (*funcPtr) (int) = var;
    data = 0;
    data = 2;
    funcPtr(data);
}
void var(int data);
static void goodB2G()
{
    int data;
    void (*funcPtr) (int) = var;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_rand_multiply_31.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    data = (char)RAND32();
    {
        char dataCopy = data;
        char data = dataCopy;
        if(data > 0) 
        {
            char result = data * 2;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char data;
    data = ' ';
    data = 2;
    {
        char dataCopy = data;
        char data = dataCopy;
        if(data > 0) 
        {
            char result = data * 2;
            printHexCharLine(result);
        }
    }
}
static void goodB2G()
{
    char data;
    data = ' ';
    data = (char)RAND32();
    {
        char dataCopy = data;
        char data = dataCopy;
        if(data > 0) 
        {
            if (data < (CHAR_MAX/2))
            {
                char result = data * 2;
                printHexCharLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_rand_postinc_14.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        data = RAND32();
    }
    if(globalFive==5)
    {
        {
            data++;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        data = RAND32();
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < INT_MAX)
        {
            data++;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        data = RAND32();
    }
    if(globalFive==5)
    {
        if (data < INT_MAX)
        {
            data++;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(globalFive==5)
    {
        {
            data++;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        data = 2;
    }
    if(globalFive==5)
    {
        {
            data++;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_max_postinc_03.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    if(5==5)
    {
        data = SHRT_MAX;
    }
    if(5==5)
    {
        {
            data++;
            short result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    short data;
    data = 0;
    if(5==5)
    {
        data = SHRT_MAX;
    }
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < SHRT_MAX)
        {
            data++;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    if(5==5)
    {
        data = SHRT_MAX;
    }
    if(5==5)
    {
        if (data < SHRT_MAX)
        {
            data++;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    short data;
    data = 0;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(5==5)
    {
        {
            data++;
            short result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    short data;
    data = 0;
    if(5==5)
    {
        data = 2;
    }
    if(5==5)
    {
        {
            data++;
            short result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_max_postinc_54b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data);
void var(char data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char data);
void var(char data)
{
    var(data);
}
void var(char data);
void var(char data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__int_fgets_square_32.c,CWE190,bad,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#include <math.h>
#ifndef OMITBAD
void var()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    data = 0;
    {
        int data = *dataPtr1;
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    data = 0;
    {
        int data = *dataPtr1;
        data = 2;
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
static void goodB2G()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    data = 0;
    {
        int data = *dataPtr1;
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_fscanf_square_61b.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
char var(char data)
{
    fscanf (stdin, ""%c"", &data);
    return data;
}
#endif 
#ifndef OMITGOOD
char var(char data)
{
    data = 2;
    return data;
}
char var(char data)
{
    fscanf (stdin, ""%c"", &data);
    return data;
}
#endif"
CWE190_Integer_Overflow__int_max_square_66b.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var(int dataArray[])
{
    int data = dataArray[2];
    {
        int result = data * data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int dataArray[])
{
    int data = dataArray[2];
    {
        int result = data * data;
        printIntLine(result);
    }
}
void var(int dataArray[])
{
    int data = dataArray[2];
    if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
    {
        int result = data * data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int_fgets_square_06.c,CWE190,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#include <math.h>
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        data = 2;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_postinc_12.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        data = (unsigned int)RAND32();
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
    else
    {
        if (data < UINT_MAX)
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    unsigned int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        data = (unsigned int)RAND32();
    }
    else
    {
        data = (unsigned int)RAND32();
    }
    if(globalReturnsTrueOrFalse())
    {
        if (data < UINT_MAX)
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
    else
    {
        if (data < UINT_MAX)
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B()
{
    unsigned int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        data = 2;
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
    else
    {
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fgets_add_08.c,CWE190,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(staticReturnsTrue())
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(staticReturnsTrue())
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(staticReturnsTrue())
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        data = 2;
    }
    if(staticReturnsTrue())
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_rand_preinc_17.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int i,j;
    int data;
    data = 0;
    for(i = 0; i < 1; i++)
    {
        data = RAND32();
    }
    for(j = 0; j < 1; j++)
    {
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int i,k;
    int data;
    data = 0;
    for(i = 0; i < 1; i++)
    {
        data = RAND32();
    }
    for(k = 0; k < 1; k++)
    {
        if (data < INT_MAX)
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B()
{
    int h,j;
    int data;
    data = 0;
    for(h = 0; h < 1; h++)
    {
        data = 2;
    }
    for(j = 0; j < 1; j++)
    {
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fgets_preinc_06.c,CWE190,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < INT_MAX)
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        if (data < INT_MAX)
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        data = 2;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_fscanf_add_18.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    goto source;
source:
    fscanf (stdin, ""%hd"", &data);
    goto sink;
sink:
    {
        short result = data + 1;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    short data;
    data = 0;
    goto source;
source:
    fscanf (stdin, ""%hd"", &data);
    goto sink;
sink:
    if (data < SHRT_MAX)
    {
        short result = data + 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodG2B()
{
    short data;
    data = 0;
    goto source;
source:
    data = 2;
    goto sink;
sink:
    {
        short result = data + 1;
        printIntLine(result);
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_multiply_63a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * dataPtr);
void var()
{
    int64_t data;
    data = 0LL;
    fscanf (stdin, ""%lld"", &data);
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t * data);
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = 2;
    var(&data);
}
void var(int64_t * data);
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    fscanf (stdin, ""%lld"", &data);
    var(&data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_connect_socket_square_08.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#include <math.h>
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticReturnsTrue())
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticReturnsTrue())
    {
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(staticReturnsTrue())
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        data = 2;
    }
    if(staticReturnsTrue())
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_rand_add_22b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
extern int var;
void var(char data)
{
    if(var)
    {
        {
            char result = data + 1;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
extern int var;
extern int var;
extern int var;
void var(char data)
{
    if(var)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < CHAR_MAX)
        {
            char result = data + 1;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var(char data)
{
    if(var)
    {
        if (data < CHAR_MAX)
        {
            char result = data + 1;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var(char data)
{
    if(var)
    {
        {
            char result = data + 1;
            printHexCharLine(result);
        }
    }
}
#endif"
CWE190_Integer_Overflow__char_fscanf_square_18.c,CWE190,bad,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    goto source;
source:
    fscanf (stdin, ""%c"", &data);
    goto sink;
sink:
    {
        char result = data * data;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    char data;
    data = ' ';
    goto source;
source:
    fscanf (stdin, ""%c"", &data);
    goto sink;
sink:
    if (abs((long)data) <= (long)sqrt((double)CHAR_MAX))
    {
        char result = data * data;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodG2B()
{
    char data;
    data = ' ';
    goto source;
source:
    data = 2;
    goto sink;
sink:
    {
        char result = data * data;
        printHexCharLine(result);
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_rand_multiply_51a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data);
void var()
{
    char data;
    data = ' ';
    data = (char)RAND32();
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char data);
static void goodG2B()
{
    char data;
    data = ' ';
    data = 2;
    var(data);
}
void var(char data);
static void goodB2G()
{
    char data;
    data = ' ';
    data = (char)RAND32();
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_rand_postinc_61a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
short var(short data);
void var()
{
    short data;
    data = 0;
    data = var(data);
    {
        data++;
        short result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
short var(short data);
static void goodG2B()
{
    short data;
    data = 0;
    data = var(data);
    {
        data++;
        short result = data;
        printIntLine(result);
    }
}
short var(short data);
static void goodB2G()
{
    short data;
    data = 0;
    data = var(data);
    if (data < SHRT_MAX)
    {
        data++;
        short result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_square_66a.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#include <inttypes.h>
#ifndef OMITBAD
void var(int64_t dataArray[]);
void var()
{
    int64_t data;
    int64_t dataArray[5];
    data = 0LL;
    fscanf (stdin, ""%"" SCNd64, &data);
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(int64_t dataArray[]);
static void goodG2B()
{
    int64_t data;
    int64_t dataArray[5];
    data = 0LL;
    data = 2;
    dataArray[2] = data;
    var(dataArray);
}
void var(int64_t dataArray[]);
static void goodB2G()
{
    int64_t data;
    int64_t dataArray[5];
    data = 0LL;
    fscanf (stdin, ""%"" SCNd64, &data);
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_fscanf_postinc_63b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char * dataPtr)
{
    char data = *dataPtr;
    {
        data++;
        char result = data;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * dataPtr)
{
    char data = *dataPtr;
    {
        data++;
        char result = data;
        printHexCharLine(result);
    }
}
void var(char * dataPtr)
{
    char data = *dataPtr;
    if (data < CHAR_MAX)
    {
        data++;
        char result = data;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int_listen_socket_preinc_53d.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data)
{
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
}
void var(int data)
{
    if (data < INT_MAX)
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__short_fscanf_postinc_14.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    if(globalFive==5)
    {
        fscanf (stdin, ""%hd"", &data);
    }
    if(globalFive==5)
    {
        {
            data++;
            short result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    short data;
    data = 0;
    if(globalFive==5)
    {
        fscanf (stdin, ""%hd"", &data);
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < SHRT_MAX)
        {
            data++;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    if(globalFive==5)
    {
        fscanf (stdin, ""%hd"", &data);
    }
    if(globalFive==5)
    {
        if (data < SHRT_MAX)
        {
            data++;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    short data;
    data = 0;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(globalFive==5)
    {
        {
            data++;
            short result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    short data;
    data = 0;
    if(globalFive==5)
    {
        data = 2;
    }
    if(globalFive==5)
    {
        {
            data++;
            short result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_square_42.c,CWE190,bad,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
static unsigned int badSource(unsigned int data)
{
    data = (unsigned int)RAND32();
    return data;
}
void var()
{
    unsigned int data;
    data = 0;
    data = badSource(data);
    {
        unsigned int result = data * data;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static unsigned int goodG2BSource(unsigned int data)
{
    data = 2;
    return data;
}
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = goodG2BSource(data);
    {
        unsigned int result = data * data;
        printUnsignedLine(result);
    }
}
static unsigned int goodB2GSource(unsigned int data)
{
    data = (unsigned int)RAND32();
    return data;
}
static void goodB2G()
{
    unsigned int data;
    data = 0;
    data = goodB2GSource(data);
    if (abs((long)data) < (long)sqrt((double)UINT_MAX))
    {
        unsigned int result = data * data;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_max_preinc_61a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
int var(int data);
void var()
{
    int data;
    data = 0;
    data = var(data);
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
int var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = var(data);
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
}
int var(int data);
static void goodB2G()
{
    int data;
    data = 0;
    data = var(data);
    if (data < INT_MAX)
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_max_postinc_65a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data);
void var()
{
    short data;
    void (*funcPtr) (short) = var;
    data = 0;
    data = SHRT_MAX;
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(short data);
static void goodG2B()
{
    short data;
    void (*funcPtr) (short) = var;
    data = 0;
    data = 2;
    funcPtr(data);
}
void var(short data);
static void goodB2G()
{
    short data;
    void (*funcPtr) (short) = var;
    data = 0;
    data = SHRT_MAX;
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_max_square_66b.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var(char dataArray[])
{
    char data = dataArray[2];
    {
        char result = data * data;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(char dataArray[])
{
    char data = dataArray[2];
    {
        char result = data * data;
        printHexCharLine(result);
    }
}
void var(char dataArray[])
{
    char data = dataArray[2];
    if (abs((long)data) <= (long)sqrt((double)CHAR_MAX))
    {
        char result = data * data;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int_listen_socket_square_53b.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#include <math.h>
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_square_34.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#include <inttypes.h>
typedef union
{
    int64_t unionFirst;
    int64_t unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    int64_t data;
    var myUnion;
    data = 0LL;
    fscanf (stdin, ""%"" SCNd64, &data);
    myUnion.unionFirst = data;
    {
        int64_t data = myUnion.unionSecond;
        {
            int64_t result = data * data;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int64_t data;
    var myUnion;
    data = 0LL;
    data = 2;
    myUnion.unionFirst = data;
    {
        int64_t data = myUnion.unionSecond;
        {
            int64_t result = data * data;
            printLongLongLine(result);
        }
    }
}
static void goodB2G()
{
    int64_t data;
    var myUnion;
    data = 0LL;
    fscanf (stdin, ""%"" SCNd64, &data);
    myUnion.unionFirst = data;
    {
        int64_t data = myUnion.unionSecond;
        if (imaxabs((intmax_t)data) <= sqrtl(LLONG_MAX))
        {
            int64_t result = data * data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_rand_multiply_65a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data);
void var()
{
    int data;
    void (*funcPtr) (int) = var;
    data = 0;
    data = RAND32();
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
static void goodG2B()
{
    int data;
    void (*funcPtr) (int) = var;
    data = 0;
    data = 2;
    funcPtr(data);
}
void var(int data);
static void goodB2G()
{
    int data;
    void (*funcPtr) (int) = var;
    data = 0;
    data = RAND32();
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_square_61a.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
unsigned int var(unsigned int data);
void var()
{
    unsigned int data;
    data = 0;
    data = var(data);
    {
        unsigned int result = data * data;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
unsigned int var(unsigned int data);
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = var(data);
    {
        unsigned int result = data * data;
        printUnsignedLine(result);
    }
}
unsigned int var(unsigned int data);
static void goodB2G()
{
    unsigned int data;
    data = 0;
    data = var(data);
    if (abs((long)data) <= (long)sqrt((double)UINT_MAX))
    {
        unsigned int result = data * data;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_rand_add_16.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    while(1)
    {
        data = (int64_t)RAND64();
        break;
    }
    while(1)
    {
        {
            int64_t result = data + 1;
            printLongLongLine(result);
        }
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    while(1)
    {
        data = (int64_t)RAND64();
        break;
    }
    while(1)
    {
        if (data < LLONG_MAX)
        {
            int64_t result = data + 1;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
        break;
    }
}
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    while(1)
    {
        data = 2;
        break;
    }
    while(1)
    {
        {
            int64_t result = data + 1;
            printLongLongLine(result);
        }
        break;
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_rand_add_61b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
char var(char data)
{
    data = (char)RAND32();
    return data;
}
#endif 
#ifndef OMITGOOD
char var(char data)
{
    data = 2;
    return data;
}
char var(char data)
{
    data = (char)RAND32();
    return data;
}
#endif"
CWE190_Integer_Overflow__int64_t_max_multiply_32.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    int64_t *dataPtr1 = &data;
    int64_t *dataPtr2 = &data;
    data = 0LL;
    {
        int64_t data = *dataPtr1;
        data = LLONG_MAX;
        *dataPtr1 = data;
    }
    {
        int64_t data = *dataPtr2;
        if(data > 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int64_t data;
    int64_t *dataPtr1 = &data;
    int64_t *dataPtr2 = &data;
    data = 0LL;
    {
        int64_t data = *dataPtr1;
        data = 2;
        *dataPtr1 = data;
    }
    {
        int64_t data = *dataPtr2;
        if(data > 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
static void goodB2G()
{
    int64_t data;
    int64_t *dataPtr1 = &data;
    int64_t *dataPtr2 = &data;
    data = 0LL;
    {
        int64_t data = *dataPtr1;
        data = LLONG_MAX;
        *dataPtr1 = data;
    }
    {
        int64_t data = *dataPtr2;
        if(data > 0) 
        {
            if (data < (LLONG_MAX/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_preinc_63a.c,CWE190,good,"#include <inttypes.h>
#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * dataPtr);
void var()
{
    int64_t data;
    data = 0LL;
    fscanf (stdin, ""%"" SCNd64, &data);
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t * data);
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = 2;
    var(&data);
}
void var(int64_t * data);
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    fscanf (stdin, ""%"" SCNd64, &data);
    var(&data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_listen_socket_multiply_64b.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    int * dataPtr = (int *)dataVoidPtr;
    int data = (*dataPtr);
    if(data > 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    int * dataPtr = (int *)dataVoidPtr;
    int data = (*dataPtr);
    if(data > 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
void var(void * dataVoidPtr)
{
    int * dataPtr = (int *)dataVoidPtr;
    int data = (*dataPtr);
    if(data > 0) 
    {
        if (data < (INT_MAX/2))
        {
            int result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif"
CWE190_Integer_Overflow__unsigned_int_fscanf_square_12.c,CWE190,bad,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        fscanf (stdin, ""%u"", &data);
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
    }
    else
    {
        if (abs((long)data) < (long)sqrt((double)UINT_MAX))
        {
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    unsigned int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        fscanf (stdin, ""%u"", &data);
    }
    else
    {
        fscanf (stdin, ""%u"", &data);
    }
    if(globalReturnsTrueOrFalse())
    {
        if (abs((long)data) < (long)sqrt((double)UINT_MAX))
        {
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
    else
    {
        if (abs((long)data) < (long)sqrt((double)UINT_MAX))
        {
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B()
{
    unsigned int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        data = 2;
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
    }
    else
    {
        {
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_rand_multiply_65b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data)
{
    if(data > 0) 
    {
        char result = data * 2;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(char data)
{
    if(data > 0) 
    {
        char result = data * 2;
        printHexCharLine(result);
    }
}
void var(char data)
{
    if(data > 0) 
    {
        if (data < (CHAR_MAX/2))
        {
            char result = data * 2;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif"
CWE190_Integer_Overflow__unsigned_int_fscanf_add_63b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int * dataPtr)
{
    unsigned int data = *dataPtr;
    {
        unsigned int result = data + 1;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(unsigned int * dataPtr)
{
    unsigned int data = *dataPtr;
    {
        unsigned int result = data + 1;
        printUnsignedLine(result);
    }
}
void var(unsigned int * dataPtr)
{
    unsigned int data = *dataPtr;
    if (data < UINT_MAX)
    {
        unsigned int result = data + 1;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_square_51a.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#include <inttypes.h>
#ifndef OMITBAD
void var(int64_t data);
void var()
{
    int64_t data;
    data = 0LL;
    fscanf (stdin, ""%"" SCNd64, &data);
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t data);
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = 2;
    var(data);
}
void var(int64_t data);
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    fscanf (stdin, ""%"" SCNd64, &data);
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fgets_add_18.c,CWE190,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    goto source;
source:
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    goto sink;
sink:
    {
        int result = data + 1;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int data;
    data = 0;
    goto source;
source:
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    goto sink;
sink:
    if (data < INT_MAX)
    {
        int result = data + 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    goto source;
source:
    data = 2;
    goto sink;
sink:
    {
        int result = data + 1;
        printIntLine(result);
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fscanf_multiply_06.c,CWE190,good,"#include ""std_testcase.h""
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data > 0) 
        {
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(STATIC_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        data = 2;
    }
    if(STATIC_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_64b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    unsigned int * dataPtr = (unsigned int *)dataVoidPtr;
    unsigned int data = (*dataPtr);
    {
        data++;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    unsigned int * dataPtr = (unsigned int *)dataVoidPtr;
    unsigned int data = (*dataPtr);
    {
        data++;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
void var(void * dataVoidPtr)
{
    unsigned int * dataPtr = (unsigned int *)dataVoidPtr;
    unsigned int data = (*dataPtr);
    if (data < UINT_MAX)
    {
        data++;
        unsigned int result = data;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int64_t_max_multiply_02.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(1)
    {
        data = LLONG_MAX;
    }
    if(1)
    {
        if(data > 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(1)
    {
        data = LLONG_MAX;
    }
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data > 0) 
        {
            if (data < (LLONG_MAX/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(1)
    {
        data = LLONG_MAX;
    }
    if(1)
    {
        if(data > 0) 
        {
            if (data < (LLONG_MAX/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(1)
    {
        if(data > 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(1)
    {
        data = 2;
    }
    if(1)
    {
        if(data > 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_multiply_02.c,CWE190,good,"#include <inttypes.h>
#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(1)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(1)
    {
        if(data > 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(1)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data > 0) 
        {
            if (data < (LLONG_MAX/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(1)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(1)
    {
        if(data > 0) 
        {
            if (data < (LLONG_MAX/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(1)
    {
        if(data > 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(1)
    {
        data = 2;
    }
    if(1)
    {
        if(data > 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_fscanf_preinc_21.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
static int badStatic = 0;
static void badSink(char data)
{
    if(badStatic)
    {
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
void var()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    badStatic = 1; 
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static int goodB2G1Static = 0;
static int goodB2G2Static = 0;
static int goodG2BStatic = 0;
static void goodB2G1Sink(char data)
{
    if(goodB2G1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < CHAR_MAX)
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G1()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    goodB2G1Static = 0; 
    goodB2G1Sink(data);
}
static void goodB2G2Sink(char data)
{
    if(goodB2G2Static)
    {
        if (data < CHAR_MAX)
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    goodB2G2Static = 1; 
    goodB2G2Sink(data);
}
static void goodG2BSink(char data)
{
    if(goodG2BStatic)
    {
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
static void goodG2B()
{
    char data;
    data = ' ';
    data = 2;
    goodG2BStatic = 1; 
    goodG2BSink(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fgets_postinc_51a.c,CWE190,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data);
void var()
{
    int data;
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    var(data);
}
void var(int data);
static void goodB2G()
{
    int data;
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_rand_square_12.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        data = RAND32();
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
    else
    {
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        data = RAND32();
    }
    else
    {
        data = RAND32();
    }
    if(globalReturnsTrueOrFalse())
    {
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
    else
    {
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        data = 2;
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
    else
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fgets_multiply_67b.c,CWE190,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
typedef struct _CWE190_Integer_Overflow__int_fgets_multiply_67_structType
{
    int structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct)
{
    int data = myStruct.structFirst;
    if(data > 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(var myStruct)
{
    int data = myStruct.structFirst;
    if(data > 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
void var(var myStruct)
{
    int data = myStruct.structFirst;
    if(data > 0) 
    {
        if (data < (INT_MAX/2))
        {
            int result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif"
CWE190_Integer_Overflow__int_fgets_multiply_10.c,CWE190,bad,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalTrue)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(globalTrue)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(globalTrue)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data > 0) 
        {
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(globalTrue)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(globalTrue)
    {
        if(data > 0) 
        {
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(globalTrue)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(globalTrue)
    {
        data = 2;
    }
    if(globalTrue)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_fscanf_add_45.c,CWE190,bad,"#include ""std_testcase.h""
static char var;
static char var;
static char var;
#ifndef OMITBAD
static void badSink()
{
    char data = var;
    {
        char result = data + 1;
        printHexCharLine(result);
    }
}
void var()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    char data = var;
    {
        char result = data + 1;
        printHexCharLine(result);
    }
}
static void goodG2B()
{
    char data;
    data = ' ';
    data = 2;
    var = data;
    goodG2BSink();
}
static void goodB2GSink()
{
    char data = var;
    if (data < CHAR_MAX)
    {
        char result = data + 1;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodB2G()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    var = data;
    goodB2GSink();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_connect_socket_square_51a.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#include <math.h>
#ifndef OMITBAD
void var(int data);
void var()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    var(data);
}
void var(int data);
static void goodB2G()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_max_square_16.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    while(1)
    {
        data = SHRT_MAX;
        break;
    }
    while(1)
    {
        {
            short result = data * data;
            printIntLine(result);
        }
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    short data;
    data = 0;
    while(1)
    {
        data = SHRT_MAX;
        break;
    }
    while(1)
    {
        if (abs((long)data) <= (long)sqrt((double)SHRT_MAX))
        {
            short result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
        break;
    }
}
static void goodG2B()
{
    short data;
    data = 0;
    while(1)
    {
        data = 2;
        break;
    }
    while(1)
    {
        {
            short result = data * data;
            printIntLine(result);
        }
        break;
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_square_02.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(1)
    {
        data = (unsigned int)RAND32();
    }
    if(1)
    {
        {
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(1)
    {
        data = (unsigned int)RAND32();
    }
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (abs((long)data) < (long)sqrt((double)UINT_MAX))
        {
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(1)
    {
        data = (unsigned int)RAND32();
    }
    if(1)
    {
        if (abs((long)data) < (long)sqrt((double)UINT_MAX))
        {
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(1)
    {
        {
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(1)
    {
        data = 2;
    }
    if(1)
    {
        {
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_fscanf_postinc_22a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
int var = 0;
void var(short data);
void var()
{
    short data;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    var = 1; 
    var(data);
}
#endif 
#ifndef OMITGOOD
int var = 0;
int var = 0;
int var = 0;
void var(short data);
static void goodB2G1()
{
    short data;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    var = 0; 
    var(data);
}
void var(short data);
static void goodB2G2()
{
    short data;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    var = 1; 
    var(data);
}
void var(short data);
static void goodG2B()
{
    short data;
    data = 0;
    data = 2;
    var = 1; 
    var(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_max_preinc_61b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
int var(int data)
{
    data = INT_MAX;
    return data;
}
#endif 
#ifndef OMITGOOD
int var(int data)
{
    data = 2;
    return data;
}
int var(int data)
{
    data = INT_MAX;
    return data;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_max_preinc_54a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data);
void var()
{
    unsigned int data;
    data = 0;
    data = UINT_MAX;
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data);
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = 2;
    var(data);
}
void var(unsigned int data);
static void goodB2G()
{
    unsigned int data;
    data = 0;
    data = UINT_MAX;
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_rand_multiply_02.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(1)
    {
        data = (int64_t)RAND64();
    }
    if(1)
    {
        if(data > 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(1)
    {
        data = (int64_t)RAND64();
    }
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data > 0) 
        {
            if (data < (LLONG_MAX/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(1)
    {
        data = (int64_t)RAND64();
    }
    if(1)
    {
        if(data > 0) 
        {
            if (data < (LLONG_MAX/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(1)
    {
        if(data > 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(1)
    {
        data = 2;
    }
    if(1)
    {
        if(data > 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_connect_socket_preinc_61a.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
int var(int data);
void var()
{
    int data;
    data = 0;
    data = var(data);
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
int var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = var(data);
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
}
int var(int data);
static void goodB2G()
{
    int data;
    data = 0;
    data = var(data);
    if (data < INT_MAX)
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_max_add_21.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
static int badStatic = 0;
static void badSink(char data)
{
    if(badStatic)
    {
        {
            char result = data + 1;
            printHexCharLine(result);
        }
    }
}
void var()
{
    char data;
    data = ' ';
    data = CHAR_MAX;
    badStatic = 1; 
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static int goodB2G1Static = 0;
static int goodB2G2Static = 0;
static int goodG2BStatic = 0;
static void goodB2G1Sink(char data)
{
    if(goodB2G1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < CHAR_MAX)
        {
            char result = data + 1;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G1()
{
    char data;
    data = ' ';
    data = CHAR_MAX;
    goodB2G1Static = 0; 
    goodB2G1Sink(data);
}
static void goodB2G2Sink(char data)
{
    if(goodB2G2Static)
    {
        if (data < CHAR_MAX)
        {
            char result = data + 1;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    data = CHAR_MAX;
    goodB2G2Static = 1; 
    goodB2G2Sink(data);
}
static void goodG2BSink(char data)
{
    if(goodG2BStatic)
    {
        {
            char result = data + 1;
            printHexCharLine(result);
        }
    }
}
static void goodG2B()
{
    char data;
    data = ' ';
    data = 2;
    goodG2BStatic = 1; 
    goodG2BSink(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_max_add_68b.c,CWE190,good,"#include ""std_testcase.h""
extern char var;
extern char var;
extern char var;
#ifndef OMITBAD
void var()
{
    char data = var;
    {
        char result = data + 1;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    char data = var;
    {
        char result = data + 1;
        printHexCharLine(result);
    }
}
void var()
{
    char data = var;
    if (data < CHAR_MAX)
    {
        char result = data + 1;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__char_max_add_18.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    goto source;
source:
    data = CHAR_MAX;
    goto sink;
sink:
    {
        char result = data + 1;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    char data;
    data = ' ';
    goto source;
source:
    data = CHAR_MAX;
    goto sink;
sink:
    if (data < CHAR_MAX)
    {
        char result = data + 1;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodG2B()
{
    char data;
    data = ' ';
    goto source;
source:
    data = 2;
    goto sink;
sink:
    {
        char result = data + 1;
        printHexCharLine(result);
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_connect_socket_preinc_63a.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int * dataPtr);
void var()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(int * data);
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    var(&data);
}
void var(int * data);
static void goodB2G()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var(&data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_max_add_11.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(globalReturnsTrue())
    {
        data = UINT_MAX;
    }
    if(globalReturnsTrue())
    {
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(globalReturnsTrue())
    {
        data = UINT_MAX;
    }
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < UINT_MAX)
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(globalReturnsTrue())
    {
        data = UINT_MAX;
    }
    if(globalReturnsTrue())
    {
        if (data < UINT_MAX)
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrue())
    {
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(globalReturnsTrue())
    {
        data = 2;
    }
    if(globalReturnsTrue())
    {
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_65b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data)
{
    {
        data++;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data)
{
    {
        data++;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
void var(unsigned int data)
{
    if (data < UINT_MAX)
    {
        data++;
        unsigned int result = data;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_add_42.c,CWE190,bad,"#include <inttypes.h>
#include ""std_testcase.h""
#ifndef OMITBAD
static int64_t badSource(int64_t data)
{
    fscanf (stdin, ""%"" SCNd64, &data);
    return data;
}
void var()
{
    int64_t data;
    data = 0LL;
    data = badSource(data);
    {
        int64_t result = data + 1;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static int64_t goodG2BSource(int64_t data)
{
    data = 2;
    return data;
}
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = goodG2BSource(data);
    {
        int64_t result = data + 1;
        printLongLongLine(result);
    }
}
static int64_t goodB2GSource(int64_t data)
{
    fscanf (stdin, ""%"" SCNd64, &data);
    return data;
}
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    data = goodB2GSource(data);
    if (data < LLONG_MAX)
    {
        int64_t result = data + 1;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fgets_preinc_21.c,CWE190,bad,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
static int badStatic = 0;
static void badSink(int data)
{
    if(badStatic)
    {
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    int data;
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    badStatic = 1; 
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static int goodB2G1Static = 0;
static int goodB2G2Static = 0;
static int goodG2BStatic = 0;
static void goodB2G1Sink(int data)
{
    if(goodB2G1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < INT_MAX)
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G1()
{
    int data;
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    goodB2G1Static = 0; 
    goodB2G1Sink(data);
}
static void goodB2G2Sink(int data)
{
    if(goodB2G2Static)
    {
        if (data < INT_MAX)
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    goodB2G2Static = 1; 
    goodB2G2Sink(data);
}
static void goodG2BSink(int data)
{
    if(goodG2BStatic)
    {
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    goodG2BStatic = 1; 
    goodG2BSink(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fscanf_postinc_22a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
int var = 0;
void var(int data);
void var()
{
    int data;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    var = 1; 
    var(data);
}
#endif 
#ifndef OMITGOOD
int var = 0;
int var = 0;
int var = 0;
void var(int data);
static void goodB2G1()
{
    int data;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    var = 0; 
    var(data);
}
void var(int data);
static void goodB2G2()
{
    int data;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    var = 1; 
    var(data);
}
void var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    var = 1; 
    var(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_rand_square_51b.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var(char data)
{
    {
        char result = data * data;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(char data)
{
    {
        char result = data * data;
        printHexCharLine(result);
    }
}
void var(char data)
{
    if (abs((long)data) <= (long)sqrt((double)CHAR_MAX))
    {
        char result = data * data;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__char_max_multiply_64a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(void * dataVoidPtr);
void var()
{
    char data;
    data = ' ';
    data = CHAR_MAX;
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr);
static void goodG2B()
{
    char data;
    data = ' ';
    data = 2;
    var(&data);
}
void var(void * dataVoidPtr);
static void goodB2G()
{
    char data;
    data = ' ';
    data = CHAR_MAX;
    var(&data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_rand_add_54c.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data);
void var(short data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(short data);
void var(short data)
{
    var(data);
}
void var(short data);
void var(short data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__short_fscanf_multiply_54e.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data)
{
    if(data > 0) 
    {
        short result = data * 2;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(short data)
{
    if(data > 0) 
    {
        short result = data * 2;
        printIntLine(result);
    }
}
void var(short data)
{
    if(data > 0) 
    {
        if (data < (SHRT_MAX/2))
        {
            short result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif"
CWE190_Integer_Overflow__int_max_square_31.c,CWE190,bad,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    data = INT_MAX;
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
static void goodB2G()
{
    int data;
    data = 0;
    data = INT_MAX;
    {
        int dataCopy = data;
        int data = dataCopy;
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_fscanf_preinc_68b.c,CWE190,good,"#include ""std_testcase.h""
extern char var;
extern char var;
extern char var;
#ifndef OMITBAD
void var()
{
    char data = var;
    {
        ++data;
        char result = data;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    char data = var;
    {
        ++data;
        char result = data;
        printHexCharLine(result);
    }
}
void var()
{
    char data = var;
    if (data < CHAR_MAX)
    {
        ++data;
        char result = data;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int_fscanf_postinc_64a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(void * dataVoidPtr);
void var()
{
    int data;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr);
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    var(&data);
}
void var(void * dataVoidPtr);
static void goodB2G()
{
    int data;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    var(&data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_rand_postinc_21.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
static int badStatic = 0;
static void badSink(int data)
{
    if(badStatic)
    {
        {
            data++;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    int data;
    data = 0;
    data = RAND32();
    badStatic = 1; 
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static int goodB2G1Static = 0;
static int goodB2G2Static = 0;
static int goodG2BStatic = 0;
static void goodB2G1Sink(int data)
{
    if(goodB2G1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < INT_MAX)
        {
            data++;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G1()
{
    int data;
    data = 0;
    data = RAND32();
    goodB2G1Static = 0; 
    goodB2G1Sink(data);
}
static void goodB2G2Sink(int data)
{
    if(goodB2G2Static)
    {
        if (data < INT_MAX)
        {
            data++;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    data = RAND32();
    goodB2G2Static = 1; 
    goodB2G2Sink(data);
}
static void goodG2BSink(int data)
{
    if(goodG2BStatic)
    {
        {
            data++;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    goodG2BStatic = 1; 
    goodG2BSink(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fgets_preinc_42.c,CWE190,bad,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
static int badSource(int data)
{
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    return data;
}
void var()
{
    int data;
    data = 0;
    data = badSource(data);
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static int goodG2BSource(int data)
{
    data = 2;
    return data;
}
static void goodG2B()
{
    int data;
    data = 0;
    data = goodG2BSource(data);
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
}
static int goodB2GSource(int data)
{
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    return data;
}
static void goodB2G()
{
    int data;
    data = 0;
    data = goodB2GSource(data);
    if (data < INT_MAX)
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_rand_postinc_12.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(globalReturnsTrueOrFalse())
    {
        data = (char)RAND32();
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            data++;
            char result = data;
            printHexCharLine(result);
        }
    }
    else
    {
        if (data < CHAR_MAX)
        {
            data++;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    char data;
    data = ' ';
    if(globalReturnsTrueOrFalse())
    {
        data = (char)RAND32();
    }
    else
    {
        data = (char)RAND32();
    }
    if(globalReturnsTrueOrFalse())
    {
        if (data < CHAR_MAX)
        {
            data++;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
    else
    {
        if (data < CHAR_MAX)
        {
            data++;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B()
{
    char data;
    data = ' ';
    if(globalReturnsTrueOrFalse())
    {
        data = 2;
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            data++;
            char result = data;
            printHexCharLine(result);
        }
    }
    else
    {
        {
            data++;
            char result = data;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_add_16.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    while(1)
    {
        data = (unsigned int)RAND32();
        break;
    }
    while(1)
    {
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    unsigned int data;
    data = 0;
    while(1)
    {
        data = (unsigned int)RAND32();
        break;
    }
    while(1)
    {
        if (data < UINT_MAX)
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
        break;
    }
}
static void goodG2B()
{
    unsigned int data;
    data = 0;
    while(1)
    {
        data = 2;
        break;
    }
    while(1)
    {
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
        break;
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_max_add_41.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
static void badSink(int data)
{
    {
        int result = data + 1;
        printIntLine(result);
    }
}
void var()
{
    int data;
    data = 0;
    data = INT_MAX;
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(int data)
{
    {
        int result = data + 1;
        printIntLine(result);
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    goodG2BSink(data);
}
static void goodB2GSink(int data)
{
    if (data < INT_MAX)
    {
        int result = data + 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodB2G()
{
    int data;
    data = 0;
    data = INT_MAX;
    goodB2GSink(data);
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_postinc_67b.c,CWE190,good,"#include ""std_testcase.h""
typedef struct _CWE190_Integer_Overflow__int64_t_fscanf_postinc_67_structType
{
    int64_t structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct)
{
    int64_t data = myStruct.structFirst;
    {
        data++;
        int64_t result = data;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(var myStruct)
{
    int64_t data = myStruct.structFirst;
    {
        data++;
        int64_t result = data;
        printLongLongLine(result);
    }
}
void var(var myStruct)
{
    int64_t data = myStruct.structFirst;
    if (data < LLONG_MAX)
    {
        data++;
        int64_t result = data;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int_connect_socket_multiply_01.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    if(data > 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    if(data > 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
static void goodB2G()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    if(data > 0) 
    {
        if (data < (INT_MAX/2))
        {
            int result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_rand_postinc_54c.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__int_rand_postinc_17.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int i,j;
    int data;
    data = 0;
    for(i = 0; i < 1; i++)
    {
        data = RAND32();
    }
    for(j = 0; j < 1; j++)
    {
        {
            data++;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int i,k;
    int data;
    data = 0;
    for(i = 0; i < 1; i++)
    {
        data = RAND32();
    }
    for(k = 0; k < 1; k++)
    {
        if (data < INT_MAX)
        {
            data++;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B()
{
    int h,j;
    int data;
    data = 0;
    for(h = 0; h < 1; h++)
    {
        data = 2;
    }
    for(j = 0; j < 1; j++)
    {
        {
            data++;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_max_multiply_66a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int dataArray[]);
void var()
{
    int data;
    int dataArray[5];
    data = 0;
    data = INT_MAX;
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(int dataArray[]);
static void goodG2B()
{
    int data;
    int dataArray[5];
    data = 0;
    data = 2;
    dataArray[2] = data;
    var(dataArray);
}
void var(int dataArray[]);
static void goodB2G()
{
    int data;
    int dataArray[5];
    data = 0;
    data = INT_MAX;
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_fscanf_multiply_61b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
short var(short data)
{
    fscanf (stdin, ""%hd"", &data);
    return data;
}
#endif 
#ifndef OMITGOOD
short var(short data)
{
    data = 2;
    return data;
}
short var(short data)
{
    fscanf (stdin, ""%hd"", &data);
    return data;
}
#endif"
CWE190_Integer_Overflow__int64_t_rand_square_03.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#include <inttypes.h>
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(5==5)
    {
        data = (int64_t)RAND64();
    }
    if(5==5)
    {
        {
            int64_t result = data * data;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(5==5)
    {
        data = (int64_t)RAND64();
    }
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (imaxabs((intmax_t)data) <= sqrtl(LLONG_MAX))
        {
            int64_t result = data * data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(5==5)
    {
        data = (int64_t)RAND64();
    }
    if(5==5)
    {
        if (imaxabs((intmax_t)data) <= sqrtl(LLONG_MAX))
        {
            int64_t result = data * data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(5==5)
    {
        {
            int64_t result = data * data;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(5==5)
    {
        data = 2;
    }
    if(5==5)
    {
        {
            int64_t result = data * data;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_max_square_63b.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var(char * dataPtr)
{
    char data = *dataPtr;
    {
        char result = data * data;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * dataPtr)
{
    char data = *dataPtr;
    {
        char result = data * data;
        printHexCharLine(result);
    }
}
void var(char * dataPtr)
{
    char data = *dataPtr;
    if (abs((long)data) <= (long)sqrt((double)CHAR_MAX))
    {
        char result = data * data;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__char_max_multiply_68a.c,CWE190,good,"#include ""std_testcase.h""
char var;
char var;
char var;
#ifndef OMITBAD
void var();
void var()
{
    char data;
    data = ' ';
    data = CHAR_MAX;
    var = data;
    var();
}
#endif 
#ifndef OMITGOOD
void var();
void var();
static void goodG2B()
{
    char data;
    data = ' ';
    data = 2;
    var = data;
    var();
}
static void goodB2G()
{
    char data;
    data = ' ';
    data = CHAR_MAX;
    var = data;
    var();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_max_add_45.c,CWE190,good,"#include ""std_testcase.h""
static int64_t var;
static int64_t var;
static int64_t var;
#ifndef OMITBAD
static void badSink()
{
    int64_t data = var;
    {
        int64_t result = data + 1;
        printLongLongLine(result);
    }
}
void var()
{
    int64_t data;
    data = 0LL;
    data = LLONG_MAX;
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    int64_t data = var;
    {
        int64_t result = data + 1;
        printLongLongLine(result);
    }
}
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = 2;
    var = data;
    goodG2BSink();
}
static void goodB2GSink()
{
    int64_t data = var;
    if (data < LLONG_MAX)
    {
        int64_t result = data + 1;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    data = LLONG_MAX;
    var = data;
    goodB2GSink();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_fscanf_postinc_16.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    while(1)
    {
        fscanf (stdin, ""%c"", &data);
        break;
    }
    while(1)
    {
        {
            data++;
            char result = data;
            printHexCharLine(result);
        }
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    char data;
    data = ' ';
    while(1)
    {
        fscanf (stdin, ""%c"", &data);
        break;
    }
    while(1)
    {
        if (data < CHAR_MAX)
        {
            data++;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
        break;
    }
}
static void goodG2B()
{
    char data;
    data = ' ';
    while(1)
    {
        data = 2;
        break;
    }
    while(1)
    {
        {
            data++;
            char result = data;
            printHexCharLine(result);
        }
        break;
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_rand_add_65a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data);
void var()
{
    char data;
    void (*funcPtr) (char) = var;
    data = ' ';
    data = (char)RAND32();
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(char data);
static void goodG2B()
{
    char data;
    void (*funcPtr) (char) = var;
    data = ' ';
    data = 2;
    funcPtr(data);
}
void var(char data);
static void goodB2G()
{
    char data;
    void (*funcPtr) (char) = var;
    data = ' ';
    data = (char)RAND32();
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_rand_multiply_63a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short * dataPtr);
void var()
{
    short data;
    data = 0;
    data = (short)RAND32();
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(short * data);
static void goodG2B()
{
    short data;
    data = 0;
    data = 2;
    var(&data);
}
void var(short * data);
static void goodB2G()
{
    short data;
    data = 0;
    data = (short)RAND32();
    var(&data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fgets_preinc_31.c,CWE190,bad,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodB2G()
{
    int data;
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    {
        int dataCopy = data;
        int data = dataCopy;
        if (data < INT_MAX)
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_listen_socket_square_52c.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#include <math.h>
#ifndef OMITBAD
void var(int data)
{
    {
        int result = data * data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    {
        int result = data * data;
        printIntLine(result);
    }
}
void var(int data)
{
    if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
    {
        int result = data * data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int_rand_preinc_18.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    goto source;
source:
    data = RAND32();
    goto sink;
sink:
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int data;
    data = 0;
    goto source;
source:
    data = RAND32();
    goto sink;
sink:
    if (data < INT_MAX)
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    goto source;
source:
    data = 2;
    goto sink;
sink:
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_connect_socket_postinc_67a.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
typedef struct _CWE190_Integer_Overflow__int_connect_socket_postinc_67_structType
{
    int structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct);
void var()
{
    int data;
    var myStruct;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myStruct.structFirst = data;
    var(myStruct);
}
#endif 
#ifndef OMITGOOD
void var(var myStruct);
static void goodG2B()
{
    int data;
    var myStruct;
    data = 0;
    data = 2;
    myStruct.structFirst = data;
    var(myStruct);
}
void var(var myStruct);
static void goodB2G()
{
    int data;
    var myStruct;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myStruct.structFirst = data;
    var(myStruct);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_square_68b.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
extern unsigned int var;
extern unsigned int var;
extern unsigned int var;
#ifndef OMITBAD
void var()
{
    unsigned int data = var;
    {
        unsigned int result = data * data;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    unsigned int data = var;
    {
        unsigned int result = data * data;
        printUnsignedLine(result);
    }
}
void var()
{
    unsigned int data = var;
    if (abs((long)data) < (long)sqrt((double)UINT_MAX))
    {
        unsigned int result = data * data;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__short_fscanf_postinc_54c.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data);
void var(short data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(short data);
void var(short data)
{
    var(data);
}
void var(short data);
void var(short data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__unsigned_int_max_multiply_13.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = UINT_MAX;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = UINT_MAX;
    }
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data > 0) 
        {
            if (data < (UINT_MAX/2))
            {
                unsigned int result = data * 2;
                printUnsignedLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = UINT_MAX;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            if (data < (UINT_MAX/2))
            {
                unsigned int result = data * 2;
                printUnsignedLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = 2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data > 0) 
        {
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_connect_socket_preinc_68a.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
int var;
int var;
int var;
#ifndef OMITBAD
void var();
void var()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var = data;
    var();
}
#endif 
#ifndef OMITGOOD
void var();
void var();
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    var = data;
    var();
}
static void goodB2G()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var = data;
    var();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_max_square_64b.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#include <inttypes.h>
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    int64_t * dataPtr = (int64_t *)dataVoidPtr;
    int64_t data = (*dataPtr);
    {
        int64_t result = data * data;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    int64_t * dataPtr = (int64_t *)dataVoidPtr;
    int64_t data = (*dataPtr);
    {
        int64_t result = data * data;
        printLongLongLine(result);
    }
}
void var(void * dataVoidPtr)
{
    int64_t * dataPtr = (int64_t *)dataVoidPtr;
    int64_t data = (*dataPtr);
    if (imaxabs((intmax_t)data) <= sqrtl(LLONG_MAX))
    {
        int64_t result = data * data;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_square_52b.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__unsigned_int_max_add_22b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
extern int var;
void var(unsigned int data)
{
    if(var)
    {
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
extern int var;
extern int var;
extern int var;
void var(unsigned int data)
{
    if(var)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < UINT_MAX)
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var(unsigned int data)
{
    if(var)
    {
        if (data < UINT_MAX)
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var(unsigned int data)
{
    if(var)
    {
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
    }
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_multiply_22b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
extern int var;
void var(unsigned int data)
{
    if(var)
    {
        if(data > 0) 
        {
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
extern int var;
extern int var;
extern int var;
void var(unsigned int data)
{
    if(var)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data > 0) 
        {
            if (data < (UINT_MAX/2))
            {
                unsigned int result = data * 2;
                printUnsignedLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
void var(unsigned int data)
{
    if(var)
    {
        if(data > 0) 
        {
            if (data < (UINT_MAX/2))
            {
                unsigned int result = data * 2;
                printUnsignedLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
void var(unsigned int data)
{
    if(var)
    {
        if(data > 0) 
        {
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
    }
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_preinc_13.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = (unsigned int)RAND32();
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = (unsigned int)RAND32();
    }
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < UINT_MAX)
        {
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = (unsigned int)RAND32();
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if (data < UINT_MAX)
        {
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = 2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_rand_square_08.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        data = RAND32();
    }
    if(staticReturnsTrue())
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        data = RAND32();
    }
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        data = RAND32();
    }
    if(staticReturnsTrue())
    {
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(staticReturnsTrue())
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        data = 2;
    }
    if(staticReturnsTrue())
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_rand_preinc_66a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char dataArray[]);
void var()
{
    char data;
    char dataArray[5];
    data = ' ';
    data = (char)RAND32();
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(char dataArray[]);
static void goodG2B()
{
    char data;
    char dataArray[5];
    data = ' ';
    data = 2;
    dataArray[2] = data;
    var(dataArray);
}
void var(char dataArray[]);
static void goodB2G()
{
    char data;
    char dataArray[5];
    data = ' ';
    data = (char)RAND32();
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_fscanf_preinc_01.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    {
        ++data;
        char result = data;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char data;
    data = ' ';
    data = 2;
    {
        ++data;
        char result = data;
        printHexCharLine(result);
    }
}
static void goodB2G()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    if (data < CHAR_MAX)
    {
        ++data;
        char result = data;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_connect_socket_preinc_63b.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int * dataPtr)
{
    int data = *dataPtr;
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int * dataPtr)
{
    int data = *dataPtr;
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
}
void var(int * dataPtr)
{
    int data = *dataPtr;
    if (data < INT_MAX)
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int64_t_rand_preinc_54a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data);
void var()
{
    int64_t data;
    data = 0LL;
    data = (int64_t)RAND64();
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t data);
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = 2;
    var(data);
}
void var(int64_t data);
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    data = (int64_t)RAND64();
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_max_preinc_21.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
static int badStatic = 0;
static void badSink(int data)
{
    if(badStatic)
    {
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    int data;
    data = 0;
    data = INT_MAX;
    badStatic = 1; 
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static int goodB2G1Static = 0;
static int goodB2G2Static = 0;
static int goodG2BStatic = 0;
static void goodB2G1Sink(int data)
{
    if(goodB2G1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < INT_MAX)
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G1()
{
    int data;
    data = 0;
    data = INT_MAX;
    goodB2G1Static = 0; 
    goodB2G1Sink(data);
}
static void goodB2G2Sink(int data)
{
    if(goodB2G2Static)
    {
        if (data < INT_MAX)
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    data = INT_MAX;
    goodB2G2Static = 1; 
    goodB2G2Sink(data);
}
static void goodG2BSink(int data)
{
    if(goodG2BStatic)
    {
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    goodG2BStatic = 1; 
    goodG2BSink(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_rand_postinc_09.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_TRUE)
    {
        data = (int64_t)RAND64();
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_TRUE)
    {
        data = (int64_t)RAND64();
    }
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < LLONG_MAX)
        {
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_TRUE)
    {
        data = (int64_t)RAND64();
    }
    if(GLOBAL_CONST_TRUE)
    {
        if (data < LLONG_MAX)
        {
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_TRUE)
    {
        data = 2;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_fscanf_preinc_53a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data);
void var()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char data);
static void goodG2B()
{
    char data;
    data = ' ';
    data = 2;
    var(data);
}
void var(char data);
static void goodB2G()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_max_square_53c.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__unsigned_int_max_add_67a.c,CWE190,good,"#include ""std_testcase.h""
typedef struct _CWE190_Integer_Overflow__unsigned_int_max_add_67_structType
{
    unsigned int structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct);
void var()
{
    unsigned int data;
    var myStruct;
    data = 0;
    data = UINT_MAX;
    myStruct.structFirst = data;
    var(myStruct);
}
#endif 
#ifndef OMITGOOD
void var(var myStruct);
static void goodG2B()
{
    unsigned int data;
    var myStruct;
    data = 0;
    data = 2;
    myStruct.structFirst = data;
    var(myStruct);
}
void var(var myStruct);
static void goodB2G()
{
    unsigned int data;
    var myStruct;
    data = 0;
    data = UINT_MAX;
    myStruct.structFirst = data;
    var(myStruct);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_rand_square_14.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#include <inttypes.h>
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(globalFive==5)
    {
        data = (int64_t)RAND64();
    }
    if(globalFive==5)
    {
        {
            int64_t result = data * data;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(globalFive==5)
    {
        data = (int64_t)RAND64();
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (imaxabs((intmax_t)data) <= sqrtl(LLONG_MAX))
        {
            int64_t result = data * data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(globalFive==5)
    {
        data = (int64_t)RAND64();
    }
    if(globalFive==5)
    {
        if (imaxabs((intmax_t)data) <= sqrtl(LLONG_MAX))
        {
            int64_t result = data * data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(globalFive==5)
    {
        {
            int64_t result = data * data;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(globalFive==5)
    {
        data = 2;
    }
    if(globalFive==5)
    {
        {
            int64_t result = data * data;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_max_preinc_63a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short * dataPtr);
void var()
{
    short data;
    data = 0;
    data = SHRT_MAX;
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(short * data);
static void goodG2B()
{
    short data;
    data = 0;
    data = 2;
    var(&data);
}
void var(short * data);
static void goodB2G()
{
    short data;
    data = 0;
    data = SHRT_MAX;
    var(&data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_rand_square_45.c,CWE190,bad,"#include ""std_testcase.h""
#include <math.h>
static char var;
static char var;
static char var;
#ifndef OMITBAD
static void badSink()
{
    char data = var;
    {
        char result = data * data;
        printHexCharLine(result);
    }
}
void var()
{
    char data;
    data = ' ';
    data = (char)RAND32();
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    char data = var;
    {
        char result = data * data;
        printHexCharLine(result);
    }
}
static void goodG2B()
{
    char data;
    data = ' ';
    data = 2;
    var = data;
    goodG2BSink();
}
static void goodB2GSink()
{
    char data = var;
    if (abs((long)data) <= (long)sqrt((double)CHAR_MAX))
    {
        char result = data * data;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodB2G()
{
    char data;
    data = ' ';
    data = (char)RAND32();
    var = data;
    goodB2GSink();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_max_preinc_17.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int i,j;
    char data;
    data = ' ';
    for(i = 0; i < 1; i++)
    {
        data = CHAR_MAX;
    }
    for(j = 0; j < 1; j++)
    {
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int i,k;
    char data;
    data = ' ';
    for(i = 0; i < 1; i++)
    {
        data = CHAR_MAX;
    }
    for(k = 0; k < 1; k++)
    {
        if (data < CHAR_MAX)
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B()
{
    int h,j;
    char data;
    data = ' ';
    for(h = 0; h < 1; h++)
    {
        data = 2;
    }
    for(j = 0; j < 1; j++)
    {
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_fscanf_square_63a.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var(unsigned int * dataPtr);
void var()
{
    unsigned int data;
    data = 0;
    fscanf (stdin, ""%u"", &data);
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(unsigned int * data);
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = 2;
    var(&data);
}
void var(unsigned int * data);
static void goodB2G()
{
    unsigned int data;
    data = 0;
    fscanf (stdin, ""%u"", &data);
    var(&data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_max_postinc_45.c,CWE190,good,"#include ""std_testcase.h""
static int var;
static int var;
static int var;
#ifndef OMITBAD
static void badSink()
{
    int data = var;
    {
        data++;
        int result = data;
        printIntLine(result);
    }
}
void var()
{
    int data;
    data = 0;
    data = INT_MAX;
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    int data = var;
    {
        data++;
        int result = data;
        printIntLine(result);
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    var = data;
    goodG2BSink();
}
static void goodB2GSink()
{
    int data = var;
    if (data < INT_MAX)
    {
        data++;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodB2G()
{
    int data;
    data = 0;
    data = INT_MAX;
    var = data;
    goodB2GSink();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_max_square_63a.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var(char * dataPtr);
void var()
{
    char data;
    data = ' ';
    data = CHAR_MAX;
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
static void goodG2B()
{
    char data;
    data = ' ';
    data = 2;
    var(&data);
}
void var(char * data);
static void goodB2G()
{
    char data;
    data = ' ';
    data = CHAR_MAX;
    var(&data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_multiply_53a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data);
void var()
{
    unsigned int data;
    data = 0;
    data = (unsigned int)RAND32();
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data);
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = 2;
    var(data);
}
void var(unsigned int data);
static void goodB2G()
{
    unsigned int data;
    data = 0;
    data = (unsigned int)RAND32();
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fgets_square_34.c,CWE190,bad,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#include <math.h>
typedef union
{
    int unionFirst;
    int unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    int data;
    var myUnion;
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int data;
    var myUnion;
    data = 0;
    data = 2;
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
static void goodB2G()
{
    int data;
    var myUnion;
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_fscanf_square_14.c,CWE190,bad,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(globalFive==5)
    {
        fscanf (stdin, ""%c"", &data);
    }
    if(globalFive==5)
    {
        {
            char result = data * data;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(globalFive==5)
    {
        fscanf (stdin, ""%c"", &data);
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (abs((long)data) <= (long)sqrt((double)CHAR_MAX))
        {
            char result = data * data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(globalFive==5)
    {
        fscanf (stdin, ""%c"", &data);
    }
    if(globalFive==5)
    {
        if (abs((long)data) <= (long)sqrt((double)CHAR_MAX))
        {
            char result = data * data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(globalFive==5)
    {
        {
            char result = data * data;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(globalFive==5)
    {
        data = 2;
    }
    if(globalFive==5)
    {
        {
            char result = data * data;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_rand_postinc_34.c,CWE190,good,"#include ""std_testcase.h""
typedef union
{
    int unionFirst;
    int unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    int data;
    var myUnion;
    data = 0;
    data = RAND32();
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            data++;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int data;
    var myUnion;
    data = 0;
    data = 2;
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            data++;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodB2G()
{
    int data;
    var myUnion;
    data = 0;
    data = RAND32();
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        if (data < INT_MAX)
        {
            data++;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_rand_add_18.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    goto source;
source:
    data = (int64_t)RAND64();
    goto sink;
sink:
    {
        int64_t result = data + 1;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    goto source;
source:
    data = (int64_t)RAND64();
    goto sink;
sink:
    if (data < LLONG_MAX)
    {
        int64_t result = data + 1;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    goto source;
source:
    data = 2;
    goto sink;
sink:
    {
        int64_t result = data + 1;
        printLongLongLine(result);
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_preinc_22b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
extern int var;
void var(int64_t data)
{
    if(var)
    {
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
extern int var;
extern int var;
extern int var;
void var(int64_t data)
{
    if(var)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < LLONG_MAX)
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var(int64_t data)
{
    if(var)
    {
        if (data < LLONG_MAX)
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var(int64_t data)
{
    if(var)
    {
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
#endif"
CWE190_Integer_Overflow__char_fscanf_postinc_54d.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data);
void var(char data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char data);
void var(char data)
{
    var(data);
}
void var(char data);
void var(char data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__int_connect_socket_multiply_63b.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int * dataPtr)
{
    int data = *dataPtr;
    if(data > 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int * dataPtr)
{
    int data = *dataPtr;
    if(data > 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
void var(int * dataPtr)
{
    int data = *dataPtr;
    if(data > 0) 
    {
        if (data < (INT_MAX/2))
        {
            int result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif"
CWE190_Integer_Overflow__int_listen_socket_square_65b.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#include <math.h>
#ifndef OMITBAD
void var(int data)
{
    {
        int result = data * data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    {
        int result = data * data;
        printIntLine(result);
    }
}
void var(int data)
{
    if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
    {
        int result = data * data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int_fscanf_add_65b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data)
{
    {
        int result = data + 1;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    {
        int result = data + 1;
        printIntLine(result);
    }
}
void var(int data)
{
    if (data < INT_MAX)
    {
        int result = data + 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int64_t_max_preinc_53c.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__short_max_preinc_63b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short * dataPtr)
{
    short data = *dataPtr;
    {
        ++data;
        short result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(short * dataPtr)
{
    short data = *dataPtr;
    {
        ++data;
        short result = data;
        printIntLine(result);
    }
}
void var(short * dataPtr)
{
    short data = *dataPtr;
    if (data < SHRT_MAX)
    {
        ++data;
        short result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int_listen_socket_preinc_64a.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(void * dataVoidPtr);
void var()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr);
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    var(&data);
}
void var(void * dataVoidPtr);
static void goodB2G()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var(&data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_connect_socket_postinc_65a.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data);
void var()
{
    int data;
    void (*funcPtr) (int) = var;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
static void goodG2B()
{
    int data;
    void (*funcPtr) (int) = var;
    data = 0;
    data = 2;
    funcPtr(data);
}
void var(int data);
static void goodB2G()
{
    int data;
    void (*funcPtr) (int) = var;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_fscanf_square_01.c,CWE190,bad,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    fscanf (stdin, ""%u"", &data);
    {
        unsigned int result = data * data;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = 2;
    {
        unsigned int result = data * data;
        printUnsignedLine(result);
    }
}
static void goodB2G()
{
    unsigned int data;
    data = 0;
    fscanf (stdin, ""%u"", &data);
    if (abs((long)data) < (long)sqrt((double)UINT_MAX))
    {
        unsigned int result = data * data;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_add_34.c,CWE190,bad,"#include ""std_testcase.h""
typedef union
{
    unsigned int unionFirst;
    unsigned int unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    unsigned int data;
    var myUnion;
    data = 0;
    data = (unsigned int)RAND32();
    myUnion.unionFirst = data;
    {
        unsigned int data = myUnion.unionSecond;
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    unsigned int data;
    var myUnion;
    data = 0;
    data = 2;
    myUnion.unionFirst = data;
    {
        unsigned int data = myUnion.unionSecond;
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
    }
}
static void goodB2G()
{
    unsigned int data;
    var myUnion;
    data = 0;
    data = (unsigned int)RAND32();
    myUnion.unionFirst = data;
    {
        unsigned int data = myUnion.unionSecond;
        if (data < UINT_MAX)
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_max_preinc_54a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data);
void var()
{
    char data;
    data = ' ';
    data = CHAR_MAX;
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char data);
static void goodG2B()
{
    char data;
    data = ' ';
    data = 2;
    var(data);
}
void var(char data);
static void goodB2G()
{
    char data;
    data = ' ';
    data = CHAR_MAX;
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_max_postinc_07.c,CWE190,good,"#include ""std_testcase.h""
static int staticFive = 5;
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(staticFive==5)
    {
        data = INT_MAX;
    }
    if(staticFive==5)
    {
        {
            data++;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(staticFive==5)
    {
        data = INT_MAX;
    }
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < INT_MAX)
        {
            data++;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(staticFive==5)
    {
        data = INT_MAX;
    }
    if(staticFive==5)
    {
        if (data < INT_MAX)
        {
            data++;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(staticFive==5)
    {
        {
            data++;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(staticFive==5)
    {
        data = 2;
    }
    if(staticFive==5)
    {
        {
            data++;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_preinc_52c.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data)
{
    {
        ++data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data)
{
    {
        ++data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
void var(unsigned int data)
{
    if (data < UINT_MAX)
    {
        ++data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__short_max_square_65a.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var(short data);
void var()
{
    short data;
    void (*funcPtr) (short) = var;
    data = 0;
    data = SHRT_MAX;
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(short data);
static void goodG2B()
{
    short data;
    void (*funcPtr) (short) = var;
    data = 0;
    data = 2;
    funcPtr(data);
}
void var(short data);
static void goodB2G()
{
    short data;
    void (*funcPtr) (short) = var;
    data = 0;
    data = SHRT_MAX;
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_rand_postinc_17.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int i,j;
    int64_t data;
    data = 0LL;
    for(i = 0; i < 1; i++)
    {
        data = (int64_t)RAND64();
    }
    for(j = 0; j < 1; j++)
    {
        {
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int i,k;
    int64_t data;
    data = 0LL;
    for(i = 0; i < 1; i++)
    {
        data = (int64_t)RAND64();
    }
    for(k = 0; k < 1; k++)
    {
        if (data < LLONG_MAX)
        {
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B()
{
    int h,j;
    int64_t data;
    data = 0LL;
    for(h = 0; h < 1; h++)
    {
        data = 2;
    }
    for(j = 0; j < 1; j++)
    {
        {
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fgets_multiply_03.c,CWE190,bad,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(5==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(5==5)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(5==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data > 0) 
        {
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(5==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(5==5)
    {
        if(data > 0) 
        {
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(5==5)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(5==5)
    {
        data = 2;
    }
    if(5==5)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_max_square_02.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(1)
    {
        data = INT_MAX;
    }
    if(1)
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(1)
    {
        data = INT_MAX;
    }
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(1)
    {
        data = INT_MAX;
    }
    if(1)
    {
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(1)
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(1)
    {
        data = 2;
    }
    if(1)
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_multiply_41.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
static void badSink(unsigned int data)
{
    if(data > 0) 
    {
        unsigned int result = data * 2;
        printUnsignedLine(result);
    }
}
void var()
{
    unsigned int data;
    data = 0;
    data = (unsigned int)RAND32();
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(unsigned int data)
{
    if(data > 0) 
    {
        unsigned int result = data * 2;
        printUnsignedLine(result);
    }
}
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = 2;
    goodG2BSink(data);
}
static void goodB2GSink(unsigned int data)
{
    if(data > 0) 
    {
        if (data < (UINT_MAX/2))
        {
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G()
{
    unsigned int data;
    data = 0;
    data = (unsigned int)RAND32();
    goodB2GSink(data);
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_square_54c.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__int64_t_rand_postinc_68b.c,CWE190,good,"#include ""std_testcase.h""
extern int64_t var;
extern int64_t var;
extern int64_t var;
#ifndef OMITBAD
void var()
{
    int64_t data = var;
    {
        data++;
        int64_t result = data;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    int64_t data = var;
    {
        data++;
        int64_t result = data;
        printLongLongLine(result);
    }
}
void var()
{
    int64_t data = var;
    if (data < LLONG_MAX)
    {
        data++;
        int64_t result = data;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_square_52c.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#include <inttypes.h>
#ifndef OMITBAD
void var(int64_t data)
{
    {
        int64_t result = data * data;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int64_t data)
{
    {
        int64_t result = data * data;
        printLongLongLine(result);
    }
}
void var(int64_t data)
{
    if (imaxabs((intmax_t)data) <= sqrtl(LLONG_MAX))
    {
        int64_t result = data * data;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int_listen_socket_add_14.c,CWE190,bad,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFive==5)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFive==5)
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(globalFive==5)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        data = 2;
    }
    if(globalFive==5)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_connect_socket_square_09.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#include <math.h>
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        data = 2;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_add_09.c,CWE190,bad,"#include <inttypes.h>
#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_TRUE)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            int64_t result = data + 1;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_TRUE)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < LLONG_MAX)
        {
            int64_t result = data + 1;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_TRUE)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(GLOBAL_CONST_TRUE)
    {
        if (data < LLONG_MAX)
        {
            int64_t result = data + 1;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            int64_t result = data + 1;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_TRUE)
    {
        data = 2;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            int64_t result = data + 1;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_rand_preinc_65b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data)
{
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
}
void var(int data)
{
    if (data < INT_MAX)
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int_connect_socket_postinc_67b.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
typedef struct _CWE190_Integer_Overflow__int_connect_socket_postinc_67_structType
{
    int structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct)
{
    int data = myStruct.structFirst;
    {
        data++;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(var myStruct)
{
    int data = myStruct.structFirst;
    {
        data++;
        int result = data;
        printIntLine(result);
    }
}
void var(var myStruct)
{
    int data = myStruct.structFirst;
    if (data < INT_MAX)
    {
        data++;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int64_t_max_multiply_54d.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__unsigned_int_fscanf_add_53d.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data)
{
    {
        unsigned int result = data + 1;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data)
{
    {
        unsigned int result = data + 1;
        printUnsignedLine(result);
    }
}
void var(unsigned int data)
{
    if (data < UINT_MAX)
    {
        unsigned int result = data + 1;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__char_rand_multiply_41.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
static void badSink(char data)
{
    if(data > 0) 
    {
        char result = data * 2;
        printHexCharLine(result);
    }
}
void var()
{
    char data;
    data = ' ';
    data = (char)RAND32();
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(char data)
{
    if(data > 0) 
    {
        char result = data * 2;
        printHexCharLine(result);
    }
}
static void goodG2B()
{
    char data;
    data = ' ';
    data = 2;
    goodG2BSink(data);
}
static void goodB2GSink(char data)
{
    if(data > 0) 
    {
        if (data < (CHAR_MAX/2))
        {
            char result = data * 2;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G()
{
    char data;
    data = ' ';
    data = (char)RAND32();
    goodB2GSink(data);
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_postinc_08.c,CWE190,good,"#include <inttypes.h>
#include ""std_testcase.h""
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(staticReturnsTrue())
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(staticReturnsTrue())
    {
        {
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(staticReturnsTrue())
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < LLONG_MAX)
        {
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(staticReturnsTrue())
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(staticReturnsTrue())
    {
        if (data < LLONG_MAX)
        {
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(staticReturnsTrue())
    {
        {
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(staticReturnsTrue())
    {
        data = 2;
    }
    if(staticReturnsTrue())
    {
        {
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_max_square_52c.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#include <inttypes.h>
#ifndef OMITBAD
void var(int64_t data)
{
    {
        int64_t result = data * data;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int64_t data)
{
    {
        int64_t result = data * data;
        printLongLongLine(result);
    }
}
void var(int64_t data)
{
    if (imaxabs((intmax_t)data) <= sqrtl(LLONG_MAX))
    {
        int64_t result = data * data;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_add_68b.c,CWE190,good,"#include ""std_testcase.h""
extern unsigned int var;
extern unsigned int var;
extern unsigned int var;
#ifndef OMITBAD
void var()
{
    unsigned int data = var;
    {
        unsigned int result = data + 1;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    unsigned int data = var;
    {
        unsigned int result = data + 1;
        printUnsignedLine(result);
    }
}
void var()
{
    unsigned int data = var;
    if (data < UINT_MAX)
    {
        unsigned int result = data + 1;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int_connect_socket_postinc_52c.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data)
{
    {
        data++;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    {
        data++;
        int result = data;
        printIntLine(result);
    }
}
void var(int data)
{
    if (data < INT_MAX)
    {
        data++;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__unsigned_int_max_preinc_11.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(globalReturnsTrue())
    {
        data = UINT_MAX;
    }
    if(globalReturnsTrue())
    {
        {
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(globalReturnsTrue())
    {
        data = UINT_MAX;
    }
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < UINT_MAX)
        {
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(globalReturnsTrue())
    {
        data = UINT_MAX;
    }
    if(globalReturnsTrue())
    {
        if (data < UINT_MAX)
        {
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrue())
    {
        {
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(globalReturnsTrue())
    {
        data = 2;
    }
    if(globalReturnsTrue())
    {
        {
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_max_multiply_17.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int i,j;
    int data;
    data = 0;
    for(i = 0; i < 1; i++)
    {
        data = INT_MAX;
    }
    for(j = 0; j < 1; j++)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int i,k;
    int data;
    data = 0;
    for(i = 0; i < 1; i++)
    {
        data = INT_MAX;
    }
    for(k = 0; k < 1; k++)
    {
        if(data > 0) 
        {
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodG2B()
{
    int h,j;
    int data;
    data = 0;
    for(h = 0; h < 1; h++)
    {
        data = 2;
    }
    for(j = 0; j < 1; j++)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fscanf_multiply_53a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data);
void var()
{
    int data;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    var(data);
}
void var(int data);
static void goodB2G()
{
    int data;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fgets_preinc_66b.c,CWE190,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int dataArray[])
{
    int data = dataArray[2];
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int dataArray[])
{
    int data = dataArray[2];
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
}
void var(int dataArray[])
{
    int data = dataArray[2];
    if (data < INT_MAX)
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int64_t_max_square_54c.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__int_fscanf_multiply_63a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * dataPtr);
void var()
{
    int data;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(int * data);
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    var(&data);
}
void var(int * data);
static void goodB2G()
{
    int data;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    var(&data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_listen_socket_multiply_02.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(1)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data > 0) 
        {
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(1)
    {
        if(data > 0) 
        {
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(1)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(1)
    {
        data = 2;
    }
    if(1)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_preinc_54e.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data)
{
    {
        ++data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data)
{
    {
        ++data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
void var(unsigned int data)
{
    if (data < UINT_MAX)
    {
        ++data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__short_rand_postinc_41.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
static void badSink(short data)
{
    {
        data++;
        short result = data;
        printIntLine(result);
    }
}
void var()
{
    short data;
    data = 0;
    data = (short)RAND32();
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(short data)
{
    {
        data++;
        short result = data;
        printIntLine(result);
    }
}
static void goodG2B()
{
    short data;
    data = 0;
    data = 2;
    goodG2BSink(data);
}
static void goodB2GSink(short data)
{
    if (data < SHRT_MAX)
    {
        data++;
        short result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodB2G()
{
    short data;
    data = 0;
    data = (short)RAND32();
    goodB2GSink(data);
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_rand_multiply_51b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data)
{
    if(data > 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    if(data > 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
void var(int data)
{
    if(data > 0) 
    {
        if (data < (INT_MAX/2))
        {
            int result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif"
CWE190_Integer_Overflow__int_fscanf_preinc_07.c,CWE190,bad,"#include ""std_testcase.h""
static int staticFive = 5;
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(staticFive==5)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(staticFive==5)
    {
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(staticFive==5)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < INT_MAX)
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(staticFive==5)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(staticFive==5)
    {
        if (data < INT_MAX)
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(staticFive==5)
    {
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(staticFive==5)
    {
        data = 2;
    }
    if(staticFive==5)
    {
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_fscanf_preinc_66b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char dataArray[])
{
    char data = dataArray[2];
    {
        ++data;
        char result = data;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(char dataArray[])
{
    char data = dataArray[2];
    {
        ++data;
        char result = data;
        printHexCharLine(result);
    }
}
void var(char dataArray[])
{
    char data = dataArray[2];
    if (data < CHAR_MAX)
    {
        ++data;
        char result = data;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int64_t_rand_preinc_54d.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_multiply_66a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t dataArray[]);
void var()
{
    int64_t data;
    int64_t dataArray[5];
    data = 0LL;
    fscanf (stdin, ""%lld"", &data);
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(int64_t dataArray[]);
static void goodG2B()
{
    int64_t data;
    int64_t dataArray[5];
    data = 0LL;
    data = 2;
    dataArray[2] = data;
    var(dataArray);
}
void var(int64_t dataArray[]);
static void goodB2G()
{
    int64_t data;
    int64_t dataArray[5];
    data = 0LL;
    fscanf (stdin, ""%lld"", &data);
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_listen_socket_multiply_54b.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__short_max_preinc_16.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    while(1)
    {
        data = SHRT_MAX;
        break;
    }
    while(1)
    {
        {
            ++data;
            short result = data;
            printIntLine(result);
        }
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    short data;
    data = 0;
    while(1)
    {
        data = SHRT_MAX;
        break;
    }
    while(1)
    {
        if (data < SHRT_MAX)
        {
            ++data;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
        break;
    }
}
static void goodG2B()
{
    short data;
    data = 0;
    while(1)
    {
        data = 2;
        break;
    }
    while(1)
    {
        {
            ++data;
            short result = data;
            printIntLine(result);
        }
        break;
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_32.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    unsigned int *dataPtr1 = &data;
    unsigned int *dataPtr2 = &data;
    data = 0;
    {
        unsigned int data = *dataPtr1;
        fscanf (stdin, ""%u"", &data);
        *dataPtr1 = data;
    }
    {
        unsigned int data = *dataPtr2;
        {
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    unsigned int data;
    unsigned int *dataPtr1 = &data;
    unsigned int *dataPtr2 = &data;
    data = 0;
    {
        unsigned int data = *dataPtr1;
        data = 2;
        *dataPtr1 = data;
    }
    {
        unsigned int data = *dataPtr2;
        {
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
static void goodB2G()
{
    unsigned int data;
    unsigned int *dataPtr1 = &data;
    unsigned int *dataPtr2 = &data;
    data = 0;
    {
        unsigned int data = *dataPtr1;
        fscanf (stdin, ""%u"", &data);
        *dataPtr1 = data;
    }
    {
        unsigned int data = *dataPtr2;
        if (data < UINT_MAX)
        {
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_multiply_51a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data);
void var()
{
    unsigned int data;
    data = 0;
    data = (unsigned int)RAND32();
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data);
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = 2;
    var(data);
}
void var(unsigned int data);
static void goodB2G()
{
    unsigned int data;
    data = 0;
    data = (unsigned int)RAND32();
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_connect_socket_add_14.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFive==5)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFive==5)
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(globalFive==5)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        data = 2;
    }
    if(globalFive==5)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_rand_add_64b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    int * dataPtr = (int *)dataVoidPtr;
    int data = (*dataPtr);
    {
        int result = data + 1;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    int * dataPtr = (int *)dataVoidPtr;
    int data = (*dataPtr);
    {
        int result = data + 1;
        printIntLine(result);
    }
}
void var(void * dataVoidPtr)
{
    int * dataPtr = (int *)dataVoidPtr;
    int data = (*dataPtr);
    if (data < INT_MAX)
    {
        int result = data + 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int_fscanf_postinc_68b.c,CWE190,good,"#include ""std_testcase.h""
extern int var;
extern int var;
extern int var;
#ifndef OMITBAD
void var()
{
    int data = var;
    {
        data++;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    int data = var;
    {
        data++;
        int result = data;
        printIntLine(result);
    }
}
void var()
{
    int data = var;
    if (data < INT_MAX)
    {
        data++;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int_connect_socket_preinc_66b.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int dataArray[])
{
    int data = dataArray[2];
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int dataArray[])
{
    int data = dataArray[2];
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
}
void var(int dataArray[])
{
    int data = dataArray[2];
    if (data < INT_MAX)
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int_fgets_postinc_52b.c,CWE190,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__int_fscanf_add_45.c,CWE190,bad,"#include ""std_testcase.h""
static int var;
static int var;
static int var;
#ifndef OMITBAD
static void badSink()
{
    int data = var;
    {
        int result = data + 1;
        printIntLine(result);
    }
}
void var()
{
    int data;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    int data = var;
    {
        int result = data + 1;
        printIntLine(result);
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    var = data;
    goodG2BSink();
}
static void goodB2GSink()
{
    int data = var;
    if (data < INT_MAX)
    {
        int result = data + 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodB2G()
{
    int data;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    var = data;
    goodB2GSink();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_max_square_14.c,CWE190,bad,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(globalFive==5)
    {
        data = CHAR_MAX;
    }
    if(globalFive==5)
    {
        {
            char result = data * data;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(globalFive==5)
    {
        data = CHAR_MAX;
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (abs((long)data) <= (long)sqrt((double)CHAR_MAX))
        {
            char result = data * data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(globalFive==5)
    {
        data = CHAR_MAX;
    }
    if(globalFive==5)
    {
        if (abs((long)data) <= (long)sqrt((double)CHAR_MAX))
        {
            char result = data * data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(globalFive==5)
    {
        {
            char result = data * data;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(globalFive==5)
    {
        data = 2;
    }
    if(globalFive==5)
    {
        {
            char result = data * data;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_max_add_44.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
static void badSink(int data)
{
    {
        int result = data + 1;
        printIntLine(result);
    }
}
void var()
{
    int data;
    void (*funcPtr) (int) = badSink;
    data = 0;
    data = INT_MAX;
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(int data)
{
    {
        int result = data + 1;
        printIntLine(result);
    }
}
static void goodG2B()
{
    int data;
    void (*funcPtr) (int) = goodG2BSink;
    data = 0;
    data = 2;
    funcPtr(data);
}
static void goodB2GSink(int data)
{
    if (data < INT_MAX)
    {
        int result = data + 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodB2G()
{
    int data;
    void (*funcPtr) (int) = goodB2GSink;
    data = 0;
    data = INT_MAX;
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_preinc_04.c,CWE190,good,"#include ""std_testcase.h""
static const int STATIC_CONST_TRUE = 1; 
static const int STATIC_CONST_FALSE = 0; 
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        data = (unsigned int)RAND32();
    }
    if(STATIC_CONST_TRUE)
    {
        {
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        data = (unsigned int)RAND32();
    }
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < UINT_MAX)
        {
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        data = (unsigned int)RAND32();
    }
    if(STATIC_CONST_TRUE)
    {
        if (data < UINT_MAX)
        {
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(STATIC_CONST_TRUE)
    {
        {
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        data = 2;
    }
    if(STATIC_CONST_TRUE)
    {
        {
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_multiply_67b.c,CWE190,good,"#include ""std_testcase.h""
typedef struct _CWE190_Integer_Overflow__unsigned_int_rand_multiply_67_structType
{
    unsigned int structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct)
{
    unsigned int data = myStruct.structFirst;
    if(data > 0) 
    {
        unsigned int result = data * 2;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(var myStruct)
{
    unsigned int data = myStruct.structFirst;
    if(data > 0) 
    {
        unsigned int result = data * 2;
        printUnsignedLine(result);
    }
}
void var(var myStruct)
{
    unsigned int data = myStruct.structFirst;
    if(data > 0) 
    {
        if (data < (UINT_MAX/2))
        {
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif"
CWE190_Integer_Overflow__short_fscanf_multiply_53a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data);
void var()
{
    short data;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(short data);
static void goodG2B()
{
    short data;
    data = 0;
    data = 2;
    var(data);
}
void var(short data);
static void goodB2G()
{
    short data;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_rand_preinc_12.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(globalReturnsTrueOrFalse())
    {
        data = (int64_t)RAND64();
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
    else
    {
        if (data < LLONG_MAX)
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    if(globalReturnsTrueOrFalse())
    {
        data = (int64_t)RAND64();
    }
    else
    {
        data = (int64_t)RAND64();
    }
    if(globalReturnsTrueOrFalse())
    {
        if (data < LLONG_MAX)
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
    else
    {
        if (data < LLONG_MAX)
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    if(globalReturnsTrueOrFalse())
    {
        data = 2;
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
    else
    {
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_max_postinc_66a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int dataArray[]);
void var()
{
    unsigned int data;
    unsigned int dataArray[5];
    data = 0;
    data = UINT_MAX;
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(unsigned int dataArray[]);
static void goodG2B()
{
    unsigned int data;
    unsigned int dataArray[5];
    data = 0;
    data = 2;
    dataArray[2] = data;
    var(dataArray);
}
void var(unsigned int dataArray[]);
static void goodB2G()
{
    unsigned int data;
    unsigned int dataArray[5];
    data = 0;
    data = UINT_MAX;
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_square_63a.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#include <inttypes.h>
#ifndef OMITBAD
void var(int64_t * dataPtr);
void var()
{
    int64_t data;
    data = 0LL;
    fscanf (stdin, ""%"" SCNd64, &data);
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t * data);
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = 2;
    var(&data);
}
void var(int64_t * data);
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    fscanf (stdin, ""%"" SCNd64, &data);
    var(&data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_fscanf_square_31.c,CWE190,bad,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    {
        char dataCopy = data;
        char data = dataCopy;
        {
            char result = data * data;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char data;
    data = ' ';
    data = 2;
    {
        char dataCopy = data;
        char data = dataCopy;
        {
            char result = data * data;
            printHexCharLine(result);
        }
    }
}
static void goodB2G()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    {
        char dataCopy = data;
        char data = dataCopy;
        if (abs((long)data) <= (long)sqrt((double)CHAR_MAX))
        {
            char result = data * data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_rand_preinc_32.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    int64_t *dataPtr1 = &data;
    int64_t *dataPtr2 = &data;
    data = 0LL;
    {
        int64_t data = *dataPtr1;
        data = (int64_t)RAND64();
        *dataPtr1 = data;
    }
    {
        int64_t data = *dataPtr2;
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int64_t data;
    int64_t *dataPtr1 = &data;
    int64_t *dataPtr2 = &data;
    data = 0LL;
    {
        int64_t data = *dataPtr1;
        data = 2;
        *dataPtr1 = data;
    }
    {
        int64_t data = *dataPtr2;
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
static void goodB2G()
{
    int64_t data;
    int64_t *dataPtr1 = &data;
    int64_t *dataPtr2 = &data;
    data = 0LL;
    {
        int64_t data = *dataPtr1;
        data = (int64_t)RAND64();
        *dataPtr1 = data;
    }
    {
        int64_t data = *dataPtr2;
        if (data < LLONG_MAX)
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_fscanf_preinc_04.c,CWE190,good,"#include ""std_testcase.h""
static const int STATIC_CONST_TRUE = 1; 
static const int STATIC_CONST_FALSE = 0; 
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(STATIC_CONST_TRUE)
    {
        fscanf (stdin, ""%c"", &data);
    }
    if(STATIC_CONST_TRUE)
    {
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(STATIC_CONST_TRUE)
    {
        fscanf (stdin, ""%c"", &data);
    }
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < CHAR_MAX)
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(STATIC_CONST_TRUE)
    {
        fscanf (stdin, ""%c"", &data);
    }
    if(STATIC_CONST_TRUE)
    {
        if (data < CHAR_MAX)
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(STATIC_CONST_TRUE)
    {
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(STATIC_CONST_TRUE)
    {
        data = 2;
    }
    if(STATIC_CONST_TRUE)
    {
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_rand_square_52a.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var(short data);
void var()
{
    short data;
    data = 0;
    data = (short)RAND32();
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(short data);
static void goodG2B()
{
    short data;
    data = 0;
    data = 2;
    var(data);
}
void var(short data);
static void goodB2G()
{
    short data;
    data = 0;
    data = (short)RAND32();
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_52c.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data)
{
    {
        data++;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data)
{
    {
        data++;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
void var(unsigned int data)
{
    if (data < UINT_MAX)
    {
        data++;
        unsigned int result = data;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int64_t_max_postinc_32.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    int64_t *dataPtr1 = &data;
    int64_t *dataPtr2 = &data;
    data = 0LL;
    {
        int64_t data = *dataPtr1;
        data = LLONG_MAX;
        *dataPtr1 = data;
    }
    {
        int64_t data = *dataPtr2;
        {
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int64_t data;
    int64_t *dataPtr1 = &data;
    int64_t *dataPtr2 = &data;
    data = 0LL;
    {
        int64_t data = *dataPtr1;
        data = 2;
        *dataPtr1 = data;
    }
    {
        int64_t data = *dataPtr2;
        {
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
static void goodB2G()
{
    int64_t data;
    int64_t *dataPtr1 = &data;
    int64_t *dataPtr2 = &data;
    data = 0LL;
    {
        int64_t data = *dataPtr1;
        data = LLONG_MAX;
        *dataPtr1 = data;
    }
    {
        int64_t data = *dataPtr2;
        if (data < LLONG_MAX)
        {
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_listen_socket_multiply_61a.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
int var(int data);
void var()
{
    int data;
    data = 0;
    data = var(data);
    if(data > 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
int var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = var(data);
    if(data > 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
int var(int data);
static void goodB2G()
{
    int data;
    data = 0;
    data = var(data);
    if(data > 0) 
    {
        if (data < (INT_MAX/2))
        {
            int result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fscanf_add_22a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
int var = 0;
void var(int data);
void var()
{
    int data;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    var = 1; 
    var(data);
}
#endif 
#ifndef OMITGOOD
int var = 0;
int var = 0;
int var = 0;
void var(int data);
static void goodB2G1()
{
    int data;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    var = 0; 
    var(data);
}
void var(int data);
static void goodB2G2()
{
    int data;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    var = 1; 
    var(data);
}
void var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    var = 1; 
    var(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_fscanf_postinc_51a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data);
void var()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char data);
static void goodG2B()
{
    char data;
    data = ' ';
    data = 2;
    var(data);
}
void var(char data);
static void goodB2G()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_fscanf_preinc_52a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data);
void var()
{
    short data;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(short data);
static void goodG2B()
{
    short data;
    data = 0;
    data = 2;
    var(data);
}
void var(short data);
static void goodB2G()
{
    short data;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fgets_add_16.c,CWE190,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    while(1)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
        break;
    }
    while(1)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int data;
    data = 0;
    while(1)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
        break;
    }
    while(1)
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
        break;
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    while(1)
    {
        data = 2;
        break;
    }
    while(1)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
        break;
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fgets_preinc_52c.c,CWE190,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data)
{
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
}
void var(int data)
{
    if (data < INT_MAX)
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__short_max_postinc_67b.c,CWE190,good,"#include ""std_testcase.h""
typedef struct _CWE190_Integer_Overflow__short_max_postinc_67_structType
{
    short structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct)
{
    short data = myStruct.structFirst;
    {
        data++;
        short result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(var myStruct)
{
    short data = myStruct.structFirst;
    {
        data++;
        short result = data;
        printIntLine(result);
    }
}
void var(var myStruct)
{
    short data = myStruct.structFirst;
    if (data < SHRT_MAX)
    {
        data++;
        short result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_04.c,CWE190,good,"#include ""std_testcase.h""
static const int STATIC_CONST_TRUE = 1; 
static const int STATIC_CONST_FALSE = 0; 
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        fscanf (stdin, ""%u"", &data);
    }
    if(STATIC_CONST_TRUE)
    {
        if(data > 0) 
        {
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        fscanf (stdin, ""%u"", &data);
    }
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data > 0) 
        {
            if (data < (UINT_MAX/2))
            {
                unsigned int result = data * 2;
                printUnsignedLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        fscanf (stdin, ""%u"", &data);
    }
    if(STATIC_CONST_TRUE)
    {
        if(data > 0) 
        {
            if (data < (UINT_MAX/2))
            {
                unsigned int result = data * 2;
                printUnsignedLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(STATIC_CONST_TRUE)
    {
        if(data > 0) 
        {
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        data = 2;
    }
    if(STATIC_CONST_TRUE)
    {
        if(data > 0) 
        {
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_max_preinc_52b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__int64_t_rand_add_03.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(5==5)
    {
        data = (int64_t)RAND64();
    }
    if(5==5)
    {
        {
            int64_t result = data + 1;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(5==5)
    {
        data = (int64_t)RAND64();
    }
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < LLONG_MAX)
        {
            int64_t result = data + 1;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(5==5)
    {
        data = (int64_t)RAND64();
    }
    if(5==5)
    {
        if (data < LLONG_MAX)
        {
            int64_t result = data + 1;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(5==5)
    {
        {
            int64_t result = data + 1;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(5==5)
    {
        data = 2;
    }
    if(5==5)
    {
        {
            int64_t result = data + 1;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_max_square_52c.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var(int data)
{
    {
        int result = data * data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    {
        int result = data * data;
        printIntLine(result);
    }
}
void var(int data)
{
    if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
    {
        int result = data * data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__short_fscanf_add_65a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data);
void var()
{
    short data;
    void (*funcPtr) (short) = var;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(short data);
static void goodG2B()
{
    short data;
    void (*funcPtr) (short) = var;
    data = 0;
    data = 2;
    funcPtr(data);
}
void var(short data);
static void goodB2G()
{
    short data;
    void (*funcPtr) (short) = var;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_max_multiply_16.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    while(1)
    {
        data = LLONG_MAX;
        break;
    }
    while(1)
    {
        if(data > 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    while(1)
    {
        data = LLONG_MAX;
        break;
    }
    while(1)
    {
        if(data > 0) 
        {
            if (data < (LLONG_MAX/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
        break;
    }
}
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    while(1)
    {
        data = 2;
        break;
    }
    while(1)
    {
        if(data > 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
        break;
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_fscanf_square_21.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
static int badStatic = 0;
static void badSink(short data)
{
    if(badStatic)
    {
        {
            short result = data * data;
            printIntLine(result);
        }
    }
}
void var()
{
    short data;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    badStatic = 1; 
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static int goodB2G1Static = 0;
static int goodB2G2Static = 0;
static int goodG2BStatic = 0;
static void goodB2G1Sink(short data)
{
    if(goodB2G1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (abs((long)data) <= (long)sqrt((double)SHRT_MAX))
        {
            short result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G1()
{
    short data;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    goodB2G1Static = 0; 
    goodB2G1Sink(data);
}
static void goodB2G2Sink(short data)
{
    if(goodB2G2Static)
    {
        if (abs((long)data) <= (long)sqrt((double)SHRT_MAX))
        {
            short result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    goodB2G2Static = 1; 
    goodB2G2Sink(data);
}
static void goodG2BSink(short data)
{
    if(goodG2BStatic)
    {
        {
            short result = data * data;
            printIntLine(result);
        }
    }
}
static void goodG2B()
{
    short data;
    data = 0;
    data = 2;
    goodG2BStatic = 1; 
    goodG2BSink(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_fscanf_add_13.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        fscanf (stdin, ""%u"", &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        fscanf (stdin, ""%u"", &data);
    }
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < UINT_MAX)
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        fscanf (stdin, ""%u"", &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if (data < UINT_MAX)
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = 2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fgets_add_61b.c,CWE190,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
int var(int data)
{
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    return data;
}
#endif 
#ifndef OMITGOOD
int var(int data)
{
    data = 2;
    return data;
}
int var(int data)
{
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    return data;
}
#endif"
CWE190_Integer_Overflow__int64_t_rand_multiply_51a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data);
void var()
{
    int64_t data;
    data = 0LL;
    data = (int64_t)RAND64();
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t data);
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = 2;
    var(data);
}
void var(int64_t data);
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    data = (int64_t)RAND64();
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_max_multiply_51b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data)
{
    if(data > 0) 
    {
        short result = data * 2;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(short data)
{
    if(data > 0) 
    {
        short result = data * 2;
        printIntLine(result);
    }
}
void var(short data)
{
    if(data > 0) 
    {
        if (data < (SHRT_MAX/2))
        {
            short result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif"
CWE190_Integer_Overflow__int_connect_socket_multiply_54e.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data)
{
    if(data > 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    if(data > 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
void var(int data)
{
    if(data > 0) 
    {
        if (data < (INT_MAX/2))
        {
            int result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif"
CWE190_Integer_Overflow__short_max_multiply_68b.c,CWE190,good,"#include ""std_testcase.h""
extern short var;
extern short var;
extern short var;
#ifndef OMITBAD
void var()
{
    short data = var;
    if(data > 0) 
    {
        short result = data * 2;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    short data = var;
    if(data > 0) 
    {
        short result = data * 2;
        printIntLine(result);
    }
}
void var()
{
    short data = var;
    if(data > 0) 
    {
        if (data < (SHRT_MAX/2))
        {
            short result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_preinc_12.c,CWE190,bad,"#include <inttypes.h>
#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(globalReturnsTrueOrFalse())
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
    else
    {
        if (data < LLONG_MAX)
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    if(globalReturnsTrueOrFalse())
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    else
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(globalReturnsTrueOrFalse())
    {
        if (data < LLONG_MAX)
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
    else
    {
        if (data < LLONG_MAX)
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    if(globalReturnsTrueOrFalse())
    {
        data = 2;
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
    else
    {
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_fscanf_preinc_08.c,CWE190,good,"#include ""std_testcase.h""
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(staticReturnsTrue())
    {
        fscanf (stdin, ""%c"", &data);
    }
    if(staticReturnsTrue())
    {
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(staticReturnsTrue())
    {
        fscanf (stdin, ""%c"", &data);
    }
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < CHAR_MAX)
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(staticReturnsTrue())
    {
        fscanf (stdin, ""%c"", &data);
    }
    if(staticReturnsTrue())
    {
        if (data < CHAR_MAX)
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(staticReturnsTrue())
    {
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(staticReturnsTrue())
    {
        data = 2;
    }
    if(staticReturnsTrue())
    {
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_rand_add_03.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(5==5)
    {
        data = RAND32();
    }
    if(5==5)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(5==5)
    {
        data = RAND32();
    }
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(5==5)
    {
        data = RAND32();
    }
    if(5==5)
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(5==5)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(5==5)
    {
        data = 2;
    }
    if(5==5)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fscanf_add_12.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        fscanf(stdin, ""%d"", &data);
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
    else
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        fscanf(stdin, ""%d"", &data);
    }
    else
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(globalReturnsTrueOrFalse())
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
    else
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        data = 2;
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
    else
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_postinc_53d.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data)
{
    {
        data++;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data)
{
    {
        data++;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
void var(unsigned int data)
{
    if (data < UINT_MAX)
    {
        data++;
        unsigned int result = data;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int_listen_socket_postinc_03.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(5==5)
    {
        {
            data++;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < INT_MAX)
        {
            data++;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(5==5)
    {
        if (data < INT_MAX)
        {
            data++;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(5==5)
    {
        {
            data++;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(5==5)
    {
        data = 2;
    }
    if(5==5)
    {
        {
            data++;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_rand_multiply_15.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    switch(6)
    {
    case 6:
        data = (short)RAND32();
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        if(data > 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    short data;
    data = 0;
    switch(6)
    {
    case 6:
        data = (short)RAND32();
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(8)
    {
    case 7:
        printLine(""Benign, fixed string"");
        break;
    default:
        if(data > 0) 
        {
            if (data < (SHRT_MAX/2))
            {
                short result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
        break;
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    switch(6)
    {
    case 6:
        data = (short)RAND32();
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        if(data > 0) 
        {
            if (data < (SHRT_MAX/2))
            {
                short result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B1()
{
    short data;
    data = 0;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        data = 2;
        break;
    }
    switch(7)
    {
    case 7:
        if(data > 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B2()
{
    short data;
    data = 0;
    switch(6)
    {
    case 6:
        data = 2;
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        if(data > 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_connect_socket_square_11.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#include <math.h>
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsTrue())
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsTrue())
    {
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrue())
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(globalReturnsTrue())
    {
        data = 2;
    }
    if(globalReturnsTrue())
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fscanf_square_64b.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    int * dataPtr = (int *)dataVoidPtr;
    int data = (*dataPtr);
    {
        int result = data * data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    int * dataPtr = (int *)dataVoidPtr;
    int data = (*dataPtr);
    {
        int result = data * data;
        printIntLine(result);
    }
}
void var(void * dataVoidPtr)
{
    int * dataPtr = (int *)dataVoidPtr;
    int data = (*dataPtr);
    if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
    {
        int result = data * data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_postinc_05.c,CWE190,good,"#include ""std_testcase.h""
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(staticTrue)
    {
        data = (unsigned int)RAND32();
    }
    if(staticTrue)
    {
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(staticTrue)
    {
        data = (unsigned int)RAND32();
    }
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < UINT_MAX)
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(staticTrue)
    {
        data = (unsigned int)RAND32();
    }
    if(staticTrue)
    {
        if (data < UINT_MAX)
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(staticTrue)
    {
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(staticTrue)
    {
        data = 2;
    }
    if(staticTrue)
    {
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_max_add_03.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(5==5)
    {
        data = CHAR_MAX;
    }
    if(5==5)
    {
        {
            char result = data + 1;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(5==5)
    {
        data = CHAR_MAX;
    }
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < CHAR_MAX)
        {
            char result = data + 1;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(5==5)
    {
        data = CHAR_MAX;
    }
    if(5==5)
    {
        if (data < CHAR_MAX)
        {
            char result = data + 1;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(5==5)
    {
        {
            char result = data + 1;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(5==5)
    {
        data = 2;
    }
    if(5==5)
    {
        {
            char result = data + 1;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fscanf_postinc_66a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int dataArray[]);
void var()
{
    int data;
    int dataArray[5];
    data = 0;
    fscanf(stdin, ""%d"", &data);
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(int dataArray[]);
static void goodG2B()
{
    int data;
    int dataArray[5];
    data = 0;
    data = 2;
    dataArray[2] = data;
    var(dataArray);
}
void var(int dataArray[]);
static void goodB2G()
{
    int data;
    int dataArray[5];
    data = 0;
    fscanf(stdin, ""%d"", &data);
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_max_preinc_14.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        data = INT_MAX;
    }
    if(globalFive==5)
    {
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        data = INT_MAX;
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < INT_MAX)
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        data = INT_MAX;
    }
    if(globalFive==5)
    {
        if (data < INT_MAX)
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(globalFive==5)
    {
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        data = 2;
    }
    if(globalFive==5)
    {
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_rand_postinc_54d.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__unsigned_int_max_multiply_17.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int i,j;
    unsigned int data;
    data = 0;
    for(i = 0; i < 1; i++)
    {
        data = UINT_MAX;
    }
    for(j = 0; j < 1; j++)
    {
        if(data > 0) 
        {
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int i,k;
    unsigned int data;
    data = 0;
    for(i = 0; i < 1; i++)
    {
        data = UINT_MAX;
    }
    for(k = 0; k < 1; k++)
    {
        if(data > 0) 
        {
            if (data < (UINT_MAX/2))
            {
                unsigned int result = data * 2;
                printUnsignedLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodG2B()
{
    int h,j;
    unsigned int data;
    data = 0;
    for(h = 0; h < 1; h++)
    {
        data = 2;
    }
    for(j = 0; j < 1; j++)
    {
        if(data > 0) 
        {
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_max_postinc_05.c,CWE190,good,"#include ""std_testcase.h""
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    if(staticTrue)
    {
        data = SHRT_MAX;
    }
    if(staticTrue)
    {
        {
            data++;
            short result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    short data;
    data = 0;
    if(staticTrue)
    {
        data = SHRT_MAX;
    }
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < SHRT_MAX)
        {
            data++;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    if(staticTrue)
    {
        data = SHRT_MAX;
    }
    if(staticTrue)
    {
        if (data < SHRT_MAX)
        {
            data++;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    short data;
    data = 0;
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(staticTrue)
    {
        {
            data++;
            short result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    short data;
    data = 0;
    if(staticTrue)
    {
        data = 2;
    }
    if(staticTrue)
    {
        {
            data++;
            short result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_rand_add_41.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
static void badSink(short data)
{
    {
        short result = data + 1;
        printIntLine(result);
    }
}
void var()
{
    short data;
    data = 0;
    data = (short)RAND32();
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(short data)
{
    {
        short result = data + 1;
        printIntLine(result);
    }
}
static void goodG2B()
{
    short data;
    data = 0;
    data = 2;
    goodG2BSink(data);
}
static void goodB2GSink(short data)
{
    if (data < SHRT_MAX)
    {
        short result = data + 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodB2G()
{
    short data;
    data = 0;
    data = (short)RAND32();
    goodB2GSink(data);
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_listen_socket_multiply_31.c,CWE190,bad,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        int dataCopy = data;
        int data = dataCopy;
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    {
        int dataCopy = data;
        int data = dataCopy;
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodB2G()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        int dataCopy = data;
        int data = dataCopy;
        if(data > 0) 
        {
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_max_add_17.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int i,j;
    char data;
    data = ' ';
    for(i = 0; i < 1; i++)
    {
        data = CHAR_MAX;
    }
    for(j = 0; j < 1; j++)
    {
        {
            char result = data + 1;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int i,k;
    char data;
    data = ' ';
    for(i = 0; i < 1; i++)
    {
        data = CHAR_MAX;
    }
    for(k = 0; k < 1; k++)
    {
        if (data < CHAR_MAX)
        {
            char result = data + 1;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B()
{
    int h,j;
    char data;
    data = ' ';
    for(h = 0; h < 1; h++)
    {
        data = 2;
    }
    for(j = 0; j < 1; j++)
    {
        {
            char result = data + 1;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_preinc_45.c,CWE190,bad,"#include <inttypes.h>
#include ""std_testcase.h""
static int64_t var;
static int64_t var;
static int64_t var;
#ifndef OMITBAD
static void badSink()
{
    int64_t data = var;
    {
        ++data;
        int64_t result = data;
        printLongLongLine(result);
    }
}
void var()
{
    int64_t data;
    data = 0LL;
    fscanf (stdin, ""%"" SCNd64, &data);
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    int64_t data = var;
    {
        ++data;
        int64_t result = data;
        printLongLongLine(result);
    }
}
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = 2;
    var = data;
    goodG2BSink();
}
static void goodB2GSink()
{
    int64_t data = var;
    if (data < LLONG_MAX)
    {
        ++data;
        int64_t result = data;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    fscanf (stdin, ""%"" SCNd64, &data);
    var = data;
    goodB2GSink();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_rand_add_61b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
int64_t var(int64_t data)
{
    data = (int64_t)RAND64();
    return data;
}
#endif 
#ifndef OMITGOOD
int64_t var(int64_t data)
{
    data = 2;
    return data;
}
int64_t var(int64_t data)
{
    data = (int64_t)RAND64();
    return data;
}
#endif"
CWE190_Integer_Overflow__char_rand_add_05.c,CWE190,bad,"#include ""std_testcase.h""
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(staticTrue)
    {
        data = (char)RAND32();
    }
    if(staticTrue)
    {
        {
            char result = data + 1;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(staticTrue)
    {
        data = (char)RAND32();
    }
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < CHAR_MAX)
        {
            char result = data + 1;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(staticTrue)
    {
        data = (char)RAND32();
    }
    if(staticTrue)
    {
        if (data < CHAR_MAX)
        {
            char result = data + 1;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(staticTrue)
    {
        {
            char result = data + 1;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(staticTrue)
    {
        data = 2;
    }
    if(staticTrue)
    {
        {
            char result = data + 1;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_max_preinc_01.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    data = INT_MAX;
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
}
static void goodB2G()
{
    int data;
    data = 0;
    data = INT_MAX;
    if (data < INT_MAX)
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_add_54d.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__int_listen_socket_add_54c.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__char_max_add_61a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
char var(char data);
void var()
{
    char data;
    data = ' ';
    data = var(data);
    {
        char result = data + 1;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
char var(char data);
static void goodG2B()
{
    char data;
    data = ' ';
    data = var(data);
    {
        char result = data + 1;
        printHexCharLine(result);
    }
}
char var(char data);
static void goodB2G()
{
    char data;
    data = ' ';
    data = var(data);
    if (data < CHAR_MAX)
    {
        char result = data + 1;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_square_21.c,CWE190,bad,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
static int badStatic = 0;
static void badSink(unsigned int data)
{
    if(badStatic)
    {
        {
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    unsigned int data;
    data = 0;
    data = (unsigned int)RAND32();
    badStatic = 1; 
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static int goodB2G1Static = 0;
static int goodB2G2Static = 0;
static int goodG2BStatic = 0;
static void goodB2G1Sink(unsigned int data)
{
    if(goodB2G1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (abs((long)data) < (long)sqrt((double)UINT_MAX))
        {
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    data = (unsigned int)RAND32();
    goodB2G1Static = 0; 
    goodB2G1Sink(data);
}
static void goodB2G2Sink(unsigned int data)
{
    if(goodB2G2Static)
    {
        if (abs((long)data) < (long)sqrt((double)UINT_MAX))
        {
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    data = (unsigned int)RAND32();
    goodB2G2Static = 1; 
    goodB2G2Sink(data);
}
static void goodG2BSink(unsigned int data)
{
    if(goodG2BStatic)
    {
        {
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = 2;
    goodG2BStatic = 1; 
    goodG2BSink(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_max_add_65a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data);
void var()
{
    short data;
    void (*funcPtr) (short) = var;
    data = 0;
    data = SHRT_MAX;
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(short data);
static void goodG2B()
{
    short data;
    void (*funcPtr) (short) = var;
    data = 0;
    data = 2;
    funcPtr(data);
}
void var(short data);
static void goodB2G()
{
    short data;
    void (*funcPtr) (short) = var;
    data = 0;
    data = SHRT_MAX;
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fscanf_add_63b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * dataPtr)
{
    int data = *dataPtr;
    {
        int result = data + 1;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int * dataPtr)
{
    int data = *dataPtr;
    {
        int result = data + 1;
        printIntLine(result);
    }
}
void var(int * dataPtr)
{
    int data = *dataPtr;
    if (data < INT_MAX)
    {
        int result = data + 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int_fgets_preinc_65a.c,CWE190,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data);
void var()
{
    int data;
    void (*funcPtr) (int) = var;
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
static void goodG2B()
{
    int data;
    void (*funcPtr) (int) = var;
    data = 0;
    data = 2;
    funcPtr(data);
}
void var(int data);
static void goodB2G()
{
    int data;
    void (*funcPtr) (int) = var;
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_max_postinc_03.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(5==5)
    {
        data = CHAR_MAX;
    }
    if(5==5)
    {
        {
            data++;
            char result = data;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(5==5)
    {
        data = CHAR_MAX;
    }
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < CHAR_MAX)
        {
            data++;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(5==5)
    {
        data = CHAR_MAX;
    }
    if(5==5)
    {
        if (data < CHAR_MAX)
        {
            data++;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(5==5)
    {
        {
            data++;
            char result = data;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(5==5)
    {
        data = 2;
    }
    if(5==5)
    {
        {
            data++;
            char result = data;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_fscanf_add_01.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    {
        char result = data + 1;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char data;
    data = ' ';
    data = 2;
    {
        char result = data + 1;
        printHexCharLine(result);
    }
}
static void goodB2G()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    if (data < CHAR_MAX)
    {
        char result = data + 1;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_fscanf_square_64b.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    unsigned int * dataPtr = (unsigned int *)dataVoidPtr;
    unsigned int data = (*dataPtr);
    {
        unsigned int result = data * data;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    unsigned int * dataPtr = (unsigned int *)dataVoidPtr;
    unsigned int data = (*dataPtr);
    {
        unsigned int result = data * data;
        printUnsignedLine(result);
    }
}
void var(void * dataVoidPtr)
{
    unsigned int * dataPtr = (unsigned int *)dataVoidPtr;
    unsigned int data = (*dataPtr);
    if (abs((long)data) < (long)sqrt((double)UINT_MAX))
    {
        unsigned int result = data * data;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__unsigned_int_fscanf_square_18.c,CWE190,bad,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    goto source;
source:
    fscanf (stdin, ""%u"", &data);
    goto sink;
sink:
    {
        unsigned int result = data * data;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    unsigned int data;
    data = 0;
    goto source;
source:
    fscanf (stdin, ""%u"", &data);
    goto sink;
sink:
    if (abs((long)data) < (long)sqrt((double)UINT_MAX))
    {
        unsigned int result = data * data;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodG2B()
{
    unsigned int data;
    data = 0;
    goto source;
source:
    data = 2;
    goto sink;
sink:
    {
        unsigned int result = data * data;
        printUnsignedLine(result);
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fscanf_postinc_61b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
int var(int data)
{
    fscanf(stdin, ""%d"", &data);
    return data;
}
#endif 
#ifndef OMITGOOD
int var(int data)
{
    data = 2;
    return data;
}
int var(int data)
{
    fscanf(stdin, ""%d"", &data);
    return data;
}
#endif"
CWE190_Integer_Overflow__int_fscanf_multiply_54d.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_preinc_54a.c,CWE190,good,"#include <inttypes.h>
#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data);
void var()
{
    int64_t data;
    data = 0LL;
    fscanf (stdin, ""%"" SCNd64, &data);
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t data);
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = 2;
    var(data);
}
void var(int64_t data);
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    fscanf (stdin, ""%"" SCNd64, &data);
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_max_square_54a.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var(int64_t data);
void var()
{
    int64_t data;
    data = 0LL;
    data = LLONG_MAX;
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t data);
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = 2;
    var(data);
}
void var(int64_t data);
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    data = LLONG_MAX;
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_add_65b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data)
{
    {
        unsigned int result = data + 1;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data)
{
    {
        unsigned int result = data + 1;
        printUnsignedLine(result);
    }
}
void var(unsigned int data)
{
    if (data < UINT_MAX)
    {
        unsigned int result = data + 1;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int_fscanf_add_31.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
static void goodB2G()
{
    int data;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    {
        int dataCopy = data;
        int data = dataCopy;
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_rand_preinc_13.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = RAND32();
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = RAND32();
    }
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < INT_MAX)
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = RAND32();
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if (data < INT_MAX)
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = 2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_fscanf_square_09.c,CWE190,bad,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        fscanf (stdin, ""%c"", &data);
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            char result = data * data;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        fscanf (stdin, ""%c"", &data);
    }
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (abs((long)data) <= (long)sqrt((double)CHAR_MAX))
        {
            char result = data * data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        fscanf (stdin, ""%c"", &data);
    }
    if(GLOBAL_CONST_TRUE)
    {
        if (abs((long)data) <= (long)sqrt((double)CHAR_MAX))
        {
            char result = data * data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            char result = data * data;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        data = 2;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            char result = data * data;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_listen_socket_preinc_08.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticReturnsTrue())
    {
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < INT_MAX)
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticReturnsTrue())
    {
        if (data < INT_MAX)
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(staticReturnsTrue())
    {
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        data = 2;
    }
    if(staticReturnsTrue())
    {
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fgets_multiply_05.c,CWE190,bad,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(staticTrue)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(staticTrue)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(staticTrue)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data > 0) 
        {
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(staticTrue)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(staticTrue)
    {
        if(data > 0) 
        {
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(staticTrue)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(staticTrue)
    {
        data = 2;
    }
    if(staticTrue)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_add_13.c,CWE190,bad,"#include <inttypes.h>
#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE==5)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            int64_t result = data + 1;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE==5)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < LLONG_MAX)
        {
            int64_t result = data + 1;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE==5)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if (data < LLONG_MAX)
        {
            int64_t result = data + 1;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            int64_t result = data + 1;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = 2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            int64_t result = data + 1;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_max_multiply_10.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalTrue)
    {
        data = INT_MAX;
    }
    if(globalTrue)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(globalTrue)
    {
        data = INT_MAX;
    }
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data > 0) 
        {
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(globalTrue)
    {
        data = INT_MAX;
    }
    if(globalTrue)
    {
        if(data > 0) 
        {
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(globalTrue)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(globalTrue)
    {
        data = 2;
    }
    if(globalTrue)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_multiply_03.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(5==5)
    {
        data = (unsigned int)RAND32();
    }
    if(5==5)
    {
        if(data > 0) 
        {
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(5==5)
    {
        data = (unsigned int)RAND32();
    }
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data > 0) 
        {
            if (data < (UINT_MAX/2))
            {
                unsigned int result = data * 2;
                printUnsignedLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(5==5)
    {
        data = (unsigned int)RAND32();
    }
    if(5==5)
    {
        if(data > 0) 
        {
            if (data < (UINT_MAX/2))
            {
                unsigned int result = data * 2;
                printUnsignedLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(5==5)
    {
        if(data > 0) 
        {
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(5==5)
    {
        data = 2;
    }
    if(5==5)
    {
        if(data > 0) 
        {
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_rand_postinc_65a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data);
void var()
{
    short data;
    void (*funcPtr) (short) = var;
    data = 0;
    data = (short)RAND32();
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(short data);
static void goodG2B()
{
    short data;
    void (*funcPtr) (short) = var;
    data = 0;
    data = 2;
    funcPtr(data);
}
void var(short data);
static void goodB2G()
{
    short data;
    void (*funcPtr) (short) = var;
    data = 0;
    data = (short)RAND32();
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_max_postinc_21.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
static int badStatic = 0;
static void badSink(unsigned int data)
{
    if(badStatic)
    {
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    unsigned int data;
    data = 0;
    data = UINT_MAX;
    badStatic = 1; 
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static int goodB2G1Static = 0;
static int goodB2G2Static = 0;
static int goodG2BStatic = 0;
static void goodB2G1Sink(unsigned int data)
{
    if(goodB2G1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < UINT_MAX)
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    data = UINT_MAX;
    goodB2G1Static = 0; 
    goodB2G1Sink(data);
}
static void goodB2G2Sink(unsigned int data)
{
    if(goodB2G2Static)
    {
        if (data < UINT_MAX)
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    data = UINT_MAX;
    goodB2G2Static = 1; 
    goodB2G2Sink(data);
}
static void goodG2BSink(unsigned int data)
{
    if(goodG2BStatic)
    {
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = 2;
    goodG2BStatic = 1; 
    goodG2BSink(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fscanf_add_14.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(globalFive==5)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(globalFive==5)
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(globalFive==5)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        data = 2;
    }
    if(globalFive==5)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_max_postinc_66a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char dataArray[]);
void var()
{
    char data;
    char dataArray[5];
    data = ' ';
    data = CHAR_MAX;
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(char dataArray[]);
static void goodG2B()
{
    char data;
    char dataArray[5];
    data = ' ';
    data = 2;
    dataArray[2] = data;
    var(dataArray);
}
void var(char dataArray[]);
static void goodB2G()
{
    char data;
    char dataArray[5];
    data = ' ';
    data = CHAR_MAX;
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_rand_preinc_53c.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data);
void var(short data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(short data);
void var(short data)
{
    var(data);
}
void var(short data);
void var(short data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_postinc_54a.c,CWE190,good,"#include <inttypes.h>
#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data);
void var()
{
    int64_t data;
    data = 0LL;
    fscanf (stdin, ""%"" SCNd64, &data);
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t data);
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = 2;
    var(data);
}
void var(int64_t data);
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    fscanf (stdin, ""%"" SCNd64, &data);
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_max_square_64a.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var(void * dataVoidPtr);
void var()
{
    unsigned int data;
    data = 0;
    data = UINT_MAX;
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr);
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = 2;
    var(&data);
}
void var(void * dataVoidPtr);
static void goodB2G()
{
    unsigned int data;
    data = 0;
    data = UINT_MAX;
    var(&data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fgets_add_61a.c,CWE190,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
int var(int data);
void var()
{
    int data;
    data = 0;
    data = var(data);
    {
        int result = data + 1;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
int var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = var(data);
    {
        int result = data + 1;
        printIntLine(result);
    }
}
int var(int data);
static void goodB2G()
{
    int data;
    data = 0;
    data = var(data);
    if (data < INT_MAX)
    {
        int result = data + 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_rand_add_16.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    while(1)
    {
        data = (short)RAND32();
        break;
    }
    while(1)
    {
        {
            short result = data + 1;
            printIntLine(result);
        }
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    short data;
    data = 0;
    while(1)
    {
        data = (short)RAND32();
        break;
    }
    while(1)
    {
        if (data < SHRT_MAX)
        {
            short result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
        break;
    }
}
static void goodG2B()
{
    short data;
    data = 0;
    while(1)
    {
        data = 2;
        break;
    }
    while(1)
    {
        {
            short result = data + 1;
            printIntLine(result);
        }
        break;
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_listen_socket_square_12.c,CWE190,bad,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#include <math.h>
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
    else
    {
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsTrueOrFalse())
    {
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
    else
    {
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        data = 2;
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
    else
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_rand_multiply_21.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
static int badStatic = 0;
static void badSink(int data)
{
    if(badStatic)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
void var()
{
    int data;
    data = 0;
    data = RAND32();
    badStatic = 1; 
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static int goodB2G1Static = 0;
static int goodB2G2Static = 0;
static int goodG2BStatic = 0;
static void goodB2G1Sink(int data)
{
    if(goodB2G1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data > 0) 
        {
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodB2G1()
{
    int data;
    data = 0;
    data = RAND32();
    goodB2G1Static = 0; 
    goodB2G1Sink(data);
}
static void goodB2G2Sink(int data)
{
    if(goodB2G2Static)
    {
        if(data > 0) 
        {
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    data = RAND32();
    goodB2G2Static = 1; 
    goodB2G2Sink(data);
}
static void goodG2BSink(int data)
{
    if(goodG2BStatic)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    goodG2BStatic = 1; 
    goodG2BSink(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_rand_add_21.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
static int badStatic = 0;
static void badSink(int data)
{
    if(badStatic)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
void var()
{
    int data;
    data = 0;
    data = RAND32();
    badStatic = 1; 
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static int goodB2G1Static = 0;
static int goodB2G2Static = 0;
static int goodG2BStatic = 0;
static void goodB2G1Sink(int data)
{
    if(goodB2G1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G1()
{
    int data;
    data = 0;
    data = RAND32();
    goodB2G1Static = 0; 
    goodB2G1Sink(data);
}
static void goodB2G2Sink(int data)
{
    if(goodB2G2Static)
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    data = RAND32();
    goodB2G2Static = 1; 
    goodB2G2Sink(data);
}
static void goodG2BSink(int data)
{
    if(goodG2BStatic)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    goodG2BStatic = 1; 
    goodG2BSink(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_add_64a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(void * dataVoidPtr);
void var()
{
    unsigned int data;
    data = 0;
    data = (unsigned int)RAND32();
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr);
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = 2;
    var(&data);
}
void var(void * dataVoidPtr);
static void goodB2G()
{
    unsigned int data;
    data = 0;
    data = (unsigned int)RAND32();
    var(&data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_rand_add_32.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    int64_t *dataPtr1 = &data;
    int64_t *dataPtr2 = &data;
    data = 0LL;
    {
        int64_t data = *dataPtr1;
        data = (int64_t)RAND64();
        *dataPtr1 = data;
    }
    {
        int64_t data = *dataPtr2;
        {
            int64_t result = data + 1;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int64_t data;
    int64_t *dataPtr1 = &data;
    int64_t *dataPtr2 = &data;
    data = 0LL;
    {
        int64_t data = *dataPtr1;
        data = 2;
        *dataPtr1 = data;
    }
    {
        int64_t data = *dataPtr2;
        {
            int64_t result = data + 1;
            printLongLongLine(result);
        }
    }
}
static void goodB2G()
{
    int64_t data;
    int64_t *dataPtr1 = &data;
    int64_t *dataPtr2 = &data;
    data = 0LL;
    {
        int64_t data = *dataPtr1;
        data = (int64_t)RAND64();
        *dataPtr1 = data;
    }
    {
        int64_t data = *dataPtr2;
        if (data < LLONG_MAX)
        {
            int64_t result = data + 1;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_listen_socket_postinc_12.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            data++;
            int result = data;
            printIntLine(result);
        }
    }
    else
    {
        if (data < INT_MAX)
        {
            data++;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsTrueOrFalse())
    {
        if (data < INT_MAX)
        {
            data++;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
    else
    {
        if (data < INT_MAX)
        {
            data++;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        data = 2;
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            data++;
            int result = data;
            printIntLine(result);
        }
    }
    else
    {
        {
            data++;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_fscanf_multiply_52a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data);
void var()
{
    short data;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(short data);
static void goodG2B()
{
    short data;
    data = 0;
    data = 2;
    var(data);
}
void var(short data);
static void goodB2G()
{
    short data;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fscanf_postinc_53a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data);
void var()
{
    int data;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    var(data);
}
void var(int data);
static void goodB2G()
{
    int data;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_max_preinc_13.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = UINT_MAX;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = UINT_MAX;
    }
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < UINT_MAX)
        {
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = UINT_MAX;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if (data < UINT_MAX)
        {
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = 2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            ++data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_max_postinc_04.c,CWE190,good,"#include ""std_testcase.h""
static const int STATIC_CONST_TRUE = 1; 
static const int STATIC_CONST_FALSE = 0; 
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        data = SHRT_MAX;
    }
    if(STATIC_CONST_TRUE)
    {
        {
            data++;
            short result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    short data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        data = SHRT_MAX;
    }
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < SHRT_MAX)
        {
            data++;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        data = SHRT_MAX;
    }
    if(STATIC_CONST_TRUE)
    {
        if (data < SHRT_MAX)
        {
            data++;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    short data;
    data = 0;
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(STATIC_CONST_TRUE)
    {
        {
            data++;
            short result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    short data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        data = 2;
    }
    if(STATIC_CONST_TRUE)
    {
        {
            data++;
            short result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fgets_add_12.c,CWE190,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
    else
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    else
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(globalReturnsTrueOrFalse())
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
    else
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        data = 2;
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
    else
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_max_multiply_10.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(globalTrue)
    {
        data = LLONG_MAX;
    }
    if(globalTrue)
    {
        if(data > 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(globalTrue)
    {
        data = LLONG_MAX;
    }
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data > 0) 
        {
            if (data < (LLONG_MAX/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(globalTrue)
    {
        data = LLONG_MAX;
    }
    if(globalTrue)
    {
        if(data > 0) 
        {
            if (data < (LLONG_MAX/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(globalTrue)
    {
        if(data > 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(globalTrue)
    {
        data = 2;
    }
    if(globalTrue)
    {
        if(data > 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_fscanf_square_11.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    if(globalReturnsTrue())
    {
        fscanf (stdin, ""%hd"", &data);
    }
    if(globalReturnsTrue())
    {
        {
            short result = data * data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    short data;
    data = 0;
    if(globalReturnsTrue())
    {
        fscanf (stdin, ""%hd"", &data);
    }
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (abs((long)data) <= (long)sqrt((double)SHRT_MAX))
        {
            short result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    if(globalReturnsTrue())
    {
        fscanf (stdin, ""%hd"", &data);
    }
    if(globalReturnsTrue())
    {
        if (abs((long)data) <= (long)sqrt((double)SHRT_MAX))
        {
            short result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    short data;
    data = 0;
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrue())
    {
        {
            short result = data * data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    short data;
    data = 0;
    if(globalReturnsTrue())
    {
        data = 2;
    }
    if(globalReturnsTrue())
    {
        {
            short result = data * data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_max_add_06.c,CWE190,good,"#include ""std_testcase.h""
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        data = INT_MAX;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        data = INT_MAX;
    }
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        data = INT_MAX;
    }
    if(STATIC_CONST_FIVE==5)
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        data = 2;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_fscanf_multiply_41.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
static void badSink(char data)
{
    if(data > 0) 
    {
        char result = data * 2;
        printHexCharLine(result);
    }
}
void var()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(char data)
{
    if(data > 0) 
    {
        char result = data * 2;
        printHexCharLine(result);
    }
}
static void goodG2B()
{
    char data;
    data = ' ';
    data = 2;
    goodG2BSink(data);
}
static void goodB2GSink(char data)
{
    if(data > 0) 
    {
        if (data < (CHAR_MAX/2))
        {
            char result = data * 2;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    goodB2GSink(data);
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_max_multiply_14.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        data = INT_MAX;
    }
    if(globalFive==5)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        data = INT_MAX;
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data > 0) 
        {
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        data = INT_MAX;
    }
    if(globalFive==5)
    {
        if(data > 0) 
        {
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(globalFive==5)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        data = 2;
    }
    if(globalFive==5)
    {
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_rand_square_02.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(1)
    {
        data = RAND32();
    }
    if(1)
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(1)
    {
        data = RAND32();
    }
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(1)
    {
        data = RAND32();
    }
    if(1)
    {
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(1)
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(1)
    {
        data = 2;
    }
    if(1)
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_rand_add_52c.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data)
{
    {
        int64_t result = data + 1;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int64_t data)
{
    {
        int64_t result = data + 1;
        printLongLongLine(result);
    }
}
void var(int64_t data)
{
    if (data < LLONG_MAX)
    {
        int64_t result = data + 1;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__short_fscanf_postinc_68b.c,CWE190,good,"#include ""std_testcase.h""
extern short var;
extern short var;
extern short var;
#ifndef OMITBAD
void var()
{
    short data = var;
    {
        data++;
        short result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    short data = var;
    {
        data++;
        short result = data;
        printIntLine(result);
    }
}
void var()
{
    short data = var;
    if (data < SHRT_MAX)
    {
        data++;
        short result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__char_max_postinc_42.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
static char badSource(char data)
{
    data = CHAR_MAX;
    return data;
}
void var()
{
    char data;
    data = ' ';
    data = badSource(data);
    {
        data++;
        char result = data;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static char goodG2BSource(char data)
{
    data = 2;
    return data;
}
static void goodG2B()
{
    char data;
    data = ' ';
    data = goodG2BSource(data);
    {
        data++;
        char result = data;
        printHexCharLine(result);
    }
}
static char goodB2GSource(char data)
{
    data = CHAR_MAX;
    return data;
}
static void goodB2G()
{
    char data;
    data = ' ';
    data = goodB2GSource(data);
    if (data < CHAR_MAX)
    {
        data++;
        char result = data;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_max_square_22b.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#include <inttypes.h>
#ifndef OMITBAD
extern int var;
void var(int64_t data)
{
    if(var)
    {
        {
            int64_t result = data * data;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
extern int var;
extern int var;
extern int var;
void var(int64_t data)
{
    if(var)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (imaxabs((intmax_t)data) <= sqrtl(LLONG_MAX))
        {
            int64_t result = data * data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var(int64_t data)
{
    if(var)
    {
        if (imaxabs((intmax_t)data) <= sqrtl(LLONG_MAX))
        {
            int64_t result = data * data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var(int64_t data)
{
    if(var)
    {
        {
            int64_t result = data * data;
            printLongLongLine(result);
        }
    }
}
#endif"
CWE190_Integer_Overflow__int_fscanf_add_04.c,CWE190,good,"#include ""std_testcase.h""
static const int STATIC_CONST_TRUE = 1; 
static const int STATIC_CONST_FALSE = 0; 
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(STATIC_CONST_TRUE)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(STATIC_CONST_TRUE)
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(STATIC_CONST_TRUE)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        data = 2;
    }
    if(STATIC_CONST_TRUE)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fgets_multiply_32.c,CWE190,bad,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    data = 0;
    {
        int data = *dataPtr1;
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    data = 0;
    {
        int data = *dataPtr1;
        data = 2;
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        if(data > 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodB2G()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    data = 0;
    {
        int data = *dataPtr1;
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        if(data > 0) 
        {
            if (data < (INT_MAX/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fscanf_add_52c.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data)
{
    {
        int result = data + 1;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    {
        int result = data + 1;
        printIntLine(result);
    }
}
void var(int data)
{
    if (data < INT_MAX)
    {
        int result = data + 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__unsigned_int_max_preinc_54b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__int_rand_postinc_51b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data)
{
    {
        data++;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    {
        data++;
        int result = data;
        printIntLine(result);
    }
}
void var(int data)
{
    if (data < INT_MAX)
    {
        data++;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__unsigned_int_fscanf_add_52b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__char_fscanf_add_11.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(globalReturnsTrue())
    {
        fscanf (stdin, ""%c"", &data);
    }
    if(globalReturnsTrue())
    {
        {
            char result = data + 1;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(globalReturnsTrue())
    {
        fscanf (stdin, ""%c"", &data);
    }
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < CHAR_MAX)
        {
            char result = data + 1;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(globalReturnsTrue())
    {
        fscanf (stdin, ""%c"", &data);
    }
    if(globalReturnsTrue())
    {
        if (data < CHAR_MAX)
        {
            char result = data + 1;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrue())
    {
        {
            char result = data + 1;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(globalReturnsTrue())
    {
        data = 2;
    }
    if(globalReturnsTrue())
    {
        {
            char result = data + 1;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fgets_square_14.c,CWE190,bad,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#include <math.h>
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(globalFive==5)
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(globalFive==5)
    {
        if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
        {
            int result = data * data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(globalFive==5)
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        data = 2;
    }
    if(globalFive==5)
    {
        {
            int result = data * data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_max_postinc_61b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
char var(char data)
{
    data = CHAR_MAX;
    return data;
}
#endif 
#ifndef OMITGOOD
char var(char data)
{
    data = 2;
    return data;
}
char var(char data)
{
    data = CHAR_MAX;
    return data;
}
#endif"
CWE190_Integer_Overflow__int64_t_rand_add_61a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
int64_t var(int64_t data);
void var()
{
    int64_t data;
    data = 0LL;
    data = var(data);
    {
        int64_t result = data + 1;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
int64_t var(int64_t data);
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = var(data);
    {
        int64_t result = data + 1;
        printLongLongLine(result);
    }
}
int64_t var(int64_t data);
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    data = var(data);
    if (data < LLONG_MAX)
    {
        int64_t result = data + 1;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_fscanf_postinc_64b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    short * dataPtr = (short *)dataVoidPtr;
    short data = (*dataPtr);
    {
        data++;
        short result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    short * dataPtr = (short *)dataVoidPtr;
    short data = (*dataPtr);
    {
        data++;
        short result = data;
        printIntLine(result);
    }
}
void var(void * dataVoidPtr)
{
    short * dataPtr = (short *)dataVoidPtr;
    short data = (*dataPtr);
    if (data < SHRT_MAX)
    {
        data++;
        short result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__short_fscanf_add_66b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short dataArray[])
{
    short data = dataArray[2];
    {
        short result = data + 1;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(short dataArray[])
{
    short data = dataArray[2];
    {
        short result = data + 1;
        printIntLine(result);
    }
}
void var(short dataArray[])
{
    short data = dataArray[2];
    if (data < SHRT_MAX)
    {
        short result = data + 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__char_fscanf_square_32.c,CWE190,bad,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var()
{
    char data;
    char *dataPtr1 = &data;
    char *dataPtr2 = &data;
    data = ' ';
    {
        char data = *dataPtr1;
        fscanf (stdin, ""%c"", &data);
        *dataPtr1 = data;
    }
    {
        char data = *dataPtr2;
        {
            char result = data * data;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char data;
    char *dataPtr1 = &data;
    char *dataPtr2 = &data;
    data = ' ';
    {
        char data = *dataPtr1;
        data = 2;
        *dataPtr1 = data;
    }
    {
        char data = *dataPtr2;
        {
            char result = data * data;
            printHexCharLine(result);
        }
    }
}
static void goodB2G()
{
    char data;
    char *dataPtr1 = &data;
    char *dataPtr2 = &data;
    data = ' ';
    {
        char data = *dataPtr1;
        fscanf (stdin, ""%c"", &data);
        *dataPtr1 = data;
    }
    {
        char data = *dataPtr2;
        if (abs((long)data) <= (long)sqrt((double)CHAR_MAX))
        {
            char result = data * data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_fscanf_multiply_11.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    if(globalReturnsTrue())
    {
        fscanf (stdin, ""%hd"", &data);
    }
    if(globalReturnsTrue())
    {
        if(data > 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    short data;
    data = 0;
    if(globalReturnsTrue())
    {
        fscanf (stdin, ""%hd"", &data);
    }
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data > 0) 
        {
            if (data < (SHRT_MAX/2))
            {
                short result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    if(globalReturnsTrue())
    {
        fscanf (stdin, ""%hd"", &data);
    }
    if(globalReturnsTrue())
    {
        if(data > 0) 
        {
            if (data < (SHRT_MAX/2))
            {
                short result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodG2B1()
{
    short data;
    data = 0;
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(globalReturnsTrue())
    {
        if(data > 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    short data;
    data = 0;
    if(globalReturnsTrue())
    {
        data = 2;
    }
    if(globalReturnsTrue())
    {
        if(data > 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_max_multiply_03.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(5==5)
    {
        data = CHAR_MAX;
    }
    if(5==5)
    {
        if(data > 0) 
        {
            char result = data * 2;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(5==5)
    {
        data = CHAR_MAX;
    }
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data > 0) 
        {
            if (data < (CHAR_MAX/2))
            {
                char result = data * 2;
                printHexCharLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(5==5)
    {
        data = CHAR_MAX;
    }
    if(5==5)
    {
        if(data > 0) 
        {
            if (data < (CHAR_MAX/2))
            {
                char result = data * 2;
                printHexCharLine(result);
            }
            else
            {
                printLine(""data value is too large to perform arithmetic safely."");
            }
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(5==5)
    {
        if(data > 0) 
        {
            char result = data * 2;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(5==5)
    {
        data = 2;
    }
    if(5==5)
    {
        if(data > 0) 
        {
            char result = data * 2;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_max_multiply_65b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data)
{
    if(data > 0) 
    {
        short result = data * 2;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(short data)
{
    if(data > 0) 
    {
        short result = data * 2;
        printIntLine(result);
    }
}
void var(short data)
{
    if(data > 0) 
    {
        if (data < (SHRT_MAX/2))
        {
            short result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_add_10.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(globalTrue)
    {
        data = (unsigned int)RAND32();
    }
    if(globalTrue)
    {
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(globalTrue)
    {
        data = (unsigned int)RAND32();
    }
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < UINT_MAX)
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(globalTrue)
    {
        data = (unsigned int)RAND32();
    }
    if(globalTrue)
    {
        if (data < UINT_MAX)
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(globalTrue)
    {
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(globalTrue)
    {
        data = 2;
    }
    if(globalTrue)
    {
        {
            unsigned int result = data + 1;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_max_multiply_54c.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__char_fscanf_square_42.c,CWE190,bad,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
static char badSource(char data)
{
    fscanf (stdin, ""%c"", &data);
    return data;
}
void var()
{
    char data;
    data = ' ';
    data = badSource(data);
    {
        char result = data * data;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static char goodG2BSource(char data)
{
    data = 2;
    return data;
}
static void goodG2B()
{
    char data;
    data = ' ';
    data = goodG2BSource(data);
    {
        char result = data * data;
        printHexCharLine(result);
    }
}
static char goodB2GSource(char data)
{
    fscanf (stdin, ""%c"", &data);
    return data;
}
static void goodB2G()
{
    char data;
    data = ' ';
    data = goodB2GSource(data);
    if (abs((long)data) <= (long)sqrt((double)CHAR_MAX))
    {
        char result = data * data;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_connect_socket_add_44.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
static void badSink(int data)
{
    {
        int result = data + 1;
        printIntLine(result);
    }
}
void var()
{
    int data;
    void (*funcPtr) (int) = badSink;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(int data)
{
    {
        int result = data + 1;
        printIntLine(result);
    }
}
static void goodG2B()
{
    int data;
    void (*funcPtr) (int) = goodG2BSink;
    data = 0;
    data = 2;
    funcPtr(data);
}
static void goodB2GSink(int data)
{
    if (data < INT_MAX)
    {
        int result = data + 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodB2G()
{
    int data;
    void (*funcPtr) (int) = goodB2GSink;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_max_square_51b.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var(int data)
{
    {
        int result = data * data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    {
        int result = data * data;
        printIntLine(result);
    }
}
void var(int data)
{
    if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
    {
        int result = data * data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_square_51b.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var(unsigned int data)
{
    {
        unsigned int result = data * data;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data)
{
    {
        unsigned int result = data * data;
        printUnsignedLine(result);
    }
}
void var(unsigned int data)
{
    if (abs((long)data) < (long)sqrt((double)UINT_MAX))
    {
        unsigned int result = data * data;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_preinc_67b.c,CWE190,good,"#include ""std_testcase.h""
typedef struct _CWE190_Integer_Overflow__int64_t_fscanf_preinc_67_structType
{
    int64_t structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct)
{
    int64_t data = myStruct.structFirst;
    {
        ++data;
        int64_t result = data;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(var myStruct)
{
    int64_t data = myStruct.structFirst;
    {
        ++data;
        int64_t result = data;
        printLongLongLine(result);
    }
}
void var(var myStruct)
{
    int64_t data = myStruct.structFirst;
    if (data < LLONG_MAX)
    {
        ++data;
        int64_t result = data;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_postinc_13.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = (unsigned int)RAND32();
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = (unsigned int)RAND32();
    }
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < UINT_MAX)
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = (unsigned int)RAND32();
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if (data < UINT_MAX)
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = 2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            data++;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_max_postinc_02.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(1)
    {
        data = LLONG_MAX;
    }
    if(1)
    {
        {
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(1)
    {
        data = LLONG_MAX;
    }
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < LLONG_MAX)
        {
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(1)
    {
        data = LLONG_MAX;
    }
    if(1)
    {
        if (data < LLONG_MAX)
        {
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(1)
    {
        {
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(1)
    {
        data = 2;
    }
    if(1)
    {
        {
            data++;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_fscanf_preinc_13.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_FIVE==5)
    {
        fscanf (stdin, ""%c"", &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_FIVE==5)
    {
        fscanf (stdin, ""%c"", &data);
    }
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < CHAR_MAX)
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_FIVE==5)
    {
        fscanf (stdin, ""%c"", &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if (data < CHAR_MAX)
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_FIVE==5)
    {
        data = 2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_rand_square_54d.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__int_fgets_postinc_54a.c,CWE190,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data);
void var()
{
    int data;
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    var(data);
}
void var(int data);
static void goodB2G()
{
    int data;
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_multiply_54e.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data)
{
    if(data > 0) 
    {
        unsigned int result = data * 2;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data)
{
    if(data > 0) 
    {
        unsigned int result = data * 2;
        printUnsignedLine(result);
    }
}
void var(unsigned int data)
{
    if(data > 0) 
    {
        if (data < (UINT_MAX/2))
        {
            unsigned int result = data * 2;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif"
CWE190_Integer_Overflow__int_fscanf_postinc_15.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    switch(6)
    {
    case 6:
        fscanf(stdin, ""%d"", &data);
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        data++;
        int result = data;
        printIntLine(result);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    switch(6)
    {
    case 6:
        fscanf(stdin, ""%d"", &data);
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(8)
    {
    case 7:
        printLine(""Benign, fixed string"");
        break;
    default:
        if (data < INT_MAX)
        {
            data++;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
        break;
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    switch(6)
    {
    case 6:
        fscanf(stdin, ""%d"", &data);
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        if (data < INT_MAX)
        {
            data++;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        data = 2;
        break;
    }
    switch(7)
    {
    case 7:
    {
        data++;
        int result = data;
        printIntLine(result);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    switch(6)
    {
    case 6:
        data = 2;
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        data++;
        int result = data;
        printIntLine(result);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_listen_socket_square_54d.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#include <math.h>
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__int_connect_socket_preinc_45.c,CWE190,bad,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
static int var;
static int var;
static int var;
#ifndef OMITBAD
static void badSink()
{
    int data = var;
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
}
void var()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    int data = var;
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    data = 2;
    var = data;
    goodG2BSink();
}
static void goodB2GSink()
{
    int data = var;
    if (data < INT_MAX)
    {
        ++data;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodB2G()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var = data;
    goodB2GSink();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fscanf_multiply_44.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
static void badSink(int data)
{
    if(data > 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
void var()
{
    int data;
    void (*funcPtr) (int) = badSink;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(int data)
{
    if(data > 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
static void goodG2B()
{
    int data;
    void (*funcPtr) (int) = goodG2BSink;
    data = 0;
    data = 2;
    funcPtr(data);
}
static void goodB2GSink(int data)
{
    if(data > 0) 
    {
        if (data < (INT_MAX/2))
        {
            int result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G()
{
    int data;
    void (*funcPtr) (int) = goodB2GSink;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_fscanf_multiply_54d.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data);
void var(char data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char data);
void var(char data)
{
    var(data);
}
void var(char data);
void var(char data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_preinc_13.c,CWE190,bad,"#include <inttypes.h>
#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE==5)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE==5)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < LLONG_MAX)
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE==5)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if (data < LLONG_MAX)
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = 2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_connect_socket_add_10.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalTrue)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(globalTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(globalTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalTrue)
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(globalTrue)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(globalTrue)
    {
        data = 2;
    }
    if(globalTrue)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_rand_preinc_34.c,CWE190,bad,"#include ""std_testcase.h""
typedef union
{
    char unionFirst;
    char unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    char data;
    var myUnion;
    data = ' ';
    data = (char)RAND32();
    myUnion.unionFirst = data;
    {
        char data = myUnion.unionSecond;
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char data;
    var myUnion;
    data = ' ';
    data = 2;
    myUnion.unionFirst = data;
    {
        char data = myUnion.unionSecond;
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
static void goodB2G()
{
    char data;
    var myUnion;
    data = ' ';
    data = (char)RAND32();
    myUnion.unionFirst = data;
    {
        char data = myUnion.unionSecond;
        if (data < CHAR_MAX)
        {
            ++data;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_rand_add_16.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    while(1)
    {
        data = RAND32();
        break;
    }
    while(1)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int data;
    data = 0;
    while(1)
    {
        data = RAND32();
        break;
    }
    while(1)
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
        break;
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    while(1)
    {
        data = 2;
        break;
    }
    while(1)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
        break;
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_fscanf_square_54d.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_square_06.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        data = (unsigned int)RAND32();
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        data = (unsigned int)RAND32();
    }
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (abs((long)data) < (long)sqrt((double)UINT_MAX))
        {
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        data = (unsigned int)RAND32();
    }
    if(STATIC_CONST_FIVE==5)
    {
        if (abs((long)data) < (long)sqrt((double)UINT_MAX))
        {
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        data = 2;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            unsigned int result = data * data;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_listen_socket_postinc_42.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
static int badSource(int data)
{
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    return data;
}
void var()
{
    int data;
    data = 0;
    data = badSource(data);
    {
        data++;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static int goodG2BSource(int data)
{
    data = 2;
    return data;
}
static void goodG2B()
{
    int data;
    data = 0;
    data = goodG2BSource(data);
    {
        data++;
        int result = data;
        printIntLine(result);
    }
}
static int goodB2GSource(int data)
{
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    return data;
}
static void goodB2G()
{
    int data;
    data = 0;
    data = goodB2GSource(data);
    if (data < INT_MAX)
    {
        data++;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__char_fscanf_postinc_42.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
static char badSource(char data)
{
    fscanf (stdin, ""%c"", &data);
    return data;
}
void var()
{
    char data;
    data = ' ';
    data = badSource(data);
    {
        data++;
        char result = data;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static char goodG2BSource(char data)
{
    data = 2;
    return data;
}
static void goodG2B()
{
    char data;
    data = ' ';
    data = goodG2BSource(data);
    {
        data++;
        char result = data;
        printHexCharLine(result);
    }
}
static char goodB2GSource(char data)
{
    fscanf (stdin, ""%c"", &data);
    return data;
}
static void goodB2G()
{
    char data;
    data = ' ';
    data = goodB2GSource(data);
    if (data < CHAR_MAX)
    {
        data++;
        char result = data;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_max_preinc_08.c,CWE190,good,"#include ""std_testcase.h""
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(staticReturnsTrue())
    {
        data = LLONG_MAX;
    }
    if(staticReturnsTrue())
    {
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(staticReturnsTrue())
    {
        data = LLONG_MAX;
    }
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < LLONG_MAX)
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(staticReturnsTrue())
    {
        data = LLONG_MAX;
    }
    if(staticReturnsTrue())
    {
        if (data < LLONG_MAX)
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(staticReturnsTrue())
    {
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(staticReturnsTrue())
    {
        data = 2;
    }
    if(staticReturnsTrue())
    {
        {
            ++data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_fgets_add_03.c,CWE190,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(5==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(5==5)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(5==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(5==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(5==5)
    {
        if (data < INT_MAX)
        {
            int result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(5==5)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(5==5)
    {
        data = 2;
    }
    if(5==5)
    {
        {
            int result = data + 1;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_connect_socket_postinc_16.c,CWE190,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    while(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        break;
    }
    while(1)
    {
        {
            data++;
            int result = data;
            printIntLine(result);
        }
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int data;
    data = 0;
    while(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        break;
    }
    while(1)
    {
        if (data < INT_MAX)
        {
            data++;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
        break;
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    while(1)
    {
        data = 2;
        break;
    }
    while(1)
    {
        {
            data++;
            int result = data;
            printIntLine(result);
        }
        break;
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_fscanf_add_65b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data)
{
    {
        short result = data + 1;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(short data)
{
    {
        short result = data + 1;
        printIntLine(result);
    }
}
void var(short data)
{
    if (data < SHRT_MAX)
    {
        short result = data + 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int_fscanf_preinc_13.c,CWE190,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < INT_MAX)
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if (data < INT_MAX)
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = 2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            ++data;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_add_68a.c,CWE190,good,"#include ""std_testcase.h""
unsigned int var;
unsigned int var;
unsigned int var;
#ifndef OMITBAD
void var();
void var()
{
    unsigned int data;
    data = 0;
    data = (unsigned int)RAND32();
    var = data;
    var();
}
#endif 
#ifndef OMITGOOD
void var();
void var();
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = 2;
    var = data;
    var();
}
static void goodB2G()
{
    unsigned int data;
    data = 0;
    data = (unsigned int)RAND32();
    var = data;
    var();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__unsigned_int_rand_multiply_68a.c,CWE190,good,"#include ""std_testcase.h""
unsigned int var;
unsigned int var;
unsigned int var;
#ifndef OMITBAD
void var();
void var()
{
    unsigned int data;
    data = 0;
    data = (unsigned int)RAND32();
    var = data;
    var();
}
#endif 
#ifndef OMITGOOD
void var();
void var();
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = 2;
    var = data;
    var();
}
static void goodB2G()
{
    unsigned int data;
    data = 0;
    data = (unsigned int)RAND32();
    var = data;
    var();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_fscanf_preinc_52b.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data);
void var(short data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(short data);
void var(short data)
{
    var(data);
}
void var(short data);
void var(short data)
{
    var(data);
}
#endif"
CWE190_Integer_Overflow__int_max_square_53d.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
#ifndef OMITBAD
void var(int data)
{
    {
        int result = data * data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    {
        int result = data * data;
        printIntLine(result);
    }
}
void var(int data)
{
    if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX))
    {
        int result = data * data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE190_Integer_Overflow__int64_t_rand_preinc_65a.c,CWE190,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data);
void var()
{
    int64_t data;
    void (*funcPtr) (int64_t) = var;
    data = 0LL;
    data = (int64_t)RAND64();
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t data);
static void goodG2B()
{
    int64_t data;
    void (*funcPtr) (int64_t) = var;
    data = 0LL;
    data = 2;
    funcPtr(data);
}
void var(int64_t data);
static void goodB2G()
{
    int64_t data;
    void (*funcPtr) (int64_t) = var;
    data = 0LL;
    data = (int64_t)RAND64();
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int_max_square_67a.c,CWE190,good,"#include ""std_testcase.h""
#include <math.h>
typedef struct _CWE190_Integer_Overflow__int_max_square_67_structType
{
    int structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct);
void var()
{
    int data;
    var myStruct;
    data = 0;
    data = INT_MAX;
    myStruct.structFirst = data;
    var(myStruct);
}
#endif 
#ifndef OMITGOOD
void var(var myStruct);
static void goodG2B()
{
    int data;
    var myStruct;
    data = 0;
    data = 2;
    myStruct.structFirst = data;
    var(myStruct);
}
void var(var myStruct);
static void goodB2G()
{
    int data;
    var myStruct;
    data = 0;
    data = INT_MAX;
    myStruct.structFirst = data;
    var(myStruct);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__short_rand_add_08.c,CWE190,good,"#include ""std_testcase.h""
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    if(staticReturnsTrue())
    {
        data = (short)RAND32();
    }
    if(staticReturnsTrue())
    {
        {
            short result = data + 1;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    short data;
    data = 0;
    if(staticReturnsTrue())
    {
        data = (short)RAND32();
    }
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data < SHRT_MAX)
        {
            short result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    if(staticReturnsTrue())
    {
        data = (short)RAND32();
    }
    if(staticReturnsTrue())
    {
        if (data < SHRT_MAX)
        {
            short result = data + 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    short data;
    data = 0;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 2;
    }
    if(staticReturnsTrue())
    {
        {
            short result = data + 1;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    short data;
    data = 0;
    if(staticReturnsTrue())
    {
        data = 2;
    }
    if(staticReturnsTrue())
    {
        {
            short result = data + 1;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE190_Integer_Overflow__int64_t_fscanf_postinc_53a.c,CWE190,good,"#include <inttypes.h>
#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data);
void var()
{
    int64_t data;
    data = 0LL;
    fscanf (stdin, ""%"" SCNd64, &data);
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t data);
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = 2;
    var(data);
}
void var(int64_t data);
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    fscanf (stdin, ""%"" SCNd64, &data);
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_fscanf_sub_54d.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data);
void var(char data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char data);
void var(char data)
{
    var(data);
}
void var(char data);
void var(char data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__short_rand_predec_41.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
static void badSink(short data)
{
    {
        --data;
        short result = data;
        printIntLine(result);
    }
}
void var()
{
    short data;
    data = 0;
    data = (short)RAND32();
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(short data)
{
    {
        --data;
        short result = data;
        printIntLine(result);
    }
}
static void goodG2B()
{
    short data;
    data = 0;
    data = -2;
    goodG2BSink(data);
}
static void goodB2GSink(short data)
{
    if (data > SHRT_MIN)
    {
        --data;
        short result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodB2G()
{
    short data;
    data = 0;
    data = (short)RAND32();
    goodB2GSink(data);
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_min_multiply_13.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = LLONG_MIN;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = LLONG_MIN;
    }
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data < 0) 
        {
            if (data > (LLONG_MIN/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = LLONG_MIN;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data < 0) 
        {
            if (data > (LLONG_MIN/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = -2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_listen_socket_predec_15.c,CWE191,bad,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    switch(6)
    {
    case 6:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        --data;
        int result = data;
        printIntLine(result);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    switch(6)
    {
    case 6:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(8)
    {
    case 7:
        printLine(""Benign, fixed string"");
        break;
    default:
        if (data > INT_MIN)
        {
            --data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
        break;
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    switch(6)
    {
    case 6:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        if (data > INT_MIN)
        {
            --data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        data = -2;
        break;
    }
    switch(7)
    {
    case 7:
    {
        --data;
        int result = data;
        printIntLine(result);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    switch(6)
    {
    case 6:
        data = -2;
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        --data;
        int result = data;
        printIntLine(result);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_min_postdec_01.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    data = 0;
    {
        data--;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = -2;
    {
        data--;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
static void goodB2G()
{
    unsigned int data;
    data = 0;
    data = 0;
    if (data > 0)
    {
        data--;
        unsigned int result = data;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_listen_socket_sub_03.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(5==5)
    {
        {
            int result = data - 1;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN)
        {
            int result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(5==5)
    {
        if (data > INT_MIN)
        {
            int result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(5==5)
    {
        {
            int result = data - 1;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(5==5)
    {
        data = -2;
    }
    if(5==5)
    {
        {
            int result = data - 1;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_rand_predec_32.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    int64_t *dataPtr1 = &data;
    int64_t *dataPtr2 = &data;
    data = 0LL;
    {
        int64_t data = *dataPtr1;
        data = (int64_t)RAND64();
        *dataPtr1 = data;
    }
    {
        int64_t data = *dataPtr2;
        {
            --data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int64_t data;
    int64_t *dataPtr1 = &data;
    int64_t *dataPtr2 = &data;
    data = 0LL;
    {
        int64_t data = *dataPtr1;
        data = -2;
        *dataPtr1 = data;
    }
    {
        int64_t data = *dataPtr2;
        {
            --data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
static void goodB2G()
{
    int64_t data;
    int64_t *dataPtr1 = &data;
    int64_t *dataPtr2 = &data;
    data = 0LL;
    {
        int64_t data = *dataPtr1;
        data = (int64_t)RAND64();
        *dataPtr1 = data;
    }
    {
        int64_t data = *dataPtr2;
        if (data > LLONG_MIN)
        {
            --data;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_min_postdec_54e.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data)
{
    {
        data--;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    {
        data--;
        int result = data;
        printIntLine(result);
    }
}
void var(int data)
{
    if (data > INT_MIN)
    {
        data--;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__int64_t_min_postdec_54e.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data)
{
    {
        data--;
        int64_t result = data;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int64_t data)
{
    {
        data--;
        int64_t result = data;
        printLongLongLine(result);
    }
}
void var(int64_t data)
{
    if (data > LLONG_MIN)
    {
        data--;
        int64_t result = data;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__int_min_sub_14.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        data = INT_MIN;
    }
    if(globalFive==5)
    {
        {
            int result = data - 1;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        data = INT_MIN;
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN)
        {
            int result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        data = INT_MIN;
    }
    if(globalFive==5)
    {
        if (data > INT_MIN)
        {
            int result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(globalFive==5)
    {
        {
            int result = data - 1;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        data = -2;
    }
    if(globalFive==5)
    {
        {
            int result = data - 1;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_fscanf_sub_65a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data);
void var()
{
    short data;
    void (*funcPtr) (short) = var;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(short data);
static void goodG2B()
{
    short data;
    void (*funcPtr) (short) = var;
    data = 0;
    data = -2;
    funcPtr(data);
}
void var(short data);
static void goodB2G()
{
    short data;
    void (*funcPtr) (short) = var;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_min_multiply_03.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(5==5)
    {
        data = LLONG_MIN;
    }
    if(5==5)
    {
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(5==5)
    {
        data = LLONG_MIN;
    }
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data < 0) 
        {
            if (data > (LLONG_MIN/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(5==5)
    {
        data = LLONG_MIN;
    }
    if(5==5)
    {
        if(data < 0) 
        {
            if (data > (LLONG_MIN/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(5==5)
    {
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(5==5)
    {
        data = -2;
    }
    if(5==5)
    {
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_min_multiply_42.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
static short badSource(short data)
{
    data = SHRT_MIN;
    return data;
}
void var()
{
    short data;
    data = 0;
    data = badSource(data);
    if(data < 0) 
    {
        short result = data * 2;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static short goodG2BSource(short data)
{
    data = -2;
    return data;
}
static void goodG2B()
{
    short data;
    data = 0;
    data = goodG2BSource(data);
    if(data < 0) 
    {
        short result = data * 2;
        printIntLine(result);
    }
}
static short goodB2GSource(short data)
{
    data = SHRT_MIN;
    return data;
}
static void goodB2G()
{
    short data;
    data = 0;
    data = goodB2GSource(data);
    if(data < 0) 
    {
        if (data > (SHRT_MIN/2))
        {
            short result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_min_predec_54d.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data);
void var(short data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(short data);
void var(short data)
{
    var(data);
}
void var(short data);
void var(short data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__short_rand_predec_13.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = (short)RAND32();
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            --data;
            short result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    short data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = (short)RAND32();
    }
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > SHRT_MIN)
        {
            --data;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = (short)RAND32();
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if (data > SHRT_MIN)
        {
            --data;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    short data;
    data = 0;
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            --data;
            short result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    short data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = -2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            --data;
            short result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_predec_65a.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data);
void var()
{
    int data;
    void (*funcPtr) (int) = var;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
static void goodG2B()
{
    int data;
    void (*funcPtr) (int) = var;
    data = 0;
    data = -2;
    funcPtr(data);
}
void var(int data);
static void goodB2G()
{
    int data;
    void (*funcPtr) (int) = var;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_listen_socket_predec_10.c,CWE191,bad,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalTrue)
    {
        {
            --data;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(globalTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN)
        {
            --data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(globalTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalTrue)
    {
        if (data > INT_MIN)
        {
            --data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(globalTrue)
    {
        {
            --data;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(globalTrue)
    {
        data = -2;
    }
    if(globalTrue)
    {
        {
            --data;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_fscanf_multiply_44.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
static void badSink(char data)
{
    if(data < 0) 
    {
        char result = data * 2;
        printHexCharLine(result);
    }
}
void var()
{
    char data;
    void (*funcPtr) (char) = badSink;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(char data)
{
    if(data < 0) 
    {
        char result = data * 2;
        printHexCharLine(result);
    }
}
static void goodG2B()
{
    char data;
    void (*funcPtr) (char) = goodG2BSink;
    data = ' ';
    data = -2;
    funcPtr(data);
}
static void goodB2GSink(char data)
{
    if(data < 0) 
    {
        if (data > (CHAR_MIN/2))
        {
            char result = data * 2;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
static void goodB2G()
{
    char data;
    void (*funcPtr) (char) = goodB2GSink;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_fscanf_sub_05.c,CWE191,bad,"#include <inttypes.h>
#include ""std_testcase.h""
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(staticTrue)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(staticTrue)
    {
        {
            int64_t result = data - 1;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(staticTrue)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > LLONG_MIN)
        {
            int64_t result = data - 1;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(staticTrue)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(staticTrue)
    {
        if (data > LLONG_MIN)
        {
            int64_t result = data - 1;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(staticTrue)
    {
        {
            int64_t result = data - 1;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(staticTrue)
    {
        data = -2;
    }
    if(staticTrue)
    {
        {
            int64_t result = data - 1;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_rand_predec_66a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char dataArray[]);
void var()
{
    char data;
    char dataArray[5];
    data = ' ';
    data = (char)RAND32();
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(char dataArray[]);
static void goodG2B()
{
    char data;
    char dataArray[5];
    data = ' ';
    data = -2;
    dataArray[2] = data;
    var(dataArray);
}
void var(char dataArray[]);
static void goodB2G()
{
    char data;
    char dataArray[5];
    data = ' ';
    data = (char)RAND32();
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_rand_predec_09.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        data = RAND32();
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            --data;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        data = RAND32();
    }
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN)
        {
            --data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        data = RAND32();
    }
    if(GLOBAL_CONST_TRUE)
    {
        if (data > INT_MIN)
        {
            --data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            --data;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        data = -2;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            --data;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_sub_44.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
static void badSink(int data)
{
    {
        int result = data - 1;
        printIntLine(result);
    }
}
void var()
{
    int data;
    void (*funcPtr) (int) = badSink;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(int data)
{
    {
        int result = data - 1;
        printIntLine(result);
    }
}
static void goodG2B()
{
    int data;
    void (*funcPtr) (int) = goodG2BSink;
    data = 0;
    data = -2;
    funcPtr(data);
}
static void goodB2GSink(int data)
{
    if (data > INT_MIN)
    {
        int result = data - 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
static void goodB2G()
{
    int data;
    void (*funcPtr) (int) = goodB2GSink;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_sub_66a.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int dataArray[]);
void var()
{
    int data;
    int dataArray[5];
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(int dataArray[]);
static void goodG2B()
{
    int data;
    int dataArray[5];
    data = 0;
    data = -2;
    dataArray[2] = data;
    var(dataArray);
}
void var(int dataArray[]);
static void goodB2G()
{
    int data;
    int dataArray[5];
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_fscanf_multiply_53a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data);
void var()
{
    int64_t data;
    data = 0LL;
    fscanf (stdin, ""%lld"", &data);
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t data);
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = -2;
    var(data);
}
void var(int64_t data);
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    fscanf (stdin, ""%lld"", &data);
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_sub_53d.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data)
{
    {
        int result = data - 1;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    {
        int result = data - 1;
        printIntLine(result);
    }
}
void var(int data)
{
    if (data > INT_MIN)
    {
        int result = data - 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
#endif"
CWE191_Integer_Underflow__int64_t_fscanf_multiply_15.c,CWE191,bad,"#include <inttypes.h>
#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    switch(6)
    {
    case 6:
        fscanf (stdin, ""%"" SCNd64, &data);
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    switch(6)
    {
    case 6:
        fscanf (stdin, ""%"" SCNd64, &data);
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(8)
    {
    case 7:
        printLine(""Benign, fixed string"");
        break;
    default:
        if(data < 0) 
        {
            if (data > (LLONG_MIN/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
        break;
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    switch(6)
    {
    case 6:
        fscanf (stdin, ""%"" SCNd64, &data);
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        if(data < 0) 
        {
            if (data > (LLONG_MIN/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        data = -2;
        break;
    }
    switch(7)
    {
    case 7:
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    switch(6)
    {
    case 6:
        data = -2;
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_postdec_34.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
typedef union
{
    int unionFirst;
    int unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    int data;
    var myUnion;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int data;
    var myUnion;
    data = 0;
    data = -2;
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodB2G()
{
    int data;
    var myUnion;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        if (data > INT_MIN)
        {
            data--;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_fscanf_multiply_53c.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data);
void var(short data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(short data);
void var(short data)
{
    var(data);
}
void var(short data);
void var(short data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_predec_51b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data)
{
    {
        --data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data)
{
    {
        --data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
void var(unsigned int data)
{
    if (data > 0)
    {
        --data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__char_fscanf_multiply_65b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data)
{
    if(data < 0) 
    {
        char result = data * 2;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(char data)
{
    if(data < 0) 
    {
        char result = data * 2;
        printHexCharLine(result);
    }
}
void var(char data)
{
    if(data < 0) 
    {
        if (data > (CHAR_MIN/2))
        {
            char result = data * 2;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
#endif"
CWE191_Integer_Underflow__int_listen_socket_predec_63b.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int * dataPtr)
{
    int data = *dataPtr;
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int * dataPtr)
{
    int data = *dataPtr;
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
void var(int * dataPtr)
{
    int data = *dataPtr;
    if (data > INT_MIN)
    {
        --data;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__short_rand_predec_17.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int i,j;
    short data;
    data = 0;
    for(i = 0; i < 1; i++)
    {
        data = (short)RAND32();
    }
    for(j = 0; j < 1; j++)
    {
        {
            --data;
            short result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int i,k;
    short data;
    data = 0;
    for(i = 0; i < 1; i++)
    {
        data = (short)RAND32();
    }
    for(k = 0; k < 1; k++)
    {
        if (data > SHRT_MIN)
        {
            --data;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B()
{
    int h,j;
    short data;
    data = 0;
    for(h = 0; h < 1; h++)
    {
        data = -2;
    }
    for(j = 0; j < 1; j++)
    {
        {
            --data;
            short result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_fscanf_postdec_34.c,CWE191,good,"#include ""std_testcase.h""
typedef union
{
    int unionFirst;
    int unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    int data;
    var myUnion;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int data;
    var myUnion;
    data = 0;
    data = -2;
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodB2G()
{
    int data;
    var myUnion;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        if (data > INT_MIN)
        {
            data--;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_fscanf_multiply_54c.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data);
void var(char data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char data);
void var(char data)
{
    var(data);
}
void var(char data);
void var(char data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__int64_t_min_postdec_53c.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_postdec_21.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
static int badStatic = 0;
static void badSink(int data)
{
    if(badStatic)
    {
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    badStatic = 1; 
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static int goodB2G1Static = 0;
static int goodB2G2Static = 0;
static int goodG2BStatic = 0;
static void goodB2G1Sink(int data)
{
    if(goodB2G1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN)
        {
            data--;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G1()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    goodB2G1Static = 0; 
    goodB2G1Sink(data);
}
static void goodB2G2Sink(int data)
{
    if(goodB2G2Static)
    {
        if (data > INT_MIN)
        {
            data--;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    goodB2G2Static = 1; 
    goodB2G2Sink(data);
}
static void goodG2BSink(int data)
{
    if(goodG2BStatic)
    {
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    data = -2;
    goodG2BStatic = 1; 
    goodG2BSink(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_min_multiply_66a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int dataArray[]);
void var()
{
    int data;
    int dataArray[5];
    data = 0;
    data = INT_MIN;
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(int dataArray[]);
static void goodG2B()
{
    int data;
    int dataArray[5];
    data = 0;
    data = -2;
    dataArray[2] = data;
    var(dataArray);
}
void var(int dataArray[]);
static void goodB2G()
{
    int data;
    int dataArray[5];
    data = 0;
    data = INT_MIN;
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_rand_sub_06.c,CWE191,good,"#include ""std_testcase.h""
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(STATIC_CONST_FIVE==5)
    {
        data = (char)RAND32();
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            char result = data - 1;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(STATIC_CONST_FIVE==5)
    {
        data = (char)RAND32();
    }
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > CHAR_MIN)
        {
            char result = data - 1;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(STATIC_CONST_FIVE==5)
    {
        data = (char)RAND32();
    }
    if(STATIC_CONST_FIVE==5)
    {
        if (data > CHAR_MIN)
        {
            char result = data - 1;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            char result = data - 1;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(STATIC_CONST_FIVE==5)
    {
        data = -2;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            char result = data - 1;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_rand_multiply_54b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data);
void var(short data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(short data);
void var(short data)
{
    var(data);
}
void var(short data);
void var(short data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_predec_51a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data);
void var()
{
    unsigned int data;
    data = 0;
    data = (unsigned int)RAND32();
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data);
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = -2;
    var(data);
}
void var(unsigned int data);
static void goodB2G()
{
    unsigned int data;
    data = 0;
    data = (unsigned int)RAND32();
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_min_sub_52a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data);
void var()
{
    char data;
    data = ' ';
    data = CHAR_MIN;
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char data);
static void goodG2B()
{
    char data;
    data = ' ';
    data = -2;
    var(data);
}
void var(char data);
static void goodB2G()
{
    char data;
    data = ' ';
    data = CHAR_MIN;
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_min_multiply_53c.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__int64_t_rand_predec_07.c,CWE191,bad,"#include ""std_testcase.h""
static int staticFive = 5;
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(staticFive==5)
    {
        data = (int64_t)RAND64();
    }
    if(staticFive==5)
    {
        {
            --data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(staticFive==5)
    {
        data = (int64_t)RAND64();
    }
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > LLONG_MIN)
        {
            --data;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(staticFive==5)
    {
        data = (int64_t)RAND64();
    }
    if(staticFive==5)
    {
        if (data > LLONG_MIN)
        {
            --data;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(staticFive==5)
    {
        {
            --data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(staticFive==5)
    {
        data = -2;
    }
    if(staticFive==5)
    {
        {
            --data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_rand_predec_65a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data);
void var()
{
    int64_t data;
    void (*funcPtr) (int64_t) = var;
    data = 0LL;
    data = (int64_t)RAND64();
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t data);
static void goodG2B()
{
    int64_t data;
    void (*funcPtr) (int64_t) = var;
    data = 0LL;
    data = -2;
    funcPtr(data);
}
void var(int64_t data);
static void goodB2G()
{
    int64_t data;
    void (*funcPtr) (int64_t) = var;
    data = 0LL;
    data = (int64_t)RAND64();
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_min_predec_09.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        data = CHAR_MIN;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        data = CHAR_MIN;
    }
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > CHAR_MIN)
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        data = CHAR_MIN;
    }
    if(GLOBAL_CONST_TRUE)
    {
        if (data > CHAR_MIN)
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        data = -2;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_rand_postdec_67a.c,CWE191,good,"#include ""std_testcase.h""
typedef struct _CWE191_Integer_Underflow__char_rand_postdec_67_structType
{
    char structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct);
void var()
{
    char data;
    var myStruct;
    data = ' ';
    data = (char)RAND32();
    myStruct.structFirst = data;
    var(myStruct);
}
#endif 
#ifndef OMITGOOD
void var(var myStruct);
static void goodG2B()
{
    char data;
    var myStruct;
    data = ' ';
    data = -2;
    myStruct.structFirst = data;
    var(myStruct);
}
void var(var myStruct);
static void goodB2G()
{
    char data;
    var myStruct;
    data = ' ';
    data = (char)RAND32();
    myStruct.structFirst = data;
    var(myStruct);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_min_multiply_52c.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data)
{
    if(data < 0) 
    {
        int64_t result = data * 2;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int64_t data)
{
    if(data < 0) 
    {
        int64_t result = data * 2;
        printLongLongLine(result);
    }
}
void var(int64_t data)
{
    if(data < 0) 
    {
        if (data > (LLONG_MIN/2))
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
#endif"
CWE191_Integer_Underflow__int64_t_min_multiply_53d.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data)
{
    if(data < 0) 
    {
        int64_t result = data * 2;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int64_t data)
{
    if(data < 0) 
    {
        int64_t result = data * 2;
        printLongLongLine(result);
    }
}
void var(int64_t data)
{
    if(data < 0) 
    {
        if (data > (LLONG_MIN/2))
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
#endif"
CWE191_Integer_Underflow__int_fscanf_predec_53a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data);
void var()
{
    int data;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = -2;
    var(data);
}
void var(int data);
static void goodB2G()
{
    int data;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_rand_sub_52a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data);
void var()
{
    char data;
    data = ' ';
    data = (char)RAND32();
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char data);
static void goodG2B()
{
    char data;
    data = ' ';
    data = -2;
    var(data);
}
void var(char data);
static void goodB2G()
{
    char data;
    data = ' ';
    data = (char)RAND32();
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_min_sub_22b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
extern int var;
void var(int data)
{
    if(var)
    {
        {
            int result = data - 1;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
extern int var;
extern int var;
extern int var;
void var(int data)
{
    if(var)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN)
        {
            int result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
void var(int data)
{
    if(var)
    {
        if (data > INT_MIN)
        {
            int result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
void var(int data)
{
    if(var)
    {
        {
            int result = data - 1;
            printIntLine(result);
        }
    }
}
#endif"
CWE191_Integer_Underflow__int_fscanf_predec_68a.c,CWE191,good,"#include ""std_testcase.h""
int var;
int var;
int var;
#ifndef OMITBAD
void var();
void var()
{
    int data;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    var = data;
    var();
}
#endif 
#ifndef OMITGOOD
void var();
void var();
static void goodG2B()
{
    int data;
    data = 0;
    data = -2;
    var = data;
    var();
}
static void goodB2G()
{
    int data;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    var = data;
    var();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_min_postdec_61a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
int64_t var(int64_t data);
void var()
{
    int64_t data;
    data = 0LL;
    data = var(data);
    {
        data--;
        int64_t result = data;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
int64_t var(int64_t data);
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = var(data);
    {
        data--;
        int64_t result = data;
        printLongLongLine(result);
    }
}
int64_t var(int64_t data);
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    data = var(data);
    if (data > LLONG_MIN)
    {
        data--;
        int64_t result = data;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_rand_sub_53d.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data)
{
    {
        int64_t result = data - 1;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int64_t data)
{
    {
        int64_t result = data - 1;
        printLongLongLine(result);
    }
}
void var(int64_t data)
{
    if (data > LLONG_MIN)
    {
        int64_t result = data - 1;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
#endif"
CWE191_Integer_Underflow__int64_t_min_sub_63a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * dataPtr);
void var()
{
    int64_t data;
    data = 0LL;
    data = LLONG_MIN;
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t * data);
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = -2;
    var(&data);
}
void var(int64_t * data);
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    data = LLONG_MIN;
    var(&data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_rand_postdec_17.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int i,j;
    char data;
    data = ' ';
    for(i = 0; i < 1; i++)
    {
        data = (char)RAND32();
    }
    for(j = 0; j < 1; j++)
    {
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int i,k;
    char data;
    data = ' ';
    for(i = 0; i < 1; i++)
    {
        data = (char)RAND32();
    }
    for(k = 0; k < 1; k++)
    {
        if (data > CHAR_MIN)
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B()
{
    int h,j;
    char data;
    data = ' ';
    for(h = 0; h < 1; h++)
    {
        data = -2;
    }
    for(j = 0; j < 1; j++)
    {
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_min_sub_07.c,CWE191,bad,"#include ""std_testcase.h""
static int staticFive = 5;
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(staticFive==5)
    {
        data = 0;
    }
    if(staticFive==5)
    {
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(staticFive==5)
    {
        data = 0;
    }
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > 0)
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(staticFive==5)
    {
        data = 0;
    }
    if(staticFive==5)
    {
        if (data > 0)
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(staticFive==5)
    {
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(staticFive==5)
    {
        data = -2;
    }
    if(staticFive==5)
    {
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_fgets_postdec_16.c,CWE191,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    while(1)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
        break;
    }
    while(1)
    {
        {
            data--;
            int result = data;
            printIntLine(result);
        }
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int data;
    data = 0;
    while(1)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
        break;
    }
    while(1)
    {
        if (data > INT_MIN)
        {
            data--;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
        break;
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    while(1)
    {
        data = -2;
        break;
    }
    while(1)
    {
        {
            data--;
            int result = data;
            printIntLine(result);
        }
        break;
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_predec_08.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticReturnsTrue())
    {
        {
            --data;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN)
        {
            --data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticReturnsTrue())
    {
        if (data > INT_MIN)
        {
            --data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(staticReturnsTrue())
    {
        {
            --data;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        data = -2;
    }
    if(staticReturnsTrue())
    {
        {
            --data;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_min_sub_61b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
unsigned int var(unsigned int data)
{
    data = 0;
    return data;
}
#endif 
#ifndef OMITGOOD
unsigned int var(unsigned int data)
{
    data = -2;
    return data;
}
unsigned int var(unsigned int data)
{
    data = 0;
    return data;
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_multiply_41.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
static void badSink(int data)
{
    if(data < 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
void var()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(int data)
{
    if(data < 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    data = -2;
    goodG2BSink(data);
}
static void goodB2GSink(int data)
{
    if(data < 0) 
    {
        if (data > (INT_MIN/2))
        {
            int result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
static void goodB2G()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    goodB2GSink(data);
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_53a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data);
void var()
{
    unsigned int data;
    data = 0;
    fscanf (stdin, ""%u"", &data);
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data);
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = -2;
    var(data);
}
void var(unsigned int data);
static void goodB2G()
{
    unsigned int data;
    data = 0;
    fscanf (stdin, ""%u"", &data);
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_multiply_54d.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__char_rand_predec_53c.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data);
void var(char data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char data);
void var(char data)
{
    var(data);
}
void var(char data);
void var(char data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__int64_t_rand_multiply_03.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(5==5)
    {
        data = (int64_t)RAND64();
    }
    if(5==5)
    {
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(5==5)
    {
        data = (int64_t)RAND64();
    }
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data < 0) 
        {
            if (data > (LLONG_MIN/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(5==5)
    {
        data = (int64_t)RAND64();
    }
    if(5==5)
    {
        if(data < 0) 
        {
            if (data > (LLONG_MIN/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(5==5)
    {
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(5==5)
    {
        data = -2;
    }
    if(5==5)
    {
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_multiply_52a.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data);
void var()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = -2;
    var(data);
}
void var(int data);
static void goodB2G()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_fgets_predec_22b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
extern int var;
void var(int data)
{
    if(var)
    {
        {
            --data;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
extern int var;
extern int var;
extern int var;
void var(int data)
{
    if(var)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN)
        {
            --data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var(int data)
{
    if(var)
    {
        if (data > INT_MIN)
        {
            --data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var(int data)
{
    if(var)
    {
        {
            --data;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif"
CWE191_Integer_Underflow__int_rand_multiply_64b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    int * dataPtr = (int *)dataVoidPtr;
    int data = (*dataPtr);
    if(data < 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    int * dataPtr = (int *)dataVoidPtr;
    int data = (*dataPtr);
    if(data < 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
void var(void * dataVoidPtr)
{
    int * dataPtr = (int *)dataVoidPtr;
    int data = (*dataPtr);
    if(data < 0) 
    {
        if (data > (INT_MIN/2))
        {
            int result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
#endif"
CWE191_Integer_Underflow__int_listen_socket_sub_65b.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data)
{
    {
        int result = data - 1;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    {
        int result = data - 1;
        printIntLine(result);
    }
}
void var(int data)
{
    if (data > INT_MIN)
    {
        int result = data - 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
#endif"
CWE191_Integer_Underflow__int64_t_min_postdec_21.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
static int badStatic = 0;
static void badSink(int64_t data)
{
    if(badStatic)
    {
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
void var()
{
    int64_t data;
    data = 0LL;
    data = LLONG_MIN;
    badStatic = 1; 
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static int goodB2G1Static = 0;
static int goodB2G2Static = 0;
static int goodG2BStatic = 0;
static void goodB2G1Sink(int64_t data)
{
    if(goodB2G1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > LLONG_MIN)
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    data = LLONG_MIN;
    goodB2G1Static = 0; 
    goodB2G1Sink(data);
}
static void goodB2G2Sink(int64_t data)
{
    if(goodB2G2Static)
    {
        if (data > LLONG_MIN)
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    data = LLONG_MIN;
    goodB2G2Static = 1; 
    goodB2G2Sink(data);
}
static void goodG2BSink(int64_t data)
{
    if(goodG2BStatic)
    {
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = -2;
    goodG2BStatic = 1; 
    goodG2BSink(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_rand_multiply_18.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    goto source;
source:
    data = (short)RAND32();
    goto sink;
sink:
    if(data < 0) 
    {
        short result = data * 2;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    short data;
    data = 0;
    goto source;
source:
    data = (short)RAND32();
    goto sink;
sink:
    if(data < 0) 
    {
        if (data > (SHRT_MIN/2))
        {
            short result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
static void goodG2B()
{
    short data;
    data = 0;
    goto source;
source:
    data = -2;
    goto sink;
sink:
    if(data < 0) 
    {
        short result = data * 2;
        printIntLine(result);
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_predec_18.c,CWE191,bad,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    goto source;
source:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    goto sink;
sink:
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int data;
    data = 0;
    goto source;
source:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    goto sink;
sink:
    if (data > INT_MIN)
    {
        --data;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    goto source;
source:
    data = -2;
    goto sink;
sink:
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_listen_socket_multiply_18.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    goto source;
source:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    goto sink;
sink:
    if(data < 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int data;
    data = 0;
    goto source;
source:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    goto sink;
sink:
    if(data < 0) 
    {
        if (data > (INT_MIN/2))
        {
            int result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    goto source;
source:
    data = -2;
    goto sink;
sink:
    if(data < 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_rand_multiply_67a.c,CWE191,good,"#include ""std_testcase.h""
typedef struct _CWE191_Integer_Underflow__int_rand_multiply_67_structType
{
    int structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct);
void var()
{
    int data;
    var myStruct;
    data = 0;
    data = RAND32();
    myStruct.structFirst = data;
    var(myStruct);
}
#endif 
#ifndef OMITGOOD
void var(var myStruct);
static void goodG2B()
{
    int data;
    var myStruct;
    data = 0;
    data = -2;
    myStruct.structFirst = data;
    var(myStruct);
}
void var(var myStruct);
static void goodB2G()
{
    int data;
    var myStruct;
    data = 0;
    data = RAND32();
    myStruct.structFirst = data;
    var(myStruct);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_fgets_multiply_04.c,CWE191,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
static const int STATIC_CONST_TRUE = 1; 
static const int STATIC_CONST_FALSE = 0; 
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(STATIC_CONST_TRUE)
    {
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data < 0) 
        {
            if (data > (INT_MIN/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(STATIC_CONST_TRUE)
    {
        if(data < 0) 
        {
            if (data > (INT_MIN/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(STATIC_CONST_TRUE)
    {
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        data = -2;
    }
    if(STATIC_CONST_TRUE)
    {
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_fscanf_predec_01.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    fscanf (stdin, ""%u"", &data);
    {
        --data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = -2;
    {
        --data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
static void goodB2G()
{
    unsigned int data;
    data = 0;
    fscanf (stdin, ""%u"", &data);
    if (data > 0)
    {
        --data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_min_sub_65a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data);
void var()
{
    int data;
    void (*funcPtr) (int) = var;
    data = 0;
    data = INT_MIN;
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
static void goodG2B()
{
    int data;
    void (*funcPtr) (int) = var;
    data = 0;
    data = -2;
    funcPtr(data);
}
void var(int data);
static void goodB2G()
{
    int data;
    void (*funcPtr) (int) = var;
    data = 0;
    data = INT_MIN;
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_min_multiply_13.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_FIVE==5)
    {
        data = CHAR_MIN;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data < 0) 
        {
            char result = data * 2;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_FIVE==5)
    {
        data = CHAR_MIN;
    }
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data < 0) 
        {
            if (data > (CHAR_MIN/2))
            {
                char result = data * 2;
                printHexCharLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_FIVE==5)
    {
        data = CHAR_MIN;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data < 0) 
        {
            if (data > (CHAR_MIN/2))
            {
                char result = data * 2;
                printHexCharLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data < 0) 
        {
            char result = data * 2;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_FIVE==5)
    {
        data = -2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data < 0) 
        {
            char result = data * 2;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_listen_socket_predec_53b.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_sub_61b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
unsigned int var(unsigned int data)
{
    data = (unsigned int)RAND32();
    return data;
}
#endif 
#ifndef OMITGOOD
unsigned int var(unsigned int data)
{
    data = -2;
    return data;
}
unsigned int var(unsigned int data)
{
    data = (unsigned int)RAND32();
    return data;
}
#endif"
CWE191_Integer_Underflow__int64_t_rand_multiply_12.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(globalReturnsTrueOrFalse())
    {
        data = (int64_t)RAND64();
    }
    else
    {
        data = -2;
    }
    if(globalReturnsTrueOrFalse())
    {
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
    else
    {
        if(data < 0) 
        {
            if (data > (LLONG_MIN/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    if(globalReturnsTrueOrFalse())
    {
        data = (int64_t)RAND64();
    }
    else
    {
        data = (int64_t)RAND64();
    }
    if(globalReturnsTrueOrFalse())
    {
        if(data < 0) 
        {
            if (data > (LLONG_MIN/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
    else
    {
        if(data < 0) 
        {
            if (data > (LLONG_MIN/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    if(globalReturnsTrueOrFalse())
    {
        data = -2;
    }
    else
    {
        data = -2;
    }
    if(globalReturnsTrueOrFalse())
    {
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
    else
    {
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_min_multiply_54c.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data);
void var(short data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(short data);
void var(short data)
{
    var(data);
}
void var(short data);
void var(short data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__unsigned_int_min_sub_10.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(globalTrue)
    {
        data = 0;
    }
    if(globalTrue)
    {
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(globalTrue)
    {
        data = 0;
    }
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > 0)
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(globalTrue)
    {
        data = 0;
    }
    if(globalTrue)
    {
        if (data > 0)
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(globalTrue)
    {
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(globalTrue)
    {
        data = -2;
    }
    if(globalTrue)
    {
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_fscanf_multiply_66b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char dataArray[])
{
    char data = dataArray[2];
    if(data < 0) 
    {
        char result = data * 2;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(char dataArray[])
{
    char data = dataArray[2];
    if(data < 0) 
    {
        char result = data * 2;
        printHexCharLine(result);
    }
}
void var(char dataArray[])
{
    char data = dataArray[2];
    if(data < 0) 
    {
        if (data > (CHAR_MIN/2))
        {
            char result = data * 2;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
#endif"
CWE191_Integer_Underflow__short_min_postdec_63b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short * dataPtr)
{
    short data = *dataPtr;
    {
        data--;
        short result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(short * dataPtr)
{
    short data = *dataPtr;
    {
        data--;
        short result = data;
        printIntLine(result);
    }
}
void var(short * dataPtr)
{
    short data = *dataPtr;
    if (data > SHRT_MIN)
    {
        data--;
        short result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_predec_66b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int dataArray[])
{
    unsigned int data = dataArray[2];
    {
        --data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(unsigned int dataArray[])
{
    unsigned int data = dataArray[2];
    {
        --data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
void var(unsigned int dataArray[])
{
    unsigned int data = dataArray[2];
    if (data > 0)
    {
        --data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__int_listen_socket_multiply_64b.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    int * dataPtr = (int *)dataVoidPtr;
    int data = (*dataPtr);
    if(data < 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    int * dataPtr = (int *)dataVoidPtr;
    int data = (*dataPtr);
    if(data < 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
void var(void * dataVoidPtr)
{
    int * dataPtr = (int *)dataVoidPtr;
    int data = (*dataPtr);
    if(data < 0) 
    {
        if (data > (INT_MIN/2))
        {
            int result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
#endif"
CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_67a.c,CWE191,good,"#include ""std_testcase.h""
typedef struct _CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_67_structType
{
    unsigned int structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct);
void var()
{
    unsigned int data;
    var myStruct;
    data = 0;
    fscanf (stdin, ""%u"", &data);
    myStruct.structFirst = data;
    var(myStruct);
}
#endif 
#ifndef OMITGOOD
void var(var myStruct);
static void goodG2B()
{
    unsigned int data;
    var myStruct;
    data = 0;
    data = -2;
    myStruct.structFirst = data;
    var(myStruct);
}
void var(var myStruct);
static void goodB2G()
{
    unsigned int data;
    var myStruct;
    data = 0;
    fscanf (stdin, ""%u"", &data);
    myStruct.structFirst = data;
    var(myStruct);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_min_sub_53c.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data);
void var(short data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(short data);
void var(short data)
{
    var(data);
}
void var(short data);
void var(short data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__unsigned_int_min_predec_52b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__char_min_multiply_51b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data)
{
    if(data < 0) 
    {
        char result = data * 2;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(char data)
{
    if(data < 0) 
    {
        char result = data * 2;
        printHexCharLine(result);
    }
}
void var(char data)
{
    if(data < 0) 
    {
        if (data > (CHAR_MIN/2))
        {
            char result = data * 2;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
#endif"
CWE191_Integer_Underflow__char_fscanf_predec_01.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    {
        --data;
        char result = data;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char data;
    data = ' ';
    data = -2;
    {
        --data;
        char result = data;
        printHexCharLine(result);
    }
}
static void goodB2G()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    if (data > CHAR_MIN)
    {
        --data;
        char result = data;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_rand_postdec_51a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data);
void var()
{
    char data;
    data = ' ';
    data = (char)RAND32();
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char data);
static void goodG2B()
{
    char data;
    data = ' ';
    data = -2;
    var(data);
}
void var(char data);
static void goodB2G()
{
    char data;
    data = ' ';
    data = (char)RAND32();
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_listen_socket_multiply_22b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
extern int var;
void var(int data)
{
    if(var)
    {
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
extern int var;
extern int var;
extern int var;
void var(int data)
{
    if(var)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data < 0) 
        {
            if (data > (INT_MIN/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
void var(int data)
{
    if(var)
    {
        if(data < 0) 
        {
            if (data > (INT_MIN/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
void var(int data)
{
    if(var)
    {
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
#endif"
CWE191_Integer_Underflow__short_min_postdec_52c.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data)
{
    {
        data--;
        short result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(short data)
{
    {
        data--;
        short result = data;
        printIntLine(result);
    }
}
void var(short data)
{
    if (data > SHRT_MIN)
    {
        data--;
        short result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__int_fscanf_postdec_08.c,CWE191,good,"#include ""std_testcase.h""
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(staticReturnsTrue())
    {
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN)
        {
            data--;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(staticReturnsTrue())
    {
        if (data > INT_MIN)
        {
            data--;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(staticReturnsTrue())
    {
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        data = -2;
    }
    if(staticReturnsTrue())
    {
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_min_sub_65b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data)
{
    {
        char result = data - 1;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(char data)
{
    {
        char result = data - 1;
        printHexCharLine(result);
    }
}
void var(char data)
{
    if (data > CHAR_MIN)
    {
        char result = data - 1;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
#endif"
CWE191_Integer_Underflow__short_rand_multiply_13.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = (short)RAND32();
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data < 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    short data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = (short)RAND32();
    }
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data < 0) 
        {
            if (data > (SHRT_MIN/2))
            {
                short result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = (short)RAND32();
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data < 0) 
        {
            if (data > (SHRT_MIN/2))
            {
                short result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodG2B1()
{
    short data;
    data = 0;
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data < 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    short data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = -2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data < 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_min_sub_22b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
extern int var;
void var(short data)
{
    if(var)
    {
        {
            short result = data - 1;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
extern int var;
extern int var;
extern int var;
void var(short data)
{
    if(var)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > SHRT_MIN)
        {
            short result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
void var(short data)
{
    if(var)
    {
        if (data > SHRT_MIN)
        {
            short result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
void var(short data)
{
    if(var)
    {
        {
            short result = data - 1;
            printIntLine(result);
        }
    }
}
#endif"
CWE191_Integer_Underflow__short_fscanf_predec_03.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    if(5==5)
    {
        fscanf (stdin, ""%hd"", &data);
    }
    if(5==5)
    {
        {
            --data;
            short result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    short data;
    data = 0;
    if(5==5)
    {
        fscanf (stdin, ""%hd"", &data);
    }
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > SHRT_MIN)
        {
            --data;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    if(5==5)
    {
        fscanf (stdin, ""%hd"", &data);
    }
    if(5==5)
    {
        if (data > SHRT_MIN)
        {
            --data;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    short data;
    data = 0;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(5==5)
    {
        {
            --data;
            short result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    short data;
    data = 0;
    if(5==5)
    {
        data = -2;
    }
    if(5==5)
    {
        {
            --data;
            short result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_rand_sub_65b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data)
{
    {
        int result = data - 1;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    {
        int result = data - 1;
        printIntLine(result);
    }
}
void var(int data)
{
    if (data > INT_MIN)
    {
        int result = data - 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
#endif"
CWE191_Integer_Underflow__char_rand_sub_45.c,CWE191,bad,"#include ""std_testcase.h""
static char var;
static char var;
static char var;
#ifndef OMITBAD
static void badSink()
{
    char data = var;
    {
        char result = data - 1;
        printHexCharLine(result);
    }
}
void var()
{
    char data;
    data = ' ';
    data = (char)RAND32();
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    char data = var;
    {
        char result = data - 1;
        printHexCharLine(result);
    }
}
static void goodG2B()
{
    char data;
    data = ' ';
    data = -2;
    var = data;
    goodG2BSink();
}
static void goodB2GSink()
{
    char data = var;
    if (data > CHAR_MIN)
    {
        char result = data - 1;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
static void goodB2G()
{
    char data;
    data = ' ';
    data = (char)RAND32();
    var = data;
    goodB2GSink();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_fgets_postdec_18.c,CWE191,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    goto source;
source:
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    goto sink;
sink:
    {
        data--;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int data;
    data = 0;
    goto source;
source:
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    goto sink;
sink:
    if (data > INT_MIN)
    {
        data--;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    goto source;
source:
    data = -2;
    goto sink;
sink:
    {
        data--;
        int result = data;
        printIntLine(result);
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_sub_03.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(5==5)
    {
        data = (unsigned int)RAND32();
    }
    if(5==5)
    {
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(5==5)
    {
        data = (unsigned int)RAND32();
    }
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > 0)
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(5==5)
    {
        data = (unsigned int)RAND32();
    }
    if(5==5)
    {
        if (data > 0)
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(5==5)
    {
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(5==5)
    {
        data = -2;
    }
    if(5==5)
    {
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_min_postdec_54a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data);
void var()
{
    char data;
    data = ' ';
    data = CHAR_MIN;
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char data);
static void goodG2B()
{
    char data;
    data = ' ';
    data = -2;
    var(data);
}
void var(char data);
static void goodB2G()
{
    char data;
    data = ' ';
    data = CHAR_MIN;
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_fscanf_multiply_31.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    {
        short dataCopy = data;
        short data = dataCopy;
        if(data < 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    short data;
    data = 0;
    data = -2;
    {
        short dataCopy = data;
        short data = dataCopy;
        if(data < 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodB2G()
{
    short data;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    {
        short dataCopy = data;
        short data = dataCopy;
        if(data < 0) 
        {
            if (data > (SHRT_MIN/2))
            {
                short result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_fscanf_postdec_15.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    switch(6)
    {
    case 6:
        fscanf (stdin, ""%c"", &data);
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        data--;
        char result = data;
        printHexCharLine(result);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    switch(6)
    {
    case 6:
        fscanf (stdin, ""%c"", &data);
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(8)
    {
    case 7:
        printLine(""Benign, fixed string"");
        break;
    default:
        if (data > CHAR_MIN)
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
        break;
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    switch(6)
    {
    case 6:
        fscanf (stdin, ""%c"", &data);
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        if (data > CHAR_MIN)
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        data = -2;
        break;
    }
    switch(7)
    {
    case 7:
    {
        data--;
        char result = data;
        printHexCharLine(result);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    switch(6)
    {
    case 6:
        data = -2;
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        data--;
        char result = data;
        printHexCharLine(result);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_rand_multiply_15.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    switch(6)
    {
    case 6:
        data = (short)RAND32();
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        if(data < 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    short data;
    data = 0;
    switch(6)
    {
    case 6:
        data = (short)RAND32();
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(8)
    {
    case 7:
        printLine(""Benign, fixed string"");
        break;
    default:
        if(data < 0) 
        {
            if (data > (SHRT_MIN/2))
            {
                short result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
        break;
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    switch(6)
    {
    case 6:
        data = (short)RAND32();
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        if(data < 0) 
        {
            if (data > (SHRT_MIN/2))
            {
                short result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B1()
{
    short data;
    data = 0;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        data = -2;
        break;
    }
    switch(7)
    {
    case 7:
        if(data < 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B2()
{
    short data;
    data = 0;
    switch(6)
    {
    case 6:
        data = -2;
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        if(data < 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_fscanf_predec_05.c,CWE191,bad,"#include ""std_testcase.h""
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    if(staticTrue)
    {
        fscanf (stdin, ""%hd"", &data);
    }
    if(staticTrue)
    {
        {
            --data;
            short result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    short data;
    data = 0;
    if(staticTrue)
    {
        fscanf (stdin, ""%hd"", &data);
    }
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > SHRT_MIN)
        {
            --data;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    if(staticTrue)
    {
        fscanf (stdin, ""%hd"", &data);
    }
    if(staticTrue)
    {
        if (data > SHRT_MIN)
        {
            --data;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    short data;
    data = 0;
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(staticTrue)
    {
        {
            --data;
            short result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    short data;
    data = 0;
    if(staticTrue)
    {
        data = -2;
    }
    if(staticTrue)
    {
        {
            --data;
            short result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_min_sub_54d.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__char_fscanf_predec_05.c,CWE191,bad,"#include ""std_testcase.h""
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(staticTrue)
    {
        fscanf (stdin, ""%c"", &data);
    }
    if(staticTrue)
    {
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(staticTrue)
    {
        fscanf (stdin, ""%c"", &data);
    }
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > CHAR_MIN)
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(staticTrue)
    {
        fscanf (stdin, ""%c"", &data);
    }
    if(staticTrue)
    {
        if (data > CHAR_MIN)
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(staticTrue)
    {
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(staticTrue)
    {
        data = -2;
    }
    if(staticTrue)
    {
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_fscanf_predec_53d.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data)
{
    {
        --data;
        int64_t result = data;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int64_t data)
{
    {
        --data;
        int64_t result = data;
        printLongLongLine(result);
    }
}
void var(int64_t data)
{
    if (data > LLONG_MIN)
    {
        --data;
        int64_t result = data;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__short_min_predec_04.c,CWE191,good,"#include ""std_testcase.h""
static const int STATIC_CONST_TRUE = 1; 
static const int STATIC_CONST_FALSE = 0; 
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        data = SHRT_MIN;
    }
    if(STATIC_CONST_TRUE)
    {
        {
            --data;
            short result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    short data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        data = SHRT_MIN;
    }
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > SHRT_MIN)
        {
            --data;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        data = SHRT_MIN;
    }
    if(STATIC_CONST_TRUE)
    {
        if (data > SHRT_MIN)
        {
            --data;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    short data;
    data = 0;
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(STATIC_CONST_TRUE)
    {
        {
            --data;
            short result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    short data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        data = -2;
    }
    if(STATIC_CONST_TRUE)
    {
        {
            --data;
            short result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_listen_socket_multiply_66b.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int dataArray[])
{
    int data = dataArray[2];
    if(data < 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int dataArray[])
{
    int data = dataArray[2];
    if(data < 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
void var(int dataArray[])
{
    int data = dataArray[2];
    if(data < 0) 
    {
        if (data > (INT_MIN/2))
        {
            int result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
#endif"
CWE191_Integer_Underflow__int_min_predec_22b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
extern int var;
void var(int data)
{
    if(var)
    {
        {
            --data;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
extern int var;
extern int var;
extern int var;
void var(int data)
{
    if(var)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN)
        {
            --data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var(int data)
{
    if(var)
    {
        if (data > INT_MIN)
        {
            --data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var(int data)
{
    if(var)
    {
        {
            --data;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_sub_08.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticReturnsTrue())
    {
        {
            int result = data - 1;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN)
        {
            int result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticReturnsTrue())
    {
        if (data > INT_MIN)
        {
            int result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(staticReturnsTrue())
    {
        {
            int result = data - 1;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(staticReturnsTrue())
    {
        data = -2;
    }
    if(staticReturnsTrue())
    {
        {
            int result = data - 1;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_min_multiply_02.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(1)
    {
        data = INT_MIN;
    }
    if(1)
    {
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(1)
    {
        data = INT_MIN;
    }
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data < 0) 
        {
            if (data > (INT_MIN/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(1)
    {
        data = INT_MIN;
    }
    if(1)
    {
        if(data < 0) 
        {
            if (data > (INT_MIN/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(1)
    {
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(1)
    {
        data = -2;
    }
    if(1)
    {
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_rand_multiply_45.c,CWE191,bad,"#include ""std_testcase.h""
static short var;
static short var;
static short var;
#ifndef OMITBAD
static void badSink()
{
    short data = var;
    if(data < 0) 
    {
        short result = data * 2;
        printIntLine(result);
    }
}
void var()
{
    short data;
    data = 0;
    data = (short)RAND32();
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    short data = var;
    if(data < 0) 
    {
        short result = data * 2;
        printIntLine(result);
    }
}
static void goodG2B()
{
    short data;
    data = 0;
    data = -2;
    var = data;
    goodG2BSink();
}
static void goodB2GSink()
{
    short data = var;
    if(data < 0) 
    {
        if (data > (SHRT_MIN/2))
        {
            short result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
static void goodB2G()
{
    short data;
    data = 0;
    data = (short)RAND32();
    var = data;
    goodB2GSink();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_rand_predec_63b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * dataPtr)
{
    int data = *dataPtr;
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int * dataPtr)
{
    int data = *dataPtr;
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
void var(int * dataPtr)
{
    int data = *dataPtr;
    if (data > INT_MIN)
    {
        --data;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__int64_t_min_postdec_54b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__int64_t_rand_sub_52c.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data)
{
    {
        int64_t result = data - 1;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int64_t data)
{
    {
        int64_t result = data - 1;
        printLongLongLine(result);
    }
}
void var(int64_t data)
{
    if (data > LLONG_MIN)
    {
        int64_t result = data - 1;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
#endif"
CWE191_Integer_Underflow__int_fscanf_predec_54e.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data)
{
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
void var(int data)
{
    if (data > INT_MIN)
    {
        --data;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__int_fgets_postdec_10.c,CWE191,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalTrue)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(globalTrue)
    {
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(globalTrue)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN)
        {
            data--;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(globalTrue)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(globalTrue)
    {
        if (data > INT_MIN)
        {
            data--;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(globalTrue)
    {
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(globalTrue)
    {
        data = -2;
    }
    if(globalTrue)
    {
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_postdec_32.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    data = 0;
    {
        int data = *dataPtr1;
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    data = 0;
    {
        int data = *dataPtr1;
        data = -2;
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodB2G()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    data = 0;
    {
        int data = *dataPtr1;
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        if (data > INT_MIN)
        {
            data--;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_rand_postdec_12.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(globalReturnsTrueOrFalse())
    {
        data = (char)RAND32();
    }
    else
    {
        data = -2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
    }
    else
    {
        if (data > CHAR_MIN)
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    char data;
    data = ' ';
    if(globalReturnsTrueOrFalse())
    {
        data = (char)RAND32();
    }
    else
    {
        data = (char)RAND32();
    }
    if(globalReturnsTrueOrFalse())
    {
        if (data > CHAR_MIN)
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
    else
    {
        if (data > CHAR_MIN)
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B()
{
    char data;
    data = ' ';
    if(globalReturnsTrueOrFalse())
    {
        data = -2;
    }
    else
    {
        data = -2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
    }
    else
    {
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_rand_sub_63a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * dataPtr);
void var()
{
    int64_t data;
    data = 0LL;
    data = (int64_t)RAND64();
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t * data);
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = -2;
    var(&data);
}
void var(int64_t * data);
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    data = (int64_t)RAND64();
    var(&data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_rand_predec_54a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data);
void var()
{
    char data;
    data = ' ';
    data = (char)RAND32();
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char data);
static void goodG2B()
{
    char data;
    data = ' ';
    data = -2;
    var(data);
}
void var(char data);
static void goodB2G()
{
    char data;
    data = ' ';
    data = (char)RAND32();
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_fscanf_postdec_53b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__unsigned_int_fscanf_predec_13.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        fscanf (stdin, ""%u"", &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        fscanf (stdin, ""%u"", &data);
    }
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > 0)
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        fscanf (stdin, ""%u"", &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if (data > 0)
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = -2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_fscanf_postdec_54a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data);
void var()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char data);
static void goodG2B()
{
    char data;
    data = ' ';
    data = -2;
    var(data);
}
void var(char data);
static void goodB2G()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_rand_multiply_66b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char dataArray[])
{
    char data = dataArray[2];
    if(data < 0) 
    {
        char result = data * 2;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(char dataArray[])
{
    char data = dataArray[2];
    if(data < 0) 
    {
        char result = data * 2;
        printHexCharLine(result);
    }
}
void var(char dataArray[])
{
    char data = dataArray[2];
    if(data < 0) 
    {
        if (data > (CHAR_MIN/2))
        {
            char result = data * 2;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
#endif"
CWE191_Integer_Underflow__int_min_predec_66b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int dataArray[])
{
    int data = dataArray[2];
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int dataArray[])
{
    int data = dataArray[2];
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
void var(int dataArray[])
{
    int data = dataArray[2];
    if (data > INT_MIN)
    {
        --data;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__char_min_sub_54e.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data)
{
    {
        char result = data - 1;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(char data)
{
    {
        char result = data - 1;
        printHexCharLine(result);
    }
}
void var(char data)
{
    if (data > CHAR_MIN)
    {
        char result = data - 1;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
#endif"
CWE191_Integer_Underflow__int_fgets_sub_42.c,CWE191,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
static int badSource(int data)
{
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    return data;
}
void var()
{
    int data;
    data = 0;
    data = badSource(data);
    {
        int result = data - 1;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static int goodG2BSource(int data)
{
    data = -2;
    return data;
}
static void goodG2B()
{
    int data;
    data = 0;
    data = goodG2BSource(data);
    {
        int result = data - 1;
        printIntLine(result);
    }
}
static int goodB2GSource(int data)
{
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    return data;
}
static void goodB2G()
{
    int data;
    data = 0;
    data = goodB2GSource(data);
    if (data > INT_MIN)
    {
        int result = data - 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_fscanf_predec_67b.c,CWE191,good,"#include ""std_testcase.h""
typedef struct _CWE191_Integer_Underflow__unsigned_int_fscanf_predec_67_structType
{
    unsigned int structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct)
{
    unsigned int data = myStruct.structFirst;
    {
        --data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(var myStruct)
{
    unsigned int data = myStruct.structFirst;
    {
        --data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
void var(var myStruct)
{
    unsigned int data = myStruct.structFirst;
    if (data > 0)
    {
        --data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__int_listen_socket_multiply_32.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    data = 0;
    {
        int data = *dataPtr1;
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    data = 0;
    {
        int data = *dataPtr1;
        data = -2;
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodB2G()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    data = 0;
    {
        int data = *dataPtr1;
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        if(data < 0) 
        {
            if (data > (INT_MIN/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_rand_postdec_61b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
char var(char data)
{
    data = (char)RAND32();
    return data;
}
#endif 
#ifndef OMITGOOD
char var(char data)
{
    data = -2;
    return data;
}
char var(char data)
{
    data = (char)RAND32();
    return data;
}
#endif"
CWE191_Integer_Underflow__int_min_sub_21.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
static int badStatic = 0;
static void badSink(int data)
{
    if(badStatic)
    {
        {
            int result = data - 1;
            printIntLine(result);
        }
    }
}
void var()
{
    int data;
    data = 0;
    data = INT_MIN;
    badStatic = 1; 
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static int goodB2G1Static = 0;
static int goodB2G2Static = 0;
static int goodG2BStatic = 0;
static void goodB2G1Sink(int data)
{
    if(goodB2G1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN)
        {
            int result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodB2G1()
{
    int data;
    data = 0;
    data = INT_MIN;
    goodB2G1Static = 0; 
    goodB2G1Sink(data);
}
static void goodB2G2Sink(int data)
{
    if(goodB2G2Static)
    {
        if (data > INT_MIN)
        {
            int result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    data = INT_MIN;
    goodB2G2Static = 1; 
    goodB2G2Sink(data);
}
static void goodG2BSink(int data)
{
    if(goodG2BStatic)
    {
        {
            int result = data - 1;
            printIntLine(result);
        }
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    data = -2;
    goodG2BStatic = 1; 
    goodG2BSink(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_postdec_67b.c,CWE191,good,"#include ""std_testcase.h""
typedef struct _CWE191_Integer_Underflow__unsigned_int_rand_postdec_67_structType
{
    unsigned int structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct)
{
    unsigned int data = myStruct.structFirst;
    {
        data--;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(var myStruct)
{
    unsigned int data = myStruct.structFirst;
    {
        data--;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
void var(var myStruct)
{
    unsigned int data = myStruct.structFirst;
    if (data > 0)
    {
        data--;
        unsigned int result = data;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__int_rand_multiply_65b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data)
{
    if(data < 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    if(data < 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
void var(int data)
{
    if(data < 0) 
    {
        if (data > (INT_MIN/2))
        {
            int result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
#endif"
CWE191_Integer_Underflow__char_fscanf_predec_52a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data);
void var()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char data);
static void goodG2B()
{
    char data;
    data = ' ';
    data = -2;
    var(data);
}
void var(char data);
static void goodB2G()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_min_postdec_31.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    data = SHRT_MIN;
    {
        short dataCopy = data;
        short data = dataCopy;
        {
            data--;
            short result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    short data;
    data = 0;
    data = -2;
    {
        short dataCopy = data;
        short data = dataCopy;
        {
            data--;
            short result = data;
            printIntLine(result);
        }
    }
}
static void goodB2G()
{
    short data;
    data = 0;
    data = SHRT_MIN;
    {
        short dataCopy = data;
        short data = dataCopy;
        if (data > SHRT_MIN)
        {
            data--;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_listen_socket_multiply_41.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
static void badSink(int data)
{
    if(data < 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
void var()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(int data)
{
    if(data < 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    data = -2;
    goodG2BSink(data);
}
static void goodB2GSink(int data)
{
    if(data < 0) 
    {
        if (data > (INT_MIN/2))
        {
            int result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
static void goodB2G()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    goodB2GSink(data);
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_fscanf_predec_02.c,CWE191,good,"#include <inttypes.h>
#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(1)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(1)
    {
        {
            --data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(1)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > LLONG_MIN)
        {
            --data;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(1)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(1)
    {
        if (data > LLONG_MIN)
        {
            --data;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(1)
    {
        {
            --data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(1)
    {
        data = -2;
    }
    if(1)
    {
        {
            --data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_listen_socket_sub_63b.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int * dataPtr)
{
    int data = *dataPtr;
    {
        int result = data - 1;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int * dataPtr)
{
    int data = *dataPtr;
    {
        int result = data - 1;
        printIntLine(result);
    }
}
void var(int * dataPtr)
{
    int data = *dataPtr;
    if (data > INT_MIN)
    {
        int result = data - 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
#endif"
CWE191_Integer_Underflow__char_rand_multiply_08.c,CWE191,good,"#include ""std_testcase.h""
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(staticReturnsTrue())
    {
        data = (char)RAND32();
    }
    if(staticReturnsTrue())
    {
        if(data < 0) 
        {
            char result = data * 2;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(staticReturnsTrue())
    {
        data = (char)RAND32();
    }
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data < 0) 
        {
            if (data > (CHAR_MIN/2))
            {
                char result = data * 2;
                printHexCharLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(staticReturnsTrue())
    {
        data = (char)RAND32();
    }
    if(staticReturnsTrue())
    {
        if(data < 0) 
        {
            if (data > (CHAR_MIN/2))
            {
                char result = data * 2;
                printHexCharLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(staticReturnsTrue())
    {
        if(data < 0) 
        {
            char result = data * 2;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(staticReturnsTrue())
    {
        data = -2;
    }
    if(staticReturnsTrue())
    {
        if(data < 0) 
        {
            char result = data * 2;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_fscanf_sub_64b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    short * dataPtr = (short *)dataVoidPtr;
    short data = (*dataPtr);
    {
        short result = data - 1;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    short * dataPtr = (short *)dataVoidPtr;
    short data = (*dataPtr);
    {
        short result = data - 1;
        printIntLine(result);
    }
}
void var(void * dataVoidPtr)
{
    short * dataPtr = (short *)dataVoidPtr;
    short data = (*dataPtr);
    if (data > SHRT_MIN)
    {
        short result = data - 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
#endif"
CWE191_Integer_Underflow__int64_t_rand_multiply_05.c,CWE191,bad,"#include ""std_testcase.h""
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(staticTrue)
    {
        data = (int64_t)RAND64();
    }
    if(staticTrue)
    {
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(staticTrue)
    {
        data = (int64_t)RAND64();
    }
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data < 0) 
        {
            if (data > (LLONG_MIN/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(staticTrue)
    {
        data = (int64_t)RAND64();
    }
    if(staticTrue)
    {
        if(data < 0) 
        {
            if (data > (LLONG_MIN/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(staticTrue)
    {
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(staticTrue)
    {
        data = -2;
    }
    if(staticTrue)
    {
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_min_predec_12.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        data = 0;
    }
    else
    {
        data = -2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
    else
    {
        if (data > 0)
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    unsigned int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        data = 0;
    }
    else
    {
        data = 0;
    }
    if(globalReturnsTrueOrFalse())
    {
        if (data > 0)
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
    else
    {
        if (data > 0)
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B()
{
    unsigned int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        data = -2;
    }
    else
    {
        data = -2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
    else
    {
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_rand_sub_67b.c,CWE191,good,"#include ""std_testcase.h""
typedef struct _CWE191_Integer_Underflow__int64_t_rand_sub_67_structType
{
    int64_t structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct)
{
    int64_t data = myStruct.structFirst;
    {
        int64_t result = data - 1;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(var myStruct)
{
    int64_t data = myStruct.structFirst;
    {
        int64_t result = data - 1;
        printLongLongLine(result);
    }
}
void var(var myStruct)
{
    int64_t data = myStruct.structFirst;
    if (data > LLONG_MIN)
    {
        int64_t result = data - 1;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_multiply_52c.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data)
{
    if(data < 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    if(data < 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
void var(int data)
{
    if(data < 0) 
    {
        if (data > (INT_MIN/2))
        {
            int result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
#endif"
CWE191_Integer_Underflow__short_fscanf_postdec_17.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int i,j;
    short data;
    data = 0;
    for(i = 0; i < 1; i++)
    {
        fscanf (stdin, ""%hd"", &data);
    }
    for(j = 0; j < 1; j++)
    {
        {
            data--;
            short result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int i,k;
    short data;
    data = 0;
    for(i = 0; i < 1; i++)
    {
        fscanf (stdin, ""%hd"", &data);
    }
    for(k = 0; k < 1; k++)
    {
        if (data > SHRT_MIN)
        {
            data--;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B()
{
    int h,j;
    short data;
    data = 0;
    for(h = 0; h < 1; h++)
    {
        data = -2;
    }
    for(j = 0; j < 1; j++)
    {
        {
            data--;
            short result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_min_multiply_68a.c,CWE191,good,"#include ""std_testcase.h""
char var;
char var;
char var;
#ifndef OMITBAD
void var();
void var()
{
    char data;
    data = ' ';
    data = CHAR_MIN;
    var = data;
    var();
}
#endif 
#ifndef OMITGOOD
void var();
void var();
static void goodG2B()
{
    char data;
    data = ' ';
    data = -2;
    var = data;
    var();
}
static void goodB2G()
{
    char data;
    data = ' ';
    data = CHAR_MIN;
    var = data;
    var();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_rand_multiply_53b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__char_fscanf_multiply_64b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    char * dataPtr = (char *)dataVoidPtr;
    char data = (*dataPtr);
    if(data < 0) 
    {
        char result = data * 2;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    char * dataPtr = (char *)dataVoidPtr;
    char data = (*dataPtr);
    if(data < 0) 
    {
        char result = data * 2;
        printHexCharLine(result);
    }
}
void var(void * dataVoidPtr)
{
    char * dataPtr = (char *)dataVoidPtr;
    char data = (*dataPtr);
    if(data < 0) 
    {
        if (data > (CHAR_MIN/2))
        {
            char result = data * 2;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
#endif"
CWE191_Integer_Underflow__int64_t_fscanf_predec_54d.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__int64_t_rand_postdec_21.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
static int badStatic = 0;
static void badSink(int64_t data)
{
    if(badStatic)
    {
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
void var()
{
    int64_t data;
    data = 0LL;
    data = (int64_t)RAND64();
    badStatic = 1; 
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static int goodB2G1Static = 0;
static int goodB2G2Static = 0;
static int goodG2BStatic = 0;
static void goodB2G1Sink(int64_t data)
{
    if(goodB2G1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > LLONG_MIN)
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    data = (int64_t)RAND64();
    goodB2G1Static = 0; 
    goodB2G1Sink(data);
}
static void goodB2G2Sink(int64_t data)
{
    if(goodB2G2Static)
    {
        if (data > LLONG_MIN)
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    data = (int64_t)RAND64();
    goodB2G2Static = 1; 
    goodB2G2Sink(data);
}
static void goodG2BSink(int64_t data)
{
    if(goodG2BStatic)
    {
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = -2;
    goodG2BStatic = 1; 
    goodG2BSink(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_min_postdec_09.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        data = CHAR_MIN;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        data = CHAR_MIN;
    }
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > CHAR_MIN)
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        data = CHAR_MIN;
    }
    if(GLOBAL_CONST_TRUE)
    {
        if (data > CHAR_MIN)
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        data = -2;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_postdec_11.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsTrue())
    {
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN)
        {
            data--;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsTrue())
    {
        if (data > INT_MIN)
        {
            data--;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(globalReturnsTrue())
    {
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(globalReturnsTrue())
    {
        data = -2;
    }
    if(globalReturnsTrue())
    {
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_fgets_postdec_54b.c,CWE191,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__char_fscanf_predec_54e.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data)
{
    {
        --data;
        char result = data;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(char data)
{
    {
        --data;
        char result = data;
        printHexCharLine(result);
    }
}
void var(char data)
{
    if (data > CHAR_MIN)
    {
        --data;
        char result = data;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__short_fscanf_sub_14.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    if(globalFive==5)
    {
        fscanf (stdin, ""%hd"", &data);
    }
    if(globalFive==5)
    {
        {
            short result = data - 1;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    short data;
    data = 0;
    if(globalFive==5)
    {
        fscanf (stdin, ""%hd"", &data);
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > SHRT_MIN)
        {
            short result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    if(globalFive==5)
    {
        fscanf (stdin, ""%hd"", &data);
    }
    if(globalFive==5)
    {
        if (data > SHRT_MIN)
        {
            short result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodG2B1()
{
    short data;
    data = 0;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(globalFive==5)
    {
        {
            short result = data - 1;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    short data;
    data = 0;
    if(globalFive==5)
    {
        data = -2;
    }
    if(globalFive==5)
    {
        {
            short result = data - 1;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_fscanf_multiply_64b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    short * dataPtr = (short *)dataVoidPtr;
    short data = (*dataPtr);
    if(data < 0) 
    {
        short result = data * 2;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    short * dataPtr = (short *)dataVoidPtr;
    short data = (*dataPtr);
    if(data < 0) 
    {
        short result = data * 2;
        printIntLine(result);
    }
}
void var(void * dataVoidPtr)
{
    short * dataPtr = (short *)dataVoidPtr;
    short data = (*dataPtr);
    if(data < 0) 
    {
        if (data > (SHRT_MIN/2))
        {
            short result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
#endif"
CWE191_Integer_Underflow__short_min_postdec_04.c,CWE191,good,"#include ""std_testcase.h""
static const int STATIC_CONST_TRUE = 1; 
static const int STATIC_CONST_FALSE = 0; 
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        data = SHRT_MIN;
    }
    if(STATIC_CONST_TRUE)
    {
        {
            data--;
            short result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    short data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        data = SHRT_MIN;
    }
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > SHRT_MIN)
        {
            data--;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        data = SHRT_MIN;
    }
    if(STATIC_CONST_TRUE)
    {
        if (data > SHRT_MIN)
        {
            data--;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    short data;
    data = 0;
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(STATIC_CONST_TRUE)
    {
        {
            data--;
            short result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    short data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        data = -2;
    }
    if(STATIC_CONST_TRUE)
    {
        {
            data--;
            short result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_fscanf_predec_66a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char dataArray[]);
void var()
{
    char data;
    char dataArray[5];
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(char dataArray[]);
static void goodG2B()
{
    char data;
    char dataArray[5];
    data = ' ';
    data = -2;
    dataArray[2] = data;
    var(dataArray);
}
void var(char dataArray[]);
static void goodB2G()
{
    char data;
    char dataArray[5];
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_rand_sub_53d.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data)
{
    {
        short result = data - 1;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(short data)
{
    {
        short result = data - 1;
        printIntLine(result);
    }
}
void var(short data)
{
    if (data > SHRT_MIN)
    {
        short result = data - 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
#endif"
CWE191_Integer_Underflow__int64_t_fscanf_multiply_18.c,CWE191,bad,"#include <inttypes.h>
#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    goto source;
source:
    fscanf (stdin, ""%"" SCNd64, &data);
    goto sink;
sink:
    if(data < 0) 
    {
        int64_t result = data * 2;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    goto source;
source:
    fscanf (stdin, ""%"" SCNd64, &data);
    goto sink;
sink:
    if(data < 0) 
    {
        if (data > (LLONG_MIN/2))
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    goto source;
source:
    data = -2;
    goto sink;
sink:
    if(data < 0) 
    {
        int64_t result = data * 2;
        printLongLongLine(result);
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_fscanf_predec_54d.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data);
void var(char data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char data);
void var(char data)
{
    var(data);
}
void var(char data);
void var(char data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__short_rand_multiply_67b.c,CWE191,good,"#include ""std_testcase.h""
typedef struct _CWE191_Integer_Underflow__short_rand_multiply_67_structType
{
    short structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct)
{
    short data = myStruct.structFirst;
    if(data < 0) 
    {
        short result = data * 2;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(var myStruct)
{
    short data = myStruct.structFirst;
    if(data < 0) 
    {
        short result = data * 2;
        printIntLine(result);
    }
}
void var(var myStruct)
{
    short data = myStruct.structFirst;
    if(data < 0) 
    {
        if (data > (SHRT_MIN/2))
        {
            short result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
#endif"
CWE191_Integer_Underflow__int64_t_rand_multiply_45.c,CWE191,bad,"#include ""std_testcase.h""
static int64_t var;
static int64_t var;
static int64_t var;
#ifndef OMITBAD
static void badSink()
{
    int64_t data = var;
    if(data < 0) 
    {
        int64_t result = data * 2;
        printLongLongLine(result);
    }
}
void var()
{
    int64_t data;
    data = 0LL;
    data = (int64_t)RAND64();
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    int64_t data = var;
    if(data < 0) 
    {
        int64_t result = data * 2;
        printLongLongLine(result);
    }
}
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = -2;
    var = data;
    goodG2BSink();
}
static void goodB2GSink()
{
    int64_t data = var;
    if(data < 0) 
    {
        if (data > (LLONG_MIN/2))
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    data = (int64_t)RAND64();
    var = data;
    goodB2GSink();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_sub_53b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__int_fscanf_predec_54b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_sub_12.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        data = -2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            int result = data - 1;
            printIntLine(result);
        }
    }
    else
    {
        if (data > INT_MIN)
        {
            int result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsTrueOrFalse())
    {
        if (data > INT_MIN)
        {
            int result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
    else
    {
        if (data > INT_MIN)
        {
            int result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        data = -2;
    }
    else
    {
        data = -2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            int result = data - 1;
            printIntLine(result);
        }
    }
    else
    {
        {
            int result = data - 1;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_rand_postdec_16.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    while(1)
    {
        data = (int64_t)RAND64();
        break;
    }
    while(1)
    {
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    while(1)
    {
        data = (int64_t)RAND64();
        break;
    }
    while(1)
    {
        if (data > LLONG_MIN)
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
        break;
    }
}
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    while(1)
    {
        data = -2;
        break;
    }
    while(1)
    {
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
        break;
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_fscanf_multiply_13.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        fscanf (stdin, ""%hd"", &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data < 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    short data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        fscanf (stdin, ""%hd"", &data);
    }
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data < 0) 
        {
            if (data > (SHRT_MIN/2))
            {
                short result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        fscanf (stdin, ""%hd"", &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data < 0) 
        {
            if (data > (SHRT_MIN/2))
            {
                short result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodG2B1()
{
    short data;
    data = 0;
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data < 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    short data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = -2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data < 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_rand_predec_22a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
int var = 0;
void var(short data);
void var()
{
    short data;
    data = 0;
    data = (short)RAND32();
    var = 1; 
    var(data);
}
#endif 
#ifndef OMITGOOD
int var = 0;
int var = 0;
int var = 0;
void var(short data);
static void goodB2G1()
{
    short data;
    data = 0;
    data = (short)RAND32();
    var = 0; 
    var(data);
}
void var(short data);
static void goodB2G2()
{
    short data;
    data = 0;
    data = (short)RAND32();
    var = 1; 
    var(data);
}
void var(short data);
static void goodG2B()
{
    short data;
    data = 0;
    data = -2;
    var = 1; 
    var(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_min_sub_52a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data);
void var()
{
    int data;
    data = 0;
    data = INT_MIN;
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = -2;
    var(data);
}
void var(int data);
static void goodB2G()
{
    int data;
    data = 0;
    data = INT_MIN;
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_fscanf_postdec_06.c,CWE191,good,"#include <inttypes.h>
#include ""std_testcase.h""
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(STATIC_CONST_FIVE==5)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(STATIC_CONST_FIVE==5)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > LLONG_MIN)
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(STATIC_CONST_FIVE==5)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        if (data > LLONG_MIN)
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(STATIC_CONST_FIVE==5)
    {
        data = -2;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_min_predec_07.c,CWE191,bad,"#include ""std_testcase.h""
static int staticFive = 5;
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    if(staticFive==5)
    {
        data = SHRT_MIN;
    }
    if(staticFive==5)
    {
        {
            --data;
            short result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    short data;
    data = 0;
    if(staticFive==5)
    {
        data = SHRT_MIN;
    }
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > SHRT_MIN)
        {
            --data;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    if(staticFive==5)
    {
        data = SHRT_MIN;
    }
    if(staticFive==5)
    {
        if (data > SHRT_MIN)
        {
            --data;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    short data;
    data = 0;
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(staticFive==5)
    {
        {
            --data;
            short result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    short data;
    data = 0;
    if(staticFive==5)
    {
        data = -2;
    }
    if(staticFive==5)
    {
        {
            --data;
            short result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_rand_multiply_09.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        data = (char)RAND32();
    }
    if(GLOBAL_CONST_TRUE)
    {
        if(data < 0) 
        {
            char result = data * 2;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        data = (char)RAND32();
    }
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data < 0) 
        {
            if (data > (CHAR_MIN/2))
            {
                char result = data * 2;
                printHexCharLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        data = (char)RAND32();
    }
    if(GLOBAL_CONST_TRUE)
    {
        if(data < 0) 
        {
            if (data > (CHAR_MIN/2))
            {
                char result = data * 2;
                printHexCharLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(GLOBAL_CONST_TRUE)
    {
        if(data < 0) 
        {
            char result = data * 2;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        data = -2;
    }
    if(GLOBAL_CONST_TRUE)
    {
        if(data < 0) 
        {
            char result = data * 2;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_fscanf_multiply_09.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        fscanf (stdin, ""%c"", &data);
    }
    if(GLOBAL_CONST_TRUE)
    {
        if(data < 0) 
        {
            char result = data * 2;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        fscanf (stdin, ""%c"", &data);
    }
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data < 0) 
        {
            if (data > (CHAR_MIN/2))
            {
                char result = data * 2;
                printHexCharLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        fscanf (stdin, ""%c"", &data);
    }
    if(GLOBAL_CONST_TRUE)
    {
        if(data < 0) 
        {
            if (data > (CHAR_MIN/2))
            {
                char result = data * 2;
                printHexCharLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(GLOBAL_CONST_TRUE)
    {
        if(data < 0) 
        {
            char result = data * 2;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(GLOBAL_CONST_TRUE)
    {
        data = -2;
    }
    if(GLOBAL_CONST_TRUE)
    {
        if(data < 0) 
        {
            char result = data * 2;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_min_predec_68a.c,CWE191,good,"#include ""std_testcase.h""
unsigned int var;
unsigned int var;
unsigned int var;
#ifndef OMITBAD
void var();
void var()
{
    unsigned int data;
    data = 0;
    data = 0;
    var = data;
    var();
}
#endif 
#ifndef OMITGOOD
void var();
void var();
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = -2;
    var = data;
    var();
}
static void goodB2G()
{
    unsigned int data;
    data = 0;
    data = 0;
    var = data;
    var();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_fgets_multiply_67a.c,CWE191,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
typedef struct _CWE191_Integer_Underflow__int_fgets_multiply_67_structType
{
    int structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct);
void var()
{
    int data;
    var myStruct;
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    myStruct.structFirst = data;
    var(myStruct);
}
#endif 
#ifndef OMITGOOD
void var(var myStruct);
static void goodG2B()
{
    int data;
    var myStruct;
    data = 0;
    data = -2;
    myStruct.structFirst = data;
    var(myStruct);
}
void var(var myStruct);
static void goodB2G()
{
    int data;
    var myStruct;
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    myStruct.structFirst = data;
    var(myStruct);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_postdec_65b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data)
{
    {
        data--;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data)
{
    {
        data--;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
void var(unsigned int data)
{
    if (data > 0)
    {
        data--;
        unsigned int result = data;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__int_listen_socket_postdec_05.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticTrue)
    {
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN)
        {
            data--;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticTrue)
    {
        if (data > INT_MIN)
        {
            data--;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(staticTrue)
    {
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(staticTrue)
    {
        data = -2;
    }
    if(staticTrue)
    {
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_rand_predec_68a.c,CWE191,good,"#include ""std_testcase.h""
int64_t var;
int64_t var;
int64_t var;
#ifndef OMITBAD
void var();
void var()
{
    int64_t data;
    data = 0LL;
    data = (int64_t)RAND64();
    var = data;
    var();
}
#endif 
#ifndef OMITGOOD
void var();
void var();
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = -2;
    var = data;
    var();
}
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    data = (int64_t)RAND64();
    var = data;
    var();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_min_postdec_12.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(globalReturnsTrueOrFalse())
    {
        data = LLONG_MIN;
    }
    else
    {
        data = -2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
    else
    {
        if (data > LLONG_MIN)
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    if(globalReturnsTrueOrFalse())
    {
        data = LLONG_MIN;
    }
    else
    {
        data = LLONG_MIN;
    }
    if(globalReturnsTrueOrFalse())
    {
        if (data > LLONG_MIN)
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
    else
    {
        if (data > LLONG_MIN)
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    if(globalReturnsTrueOrFalse())
    {
        data = -2;
    }
    else
    {
        data = -2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
    else
    {
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_listen_socket_predec_02.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(1)
    {
        {
            --data;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN)
        {
            --data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(1)
    {
        if (data > INT_MIN)
        {
            --data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(1)
    {
        {
            --data;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(1)
    {
        data = -2;
    }
    if(1)
    {
        {
            --data;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_fscanf_postdec_67b.c,CWE191,good,"#include ""std_testcase.h""
typedef struct _CWE191_Integer_Underflow__char_fscanf_postdec_67_structType
{
    char structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct)
{
    char data = myStruct.structFirst;
    {
        data--;
        char result = data;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(var myStruct)
{
    char data = myStruct.structFirst;
    {
        data--;
        char result = data;
        printHexCharLine(result);
    }
}
void var(var myStruct)
{
    char data = myStruct.structFirst;
    if (data > CHAR_MIN)
    {
        data--;
        char result = data;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__char_min_predec_54c.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data);
void var(char data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char data);
void var(char data)
{
    var(data);
}
void var(char data);
void var(char data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_sub_65a.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data);
void var()
{
    int data;
    void (*funcPtr) (int) = var;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
static void goodG2B()
{
    int data;
    void (*funcPtr) (int) = var;
    data = 0;
    data = -2;
    funcPtr(data);
}
void var(int data);
static void goodB2G()
{
    int data;
    void (*funcPtr) (int) = var;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_sub_13.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = (unsigned int)RAND32();
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = (unsigned int)RAND32();
    }
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > 0)
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = (unsigned int)RAND32();
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if (data > 0)
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = -2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_min_postdec_68a.c,CWE191,good,"#include ""std_testcase.h""
int var;
int var;
int var;
#ifndef OMITBAD
void var();
void var()
{
    int data;
    data = 0;
    data = INT_MIN;
    var = data;
    var();
}
#endif 
#ifndef OMITGOOD
void var();
void var();
static void goodG2B()
{
    int data;
    data = 0;
    data = -2;
    var = data;
    var();
}
static void goodB2G()
{
    int data;
    data = 0;
    data = INT_MIN;
    var = data;
    var();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_fscanf_predec_22b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
extern int var;
void var(int data)
{
    if(var)
    {
        {
            --data;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
extern int var;
extern int var;
extern int var;
void var(int data)
{
    if(var)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN)
        {
            --data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var(int data)
{
    if(var)
    {
        if (data > INT_MIN)
        {
            --data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var(int data)
{
    if(var)
    {
        {
            --data;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif"
CWE191_Integer_Underflow__int_rand_sub_67a.c,CWE191,good,"#include ""std_testcase.h""
typedef struct _CWE191_Integer_Underflow__int_rand_sub_67_structType
{
    int structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct);
void var()
{
    int data;
    var myStruct;
    data = 0;
    data = RAND32();
    myStruct.structFirst = data;
    var(myStruct);
}
#endif 
#ifndef OMITGOOD
void var(var myStruct);
static void goodG2B()
{
    int data;
    var myStruct;
    data = 0;
    data = -2;
    myStruct.structFirst = data;
    var(myStruct);
}
void var(var myStruct);
static void goodB2G()
{
    int data;
    var myStruct;
    data = 0;
    data = RAND32();
    myStruct.structFirst = data;
    var(myStruct);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_fscanf_sub_42.c,CWE191,bad,"#include <inttypes.h>
#include ""std_testcase.h""
#ifndef OMITBAD
static int64_t badSource(int64_t data)
{
    fscanf (stdin, ""%"" SCNd64, &data);
    return data;
}
void var()
{
    int64_t data;
    data = 0LL;
    data = badSource(data);
    {
        int64_t result = data - 1;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static int64_t goodG2BSource(int64_t data)
{
    data = -2;
    return data;
}
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = goodG2BSource(data);
    {
        int64_t result = data - 1;
        printLongLongLine(result);
    }
}
static int64_t goodB2GSource(int64_t data)
{
    fscanf (stdin, ""%"" SCNd64, &data);
    return data;
}
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    data = goodB2GSource(data);
    if (data > LLONG_MIN)
    {
        int64_t result = data - 1;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_listen_socket_predec_64a.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(void * dataVoidPtr);
void var()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr);
static void goodG2B()
{
    int data;
    data = 0;
    data = -2;
    var(&data);
}
void var(void * dataVoidPtr);
static void goodB2G()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var(&data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_rand_sub_54a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data);
void var()
{
    int data;
    data = 0;
    data = RAND32();
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = -2;
    var(data);
}
void var(int data);
static void goodB2G()
{
    int data;
    data = 0;
    data = RAND32();
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_fscanf_postdec_18.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    goto source;
source:
    fscanf (stdin, ""%c"", &data);
    goto sink;
sink:
    {
        data--;
        char result = data;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    char data;
    data = ' ';
    goto source;
source:
    fscanf (stdin, ""%c"", &data);
    goto sink;
sink:
    if (data > CHAR_MIN)
    {
        data--;
        char result = data;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodG2B()
{
    char data;
    data = ' ';
    goto source;
source:
    data = -2;
    goto sink;
sink:
    {
        data--;
        char result = data;
        printHexCharLine(result);
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_rand_postdec_32.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    short data;
    short *dataPtr1 = &data;
    short *dataPtr2 = &data;
    data = 0;
    {
        short data = *dataPtr1;
        data = (short)RAND32();
        *dataPtr1 = data;
    }
    {
        short data = *dataPtr2;
        {
            data--;
            short result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    short data;
    short *dataPtr1 = &data;
    short *dataPtr2 = &data;
    data = 0;
    {
        short data = *dataPtr1;
        data = -2;
        *dataPtr1 = data;
    }
    {
        short data = *dataPtr2;
        {
            data--;
            short result = data;
            printIntLine(result);
        }
    }
}
static void goodB2G()
{
    short data;
    short *dataPtr1 = &data;
    short *dataPtr2 = &data;
    data = 0;
    {
        short data = *dataPtr1;
        data = (short)RAND32();
        *dataPtr1 = data;
    }
    {
        short data = *dataPtr2;
        if (data > SHRT_MIN)
        {
            data--;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_22a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
int var = 0;
void var(unsigned int data);
void var()
{
    unsigned int data;
    data = 0;
    fscanf (stdin, ""%u"", &data);
    var = 1; 
    var(data);
}
#endif 
#ifndef OMITGOOD
int var = 0;
int var = 0;
int var = 0;
void var(unsigned int data);
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    fscanf (stdin, ""%u"", &data);
    var = 0; 
    var(data);
}
void var(unsigned int data);
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    fscanf (stdin, ""%u"", &data);
    var = 1; 
    var(data);
}
void var(unsigned int data);
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = -2;
    var = 1; 
    var(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_min_sub_12.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(globalReturnsTrueOrFalse())
    {
        data = LLONG_MIN;
    }
    else
    {
        data = -2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            int64_t result = data - 1;
            printLongLongLine(result);
        }
    }
    else
    {
        if (data > LLONG_MIN)
        {
            int64_t result = data - 1;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    if(globalReturnsTrueOrFalse())
    {
        data = LLONG_MIN;
    }
    else
    {
        data = LLONG_MIN;
    }
    if(globalReturnsTrueOrFalse())
    {
        if (data > LLONG_MIN)
        {
            int64_t result = data - 1;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
    else
    {
        if (data > LLONG_MIN)
        {
            int64_t result = data - 1;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    if(globalReturnsTrueOrFalse())
    {
        data = -2;
    }
    else
    {
        data = -2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            int64_t result = data - 1;
            printLongLongLine(result);
        }
    }
    else
    {
        {
            int64_t result = data - 1;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_rand_sub_42.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
static char badSource(char data)
{
    data = (char)RAND32();
    return data;
}
void var()
{
    char data;
    data = ' ';
    data = badSource(data);
    {
        char result = data - 1;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static char goodG2BSource(char data)
{
    data = -2;
    return data;
}
static void goodG2B()
{
    char data;
    data = ' ';
    data = goodG2BSource(data);
    {
        char result = data - 1;
        printHexCharLine(result);
    }
}
static char goodB2GSource(char data)
{
    data = (char)RAND32();
    return data;
}
static void goodB2G()
{
    char data;
    data = ' ';
    data = goodB2GSource(data);
    if (data > CHAR_MIN)
    {
        char result = data - 1;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_17.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int i,j;
    unsigned int data;
    data = 0;
    for(i = 0; i < 1; i++)
    {
        fscanf (stdin, ""%u"", &data);
    }
    for(j = 0; j < 1; j++)
    {
        {
            data--;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int i,k;
    unsigned int data;
    data = 0;
    for(i = 0; i < 1; i++)
    {
        fscanf (stdin, ""%u"", &data);
    }
    for(k = 0; k < 1; k++)
    {
        if (data > 0)
        {
            data--;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B()
{
    int h,j;
    unsigned int data;
    data = 0;
    for(h = 0; h < 1; h++)
    {
        data = -2;
    }
    for(j = 0; j < 1; j++)
    {
        {
            data--;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_rand_sub_54b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__char_rand_predec_03.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(5==5)
    {
        data = (char)RAND32();
    }
    if(5==5)
    {
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(5==5)
    {
        data = (char)RAND32();
    }
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > CHAR_MIN)
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(5==5)
    {
        data = (char)RAND32();
    }
    if(5==5)
    {
        if (data > CHAR_MIN)
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(5==5)
    {
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(5==5)
    {
        data = -2;
    }
    if(5==5)
    {
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_rand_postdec_52b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data);
void var(short data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(short data);
void var(short data)
{
    var(data);
}
void var(short data);
void var(short data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__short_rand_postdec_51b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data)
{
    {
        data--;
        short result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(short data)
{
    {
        data--;
        short result = data;
        printIntLine(result);
    }
}
void var(short data)
{
    if (data > SHRT_MIN)
    {
        data--;
        short result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__int64_t_fscanf_postdec_17.c,CWE191,good,"#include <inttypes.h>
#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int i,j;
    int64_t data;
    data = 0LL;
    for(i = 0; i < 1; i++)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    for(j = 0; j < 1; j++)
    {
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int i,k;
    int64_t data;
    data = 0LL;
    for(i = 0; i < 1; i++)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    for(k = 0; k < 1; k++)
    {
        if (data > LLONG_MIN)
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B()
{
    int h,j;
    int64_t data;
    data = 0LL;
    for(h = 0; h < 1; h++)
    {
        data = -2;
    }
    for(j = 0; j < 1; j++)
    {
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_min_multiply_12.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(globalReturnsTrueOrFalse())
    {
        data = LLONG_MIN;
    }
    else
    {
        data = -2;
    }
    if(globalReturnsTrueOrFalse())
    {
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
    else
    {
        if(data < 0) 
        {
            if (data > (LLONG_MIN/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    if(globalReturnsTrueOrFalse())
    {
        data = LLONG_MIN;
    }
    else
    {
        data = LLONG_MIN;
    }
    if(globalReturnsTrueOrFalse())
    {
        if(data < 0) 
        {
            if (data > (LLONG_MIN/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
    else
    {
        if(data < 0) 
        {
            if (data > (LLONG_MIN/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    if(globalReturnsTrueOrFalse())
    {
        data = -2;
    }
    else
    {
        data = -2;
    }
    if(globalReturnsTrueOrFalse())
    {
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
    else
    {
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_fscanf_sub_22b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
extern int var;
void var(int data)
{
    if(var)
    {
        {
            int result = data - 1;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
extern int var;
extern int var;
extern int var;
void var(int data)
{
    if(var)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN)
        {
            int result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
void var(int data)
{
    if(var)
    {
        if (data > INT_MIN)
        {
            int result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
void var(int data)
{
    if(var)
    {
        {
            int result = data - 1;
            printIntLine(result);
        }
    }
}
#endif"
CWE191_Integer_Underflow__int_min_predec_09.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        data = INT_MIN;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            --data;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        data = INT_MIN;
    }
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN)
        {
            --data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        data = INT_MIN;
    }
    if(GLOBAL_CONST_TRUE)
    {
        if (data > INT_MIN)
        {
            --data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            --data;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        data = -2;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            --data;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_fscanf_sub_09.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        fscanf (stdin, ""%hd"", &data);
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            short result = data - 1;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    short data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        fscanf (stdin, ""%hd"", &data);
    }
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > SHRT_MIN)
        {
            short result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        fscanf (stdin, ""%hd"", &data);
    }
    if(GLOBAL_CONST_TRUE)
    {
        if (data > SHRT_MIN)
        {
            short result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodG2B1()
{
    short data;
    data = 0;
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            short result = data - 1;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    short data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        data = -2;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            short result = data - 1;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_min_postdec_63b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char * dataPtr)
{
    char data = *dataPtr;
    {
        data--;
        char result = data;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * dataPtr)
{
    char data = *dataPtr;
    {
        data--;
        char result = data;
        printHexCharLine(result);
    }
}
void var(char * dataPtr)
{
    char data = *dataPtr;
    if (data > CHAR_MIN)
    {
        data--;
        char result = data;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__short_rand_sub_11.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    if(globalReturnsTrue())
    {
        data = (short)RAND32();
    }
    if(globalReturnsTrue())
    {
        {
            short result = data - 1;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    short data;
    data = 0;
    if(globalReturnsTrue())
    {
        data = (short)RAND32();
    }
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > SHRT_MIN)
        {
            short result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    if(globalReturnsTrue())
    {
        data = (short)RAND32();
    }
    if(globalReturnsTrue())
    {
        if (data > SHRT_MIN)
        {
            short result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodG2B1()
{
    short data;
    data = 0;
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(globalReturnsTrue())
    {
        {
            short result = data - 1;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    short data;
    data = 0;
    if(globalReturnsTrue())
    {
        data = -2;
    }
    if(globalReturnsTrue())
    {
        {
            short result = data - 1;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_fscanf_predec_67a.c,CWE191,good,"#include ""std_testcase.h""
typedef struct _CWE191_Integer_Underflow__char_fscanf_predec_67_structType
{
    char structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct);
void var()
{
    char data;
    var myStruct;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    myStruct.structFirst = data;
    var(myStruct);
}
#endif 
#ifndef OMITGOOD
void var(var myStruct);
static void goodG2B()
{
    char data;
    var myStruct;
    data = ' ';
    data = -2;
    myStruct.structFirst = data;
    var(myStruct);
}
void var(var myStruct);
static void goodB2G()
{
    char data;
    var myStruct;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    myStruct.structFirst = data;
    var(myStruct);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_min_sub_01.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    data = INT_MIN;
    {
        int result = data - 1;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int data;
    data = 0;
    data = -2;
    {
        int result = data - 1;
        printIntLine(result);
    }
}
static void goodB2G()
{
    int data;
    data = 0;
    data = INT_MIN;
    if (data > INT_MIN)
    {
        int result = data - 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_fscanf_sub_44.c,CWE191,bad,"#include <inttypes.h>
#include ""std_testcase.h""
#ifndef OMITBAD
static void badSink(int64_t data)
{
    {
        int64_t result = data - 1;
        printLongLongLine(result);
    }
}
void var()
{
    int64_t data;
    void (*funcPtr) (int64_t) = badSink;
    data = 0LL;
    fscanf (stdin, ""%"" SCNd64, &data);
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(int64_t data)
{
    {
        int64_t result = data - 1;
        printLongLongLine(result);
    }
}
static void goodG2B()
{
    int64_t data;
    void (*funcPtr) (int64_t) = goodG2BSink;
    data = 0LL;
    data = -2;
    funcPtr(data);
}
static void goodB2GSink(int64_t data)
{
    if (data > LLONG_MIN)
    {
        int64_t result = data - 1;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
static void goodB2G()
{
    int64_t data;
    void (*funcPtr) (int64_t) = goodB2GSink;
    data = 0LL;
    fscanf (stdin, ""%"" SCNd64, &data);
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_predec_15.c,CWE191,bad,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    switch(6)
    {
    case 6:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        --data;
        int result = data;
        printIntLine(result);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    switch(6)
    {
    case 6:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(8)
    {
    case 7:
        printLine(""Benign, fixed string"");
        break;
    default:
        if (data > INT_MIN)
        {
            --data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
        break;
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    switch(6)
    {
    case 6:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        if (data > INT_MIN)
        {
            --data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        data = -2;
        break;
    }
    switch(7)
    {
    case 7:
    {
        --data;
        int result = data;
        printIntLine(result);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    switch(6)
    {
    case 6:
        data = -2;
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        --data;
        int result = data;
        printIntLine(result);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_fscanf_multiply_61a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
int64_t var(int64_t data);
void var()
{
    int64_t data;
    data = 0LL;
    data = var(data);
    if(data < 0) 
    {
        int64_t result = data * 2;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
int64_t var(int64_t data);
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = var(data);
    if(data < 0) 
    {
        int64_t result = data * 2;
        printLongLongLine(result);
    }
}
int64_t var(int64_t data);
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    data = var(data);
    if(data < 0) 
    {
        if (data > (LLONG_MIN/2))
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_fgets_predec_45.c,CWE191,bad,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
static int var;
static int var;
static int var;
#ifndef OMITBAD
static void badSink()
{
    int data = var;
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
void var()
{
    int data;
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    int data = var;
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    data = -2;
    var = data;
    goodG2BSink();
}
static void goodB2GSink()
{
    int data = var;
    if (data > INT_MIN)
    {
        --data;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodB2G()
{
    int data;
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    var = data;
    goodB2GSink();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_min_multiply_17.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int i,j;
    int64_t data;
    data = 0LL;
    for(i = 0; i < 1; i++)
    {
        data = LLONG_MIN;
    }
    for(j = 0; j < 1; j++)
    {
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int i,k;
    int64_t data;
    data = 0LL;
    for(i = 0; i < 1; i++)
    {
        data = LLONG_MIN;
    }
    for(k = 0; k < 1; k++)
    {
        if(data < 0) 
        {
            if (data > (LLONG_MIN/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodG2B()
{
    int h,j;
    int64_t data;
    data = 0LL;
    for(h = 0; h < 1; h++)
    {
        data = -2;
    }
    for(j = 0; j < 1; j++)
    {
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_postdec_53d.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data)
{
    {
        data--;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data)
{
    {
        data--;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
void var(unsigned int data)
{
    if (data > 0)
    {
        data--;
        unsigned int result = data;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__char_rand_postdec_54a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data);
void var()
{
    char data;
    data = ' ';
    data = (char)RAND32();
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char data);
static void goodG2B()
{
    char data;
    data = ' ';
    data = -2;
    var(data);
}
void var(char data);
static void goodB2G()
{
    char data;
    data = ' ';
    data = (char)RAND32();
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_rand_postdec_64a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(void * dataVoidPtr);
void var()
{
    char data;
    data = ' ';
    data = (char)RAND32();
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr);
static void goodG2B()
{
    char data;
    data = ' ';
    data = -2;
    var(&data);
}
void var(void * dataVoidPtr);
static void goodB2G()
{
    char data;
    data = ' ';
    data = (char)RAND32();
    var(&data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_fscanf_postdec_64a.c,CWE191,good,"#include <inttypes.h>
#include ""std_testcase.h""
#ifndef OMITBAD
void var(void * dataVoidPtr);
void var()
{
    int64_t data;
    data = 0LL;
    fscanf (stdin, ""%"" SCNd64, &data);
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr);
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = -2;
    var(&data);
}
void var(void * dataVoidPtr);
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    fscanf (stdin, ""%"" SCNd64, &data);
    var(&data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_fgets_postdec_67b.c,CWE191,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
typedef struct _CWE191_Integer_Underflow__int_fgets_postdec_67_structType
{
    int structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct)
{
    int data = myStruct.structFirst;
    {
        data--;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(var myStruct)
{
    int data = myStruct.structFirst;
    {
        data--;
        int result = data;
        printIntLine(result);
    }
}
void var(var myStruct)
{
    int data = myStruct.structFirst;
    if (data > INT_MIN)
    {
        data--;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__char_rand_predec_41.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
static void badSink(char data)
{
    {
        --data;
        char result = data;
        printHexCharLine(result);
    }
}
void var()
{
    char data;
    data = ' ';
    data = (char)RAND32();
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(char data)
{
    {
        --data;
        char result = data;
        printHexCharLine(result);
    }
}
static void goodG2B()
{
    char data;
    data = ' ';
    data = -2;
    goodG2BSink(data);
}
static void goodB2GSink(char data)
{
    if (data > CHAR_MIN)
    {
        --data;
        char result = data;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodB2G()
{
    char data;
    data = ' ';
    data = (char)RAND32();
    goodB2GSink(data);
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_predec_12.c,CWE191,bad,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        data = -2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            --data;
            int result = data;
            printIntLine(result);
        }
    }
    else
    {
        if (data > INT_MIN)
        {
            --data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    else
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsTrueOrFalse())
    {
        if (data > INT_MIN)
        {
            --data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
    else
    {
        if (data > INT_MIN)
        {
            --data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        data = -2;
    }
    else
    {
        data = -2;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            --data;
            int result = data;
            printIntLine(result);
        }
    }
    else
    {
        {
            --data;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_sub_66a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int dataArray[]);
void var()
{
    unsigned int data;
    unsigned int dataArray[5];
    data = 0;
    data = (unsigned int)RAND32();
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(unsigned int dataArray[]);
static void goodG2B()
{
    unsigned int data;
    unsigned int dataArray[5];
    data = 0;
    data = -2;
    dataArray[2] = data;
    var(dataArray);
}
void var(unsigned int dataArray[]);
static void goodB2G()
{
    unsigned int data;
    unsigned int dataArray[5];
    data = 0;
    data = (unsigned int)RAND32();
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_min_predec_68b.c,CWE191,good,"#include ""std_testcase.h""
extern char var;
extern char var;
extern char var;
#ifndef OMITBAD
void var()
{
    char data = var;
    {
        --data;
        char result = data;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    char data = var;
    {
        --data;
        char result = data;
        printHexCharLine(result);
    }
}
void var()
{
    char data = var;
    if (data > CHAR_MIN)
    {
        --data;
        char result = data;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__int_listen_socket_sub_66a.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int dataArray[]);
void var()
{
    int data;
    int dataArray[5];
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(int dataArray[]);
static void goodG2B()
{
    int data;
    int dataArray[5];
    data = 0;
    data = -2;
    dataArray[2] = data;
    var(dataArray);
}
void var(int dataArray[]);
static void goodB2G()
{
    int data;
    int dataArray[5];
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_listen_socket_postdec_54c.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__int_rand_sub_54d.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__char_fscanf_multiply_52b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data);
void var(char data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char data);
void var(char data)
{
    var(data);
}
void var(char data);
void var(char data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__int64_t_rand_predec_44.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
static void badSink(int64_t data)
{
    {
        --data;
        int64_t result = data;
        printLongLongLine(result);
    }
}
void var()
{
    int64_t data;
    void (*funcPtr) (int64_t) = badSink;
    data = 0LL;
    data = (int64_t)RAND64();
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(int64_t data)
{
    {
        --data;
        int64_t result = data;
        printLongLongLine(result);
    }
}
static void goodG2B()
{
    int64_t data;
    void (*funcPtr) (int64_t) = goodG2BSink;
    data = 0LL;
    data = -2;
    funcPtr(data);
}
static void goodB2GSink(int64_t data)
{
    if (data > LLONG_MIN)
    {
        --data;
        int64_t result = data;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodB2G()
{
    int64_t data;
    void (*funcPtr) (int64_t) = goodB2GSink;
    data = 0LL;
    data = (int64_t)RAND64();
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_fgets_sub_02.c,CWE191,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(1)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(1)
    {
        {
            int result = data - 1;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(1)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN)
        {
            int result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(1)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(1)
    {
        if (data > INT_MIN)
        {
            int result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(1)
    {
        {
            int result = data - 1;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(1)
    {
        data = -2;
    }
    if(1)
    {
        {
            int result = data - 1;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_fscanf_postdec_45.c,CWE191,good,"#include ""std_testcase.h""
static short var;
static short var;
static short var;
#ifndef OMITBAD
static void badSink()
{
    short data = var;
    {
        data--;
        short result = data;
        printIntLine(result);
    }
}
void var()
{
    short data;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    short data = var;
    {
        data--;
        short result = data;
        printIntLine(result);
    }
}
static void goodG2B()
{
    short data;
    data = 0;
    data = -2;
    var = data;
    goodG2BSink();
}
static void goodB2GSink()
{
    short data = var;
    if (data > SHRT_MIN)
    {
        data--;
        short result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodB2G()
{
    short data;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    var = data;
    goodB2GSink();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_min_predec_21.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
static int badStatic = 0;
static void badSink(char data)
{
    if(badStatic)
    {
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
void var()
{
    char data;
    data = ' ';
    data = CHAR_MIN;
    badStatic = 1; 
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static int goodB2G1Static = 0;
static int goodB2G2Static = 0;
static int goodG2BStatic = 0;
static void goodB2G1Sink(char data)
{
    if(goodB2G1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > CHAR_MIN)
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G1()
{
    char data;
    data = ' ';
    data = CHAR_MIN;
    goodB2G1Static = 0; 
    goodB2G1Sink(data);
}
static void goodB2G2Sink(char data)
{
    if(goodB2G2Static)
    {
        if (data > CHAR_MIN)
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    data = CHAR_MIN;
    goodB2G2Static = 1; 
    goodB2G2Sink(data);
}
static void goodG2BSink(char data)
{
    if(goodG2BStatic)
    {
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
static void goodG2B()
{
    char data;
    data = ' ';
    data = -2;
    goodG2BStatic = 1; 
    goodG2BSink(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_fscanf_predec_09.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        fscanf (stdin, ""%u"", &data);
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        fscanf (stdin, ""%u"", &data);
    }
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > 0)
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        fscanf (stdin, ""%u"", &data);
    }
    if(GLOBAL_CONST_TRUE)
    {
        if (data > 0)
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_TRUE)
    {
        data = -2;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_multiply_34.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
typedef union
{
    int unionFirst;
    int unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    int data;
    var myUnion;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int data;
    var myUnion;
    data = 0;
    data = -2;
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodB2G()
{
    int data;
    var myUnion;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        if(data < 0) 
        {
            if (data > (INT_MIN/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_min_sub_18.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    goto source;
source:
    data = INT_MIN;
    goto sink;
sink:
    {
        int result = data - 1;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int data;
    data = 0;
    goto source;
source:
    data = INT_MIN;
    goto sink;
sink:
    if (data > INT_MIN)
    {
        int result = data - 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    goto source;
source:
    data = -2;
    goto sink;
sink:
    {
        int result = data - 1;
        printIntLine(result);
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_listen_socket_multiply_05.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticTrue)
    {
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data < 0) 
        {
            if (data > (INT_MIN/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticTrue)
    {
        if(data < 0) 
        {
            if (data > (INT_MIN/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(staticTrue)
    {
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(staticTrue)
    {
        data = -2;
    }
    if(staticTrue)
    {
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_fscanf_predec_61a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
int var(int data);
void var()
{
    int data;
    data = 0;
    data = var(data);
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
int var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = var(data);
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
int var(int data);
static void goodB2G()
{
    int data;
    data = 0;
    data = var(data);
    if (data > INT_MIN)
    {
        --data;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_min_multiply_52a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data);
void var()
{
    int data;
    data = 0;
    data = INT_MIN;
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = -2;
    var(data);
}
void var(int data);
static void goodB2G()
{
    int data;
    data = 0;
    data = INT_MIN;
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_predec_07.c,CWE191,bad,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
static int staticFive = 5;
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(staticFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticFive==5)
    {
        {
            --data;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(staticFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN)
        {
            --data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(staticFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticFive==5)
    {
        if (data > INT_MIN)
        {
            --data;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(staticFive==5)
    {
        {
            --data;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(staticFive==5)
    {
        data = -2;
    }
    if(staticFive==5)
    {
        {
            --data;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_fgets_sub_53d.c,CWE191,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data)
{
    {
        int result = data - 1;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    {
        int result = data - 1;
        printIntLine(result);
    }
}
void var(int data)
{
    if (data > INT_MIN)
    {
        int result = data - 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
#endif"
CWE191_Integer_Underflow__short_fscanf_multiply_54c.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data);
void var(short data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(short data);
void var(short data)
{
    var(data);
}
void var(short data);
void var(short data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__short_min_sub_66a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short dataArray[]);
void var()
{
    short data;
    short dataArray[5];
    data = 0;
    data = SHRT_MIN;
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(short dataArray[]);
static void goodG2B()
{
    short data;
    short dataArray[5];
    data = 0;
    data = -2;
    dataArray[2] = data;
    var(dataArray);
}
void var(short dataArray[]);
static void goodB2G()
{
    short data;
    short dataArray[5];
    data = 0;
    data = SHRT_MIN;
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_sub_51a.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data);
void var()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = -2;
    var(data);
}
void var(int data);
static void goodB2G()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_rand_sub_54d.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data);
void var(char data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char data);
void var(char data)
{
    var(data);
}
void var(char data);
void var(char data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_sub_32.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    unsigned int *dataPtr1 = &data;
    unsigned int *dataPtr2 = &data;
    data = 0;
    {
        unsigned int data = *dataPtr1;
        data = (unsigned int)RAND32();
        *dataPtr1 = data;
    }
    {
        unsigned int data = *dataPtr2;
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    unsigned int data;
    unsigned int *dataPtr1 = &data;
    unsigned int *dataPtr2 = &data;
    data = 0;
    {
        unsigned int data = *dataPtr1;
        data = -2;
        *dataPtr1 = data;
    }
    {
        unsigned int data = *dataPtr2;
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
    }
}
static void goodB2G()
{
    unsigned int data;
    unsigned int *dataPtr1 = &data;
    unsigned int *dataPtr2 = &data;
    data = 0;
    {
        unsigned int data = *dataPtr1;
        data = (unsigned int)RAND32();
        *dataPtr1 = data;
    }
    {
        unsigned int data = *dataPtr2;
        if (data > 0)
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_fscanf_sub_06.c,CWE191,good,"#include <inttypes.h>
#include ""std_testcase.h""
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(STATIC_CONST_FIVE==5)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int64_t result = data - 1;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(STATIC_CONST_FIVE==5)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > LLONG_MIN)
        {
            int64_t result = data - 1;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(STATIC_CONST_FIVE==5)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        if (data > LLONG_MIN)
        {
            int64_t result = data - 1;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int64_t result = data - 1;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(STATIC_CONST_FIVE==5)
    {
        data = -2;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int64_t result = data - 1;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_fscanf_sub_14.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(globalFive==5)
    {
        fscanf (stdin, ""%u"", &data);
    }
    if(globalFive==5)
    {
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(globalFive==5)
    {
        fscanf (stdin, ""%u"", &data);
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > 0)
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(globalFive==5)
    {
        fscanf (stdin, ""%u"", &data);
    }
    if(globalFive==5)
    {
        if (data > 0)
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(globalFive==5)
    {
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(globalFive==5)
    {
        data = -2;
    }
    if(globalFive==5)
    {
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_fscanf_postdec_52a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data);
void var()
{
    int data;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = -2;
    var(data);
}
void var(int data);
static void goodB2G()
{
    int data;
    data = 0;
    fscanf(stdin, ""%d"", &data);
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_min_sub_34.c,CWE191,bad,"#include ""std_testcase.h""
typedef union
{
    int64_t unionFirst;
    int64_t unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    int64_t data;
    var myUnion;
    data = 0LL;
    data = LLONG_MIN;
    myUnion.unionFirst = data;
    {
        int64_t data = myUnion.unionSecond;
        {
            int64_t result = data - 1;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int64_t data;
    var myUnion;
    data = 0LL;
    data = -2;
    myUnion.unionFirst = data;
    {
        int64_t data = myUnion.unionSecond;
        {
            int64_t result = data - 1;
            printLongLongLine(result);
        }
    }
}
static void goodB2G()
{
    int64_t data;
    var myUnion;
    data = 0LL;
    data = LLONG_MIN;
    myUnion.unionFirst = data;
    {
        int64_t data = myUnion.unionSecond;
        if (data > LLONG_MIN)
        {
            int64_t result = data - 1;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_min_postdec_13.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = 0;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            data--;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = 0;
    }
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > 0)
        {
            data--;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = 0;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if (data > 0)
        {
            data--;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            data--;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = -2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            data--;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_predec_16.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    while(1)
    {
        data = (unsigned int)RAND32();
        break;
    }
    while(1)
    {
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    unsigned int data;
    data = 0;
    while(1)
    {
        data = (unsigned int)RAND32();
        break;
    }
    while(1)
    {
        if (data > 0)
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
        break;
    }
}
static void goodG2B()
{
    unsigned int data;
    data = 0;
    while(1)
    {
        data = -2;
        break;
    }
    while(1)
    {
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        break;
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_min_postdec_63b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * dataPtr)
{
    int64_t data = *dataPtr;
    {
        data--;
        int64_t result = data;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int64_t * dataPtr)
{
    int64_t data = *dataPtr;
    {
        data--;
        int64_t result = data;
        printLongLongLine(result);
    }
}
void var(int64_t * dataPtr)
{
    int64_t data = *dataPtr;
    if (data > LLONG_MIN)
    {
        data--;
        int64_t result = data;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__int_fgets_postdec_64b.c,CWE191,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    int * dataPtr = (int *)dataVoidPtr;
    int data = (*dataPtr);
    {
        data--;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    int * dataPtr = (int *)dataVoidPtr;
    int data = (*dataPtr);
    {
        data--;
        int result = data;
        printIntLine(result);
    }
}
void var(void * dataVoidPtr)
{
    int * dataPtr = (int *)dataVoidPtr;
    int data = (*dataPtr);
    if (data > INT_MIN)
    {
        data--;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__char_rand_predec_63b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char * dataPtr)
{
    char data = *dataPtr;
    {
        --data;
        char result = data;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * dataPtr)
{
    char data = *dataPtr;
    {
        --data;
        char result = data;
        printHexCharLine(result);
    }
}
void var(char * dataPtr)
{
    char data = *dataPtr;
    if (data > CHAR_MIN)
    {
        --data;
        char result = data;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__int_fgets_predec_53c.c,CWE191,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__int_fscanf_multiply_61a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
int var(int data);
void var()
{
    int data;
    data = 0;
    data = var(data);
    if(data < 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
int var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = var(data);
    if(data < 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
int var(int data);
static void goodB2G()
{
    int data;
    data = 0;
    data = var(data);
    if(data < 0) 
    {
        if (data > (INT_MIN/2))
        {
            int result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_fscanf_sub_68a.c,CWE191,good,"#include ""std_testcase.h""
unsigned int var;
unsigned int var;
unsigned int var;
#ifndef OMITBAD
void var();
void var()
{
    unsigned int data;
    data = 0;
    fscanf (stdin, ""%u"", &data);
    var = data;
    var();
}
#endif 
#ifndef OMITGOOD
void var();
void var();
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = -2;
    var = data;
    var();
}
static void goodB2G()
{
    unsigned int data;
    data = 0;
    fscanf (stdin, ""%u"", &data);
    var = data;
    var();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_fscanf_sub_54d.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__int64_t_fscanf_postdec_52c.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data)
{
    {
        data--;
        int64_t result = data;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int64_t data)
{
    {
        data--;
        int64_t result = data;
        printLongLongLine(result);
    }
}
void var(int64_t data)
{
    if (data > LLONG_MIN)
    {
        data--;
        int64_t result = data;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_sub_65a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data);
void var()
{
    unsigned int data;
    void (*funcPtr) (unsigned int) = var;
    data = 0;
    data = (unsigned int)RAND32();
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data);
static void goodG2B()
{
    unsigned int data;
    void (*funcPtr) (unsigned int) = var;
    data = 0;
    data = -2;
    funcPtr(data);
}
void var(unsigned int data);
static void goodB2G()
{
    unsigned int data;
    void (*funcPtr) (unsigned int) = var;
    data = 0;
    data = (unsigned int)RAND32();
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_sub_67b.c,CWE191,good,"#include ""std_testcase.h""
typedef struct _CWE191_Integer_Underflow__unsigned_int_rand_sub_67_structType
{
    unsigned int structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct)
{
    unsigned int data = myStruct.structFirst;
    {
        unsigned int result = data - 1;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(var myStruct)
{
    unsigned int data = myStruct.structFirst;
    {
        unsigned int result = data - 1;
        printUnsignedLine(result);
    }
}
void var(var myStruct)
{
    unsigned int data = myStruct.structFirst;
    if (data > 0)
    {
        unsigned int result = data - 1;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
#endif"
CWE191_Integer_Underflow__unsigned_int_fscanf_predec_65a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data);
void var()
{
    unsigned int data;
    void (*funcPtr) (unsigned int) = var;
    data = 0;
    fscanf (stdin, ""%u"", &data);
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data);
static void goodG2B()
{
    unsigned int data;
    void (*funcPtr) (unsigned int) = var;
    data = 0;
    data = -2;
    funcPtr(data);
}
void var(unsigned int data);
static void goodB2G()
{
    unsigned int data;
    void (*funcPtr) (unsigned int) = var;
    data = 0;
    fscanf (stdin, ""%u"", &data);
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_rand_multiply_63a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * dataPtr);
void var()
{
    int64_t data;
    data = 0LL;
    data = (int64_t)RAND64();
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t * data);
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = -2;
    var(&data);
}
void var(int64_t * data);
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    data = (int64_t)RAND64();
    var(&data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_predec_54a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data);
void var()
{
    unsigned int data;
    data = 0;
    data = (unsigned int)RAND32();
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data);
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = -2;
    var(data);
}
void var(unsigned int data);
static void goodB2G()
{
    unsigned int data;
    data = 0;
    data = (unsigned int)RAND32();
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_min_predec_22b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
extern int var;
void var(short data)
{
    if(var)
    {
        {
            --data;
            short result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
extern int var;
extern int var;
extern int var;
void var(short data)
{
    if(var)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > SHRT_MIN)
        {
            --data;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var(short data)
{
    if(var)
    {
        if (data > SHRT_MIN)
        {
            --data;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var(short data)
{
    if(var)
    {
        {
            --data;
            short result = data;
            printIntLine(result);
        }
    }
}
#endif"
CWE191_Integer_Underflow__int_fgets_multiply_14.c,CWE191,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(globalFive==5)
    {
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data < 0) 
        {
            if (data > (INT_MIN/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(globalFive==5)
    {
        if(data < 0) 
        {
            if (data > (INT_MIN/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(globalFive==5)
    {
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        data = -2;
    }
    if(globalFive==5)
    {
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_postdec_18.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    goto source;
source:
    data = (unsigned int)RAND32();
    goto sink;
sink:
    {
        data--;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    unsigned int data;
    data = 0;
    goto source;
source:
    data = (unsigned int)RAND32();
    goto sink;
sink:
    if (data > 0)
    {
        data--;
        unsigned int result = data;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodG2B()
{
    unsigned int data;
    data = 0;
    goto source;
source:
    data = -2;
    goto sink;
sink:
    {
        data--;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_listen_socket_postdec_14.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFive==5)
    {
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN)
        {
            data--;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFive==5)
    {
        if (data > INT_MIN)
        {
            data--;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(globalFive==5)
    {
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        data = -2;
    }
    if(globalFive==5)
    {
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_rand_sub_16.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    while(1)
    {
        data = (int64_t)RAND64();
        break;
    }
    while(1)
    {
        {
            int64_t result = data - 1;
            printLongLongLine(result);
        }
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    while(1)
    {
        data = (int64_t)RAND64();
        break;
    }
    while(1)
    {
        if (data > LLONG_MIN)
        {
            int64_t result = data - 1;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
        break;
    }
}
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    while(1)
    {
        data = -2;
        break;
    }
    while(1)
    {
        {
            int64_t result = data - 1;
            printLongLongLine(result);
        }
        break;
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_rand_multiply_32.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    data = 0;
    {
        int data = *dataPtr1;
        data = RAND32();
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    data = 0;
    {
        int data = *dataPtr1;
        data = -2;
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodB2G()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    data = 0;
    {
        int data = *dataPtr1;
        data = RAND32();
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        if(data < 0) 
        {
            if (data > (INT_MIN/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_sub_54d.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_08.c,CWE191,good,"#include ""std_testcase.h""
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(staticReturnsTrue())
    {
        fscanf (stdin, ""%u"", &data);
    }
    if(staticReturnsTrue())
    {
        {
            data--;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(staticReturnsTrue())
    {
        fscanf (stdin, ""%u"", &data);
    }
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > 0)
        {
            data--;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(staticReturnsTrue())
    {
        fscanf (stdin, ""%u"", &data);
    }
    if(staticReturnsTrue())
    {
        if (data > 0)
        {
            data--;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(staticReturnsTrue())
    {
        {
            data--;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(staticReturnsTrue())
    {
        data = -2;
    }
    if(staticReturnsTrue())
    {
        {
            data--;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_min_postdec_32.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    char *dataPtr1 = &data;
    char *dataPtr2 = &data;
    data = ' ';
    {
        char data = *dataPtr1;
        data = CHAR_MIN;
        *dataPtr1 = data;
    }
    {
        char data = *dataPtr2;
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char data;
    char *dataPtr1 = &data;
    char *dataPtr2 = &data;
    data = ' ';
    {
        char data = *dataPtr1;
        data = -2;
        *dataPtr1 = data;
    }
    {
        char data = *dataPtr2;
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
    }
}
static void goodB2G()
{
    char data;
    char *dataPtr1 = &data;
    char *dataPtr2 = &data;
    data = ' ';
    {
        char data = *dataPtr1;
        data = CHAR_MIN;
        *dataPtr1 = data;
    }
    {
        char data = *dataPtr2;
        if (data > CHAR_MIN)
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_rand_multiply_04.c,CWE191,good,"#include ""std_testcase.h""
static const int STATIC_CONST_TRUE = 1; 
static const int STATIC_CONST_FALSE = 0; 
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(STATIC_CONST_TRUE)
    {
        data = (char)RAND32();
    }
    if(STATIC_CONST_TRUE)
    {
        if(data < 0) 
        {
            char result = data * 2;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(STATIC_CONST_TRUE)
    {
        data = (char)RAND32();
    }
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data < 0) 
        {
            if (data > (CHAR_MIN/2))
            {
                char result = data * 2;
                printHexCharLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(STATIC_CONST_TRUE)
    {
        data = (char)RAND32();
    }
    if(STATIC_CONST_TRUE)
    {
        if(data < 0) 
        {
            if (data > (CHAR_MIN/2))
            {
                char result = data * 2;
                printHexCharLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(STATIC_CONST_TRUE)
    {
        if(data < 0) 
        {
            char result = data * 2;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(STATIC_CONST_TRUE)
    {
        data = -2;
    }
    if(STATIC_CONST_TRUE)
    {
        if(data < 0) 
        {
            char result = data * 2;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_listen_socket_postdec_63b.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int * dataPtr)
{
    int data = *dataPtr;
    {
        data--;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int * dataPtr)
{
    int data = *dataPtr;
    {
        data--;
        int result = data;
        printIntLine(result);
    }
}
void var(int * dataPtr)
{
    int data = *dataPtr;
    if (data > INT_MIN)
    {
        data--;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__short_min_predec_54a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data);
void var()
{
    short data;
    data = 0;
    data = SHRT_MIN;
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(short data);
static void goodG2B()
{
    short data;
    data = 0;
    data = -2;
    var(data);
}
void var(short data);
static void goodB2G()
{
    short data;
    data = 0;
    data = SHRT_MIN;
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_fscanf_postdec_54c.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
void var(int64_t data);
void var(int64_t data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__char_min_sub_63a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char * dataPtr);
void var()
{
    char data;
    data = ' ';
    data = CHAR_MIN;
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
static void goodG2B()
{
    char data;
    data = ' ';
    data = -2;
    var(&data);
}
void var(char * data);
static void goodB2G()
{
    char data;
    data = ' ';
    data = CHAR_MIN;
    var(&data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_fgets_postdec_61a.c,CWE191,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
int var(int data);
void var()
{
    int data;
    data = 0;
    data = var(data);
    {
        data--;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
int var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = var(data);
    {
        data--;
        int result = data;
        printIntLine(result);
    }
}
int var(int data);
static void goodB2G()
{
    int data;
    data = 0;
    data = var(data);
    if (data > INT_MIN)
    {
        data--;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_rand_postdec_05.c,CWE191,good,"#include ""std_testcase.h""
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(staticTrue)
    {
        data = RAND32();
    }
    if(staticTrue)
    {
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(staticTrue)
    {
        data = RAND32();
    }
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN)
        {
            data--;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(staticTrue)
    {
        data = RAND32();
    }
    if(staticTrue)
    {
        if (data > INT_MIN)
        {
            data--;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(staticTrue)
    {
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(staticTrue)
    {
        data = -2;
    }
    if(staticTrue)
    {
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_min_predec_14.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    if(globalFive==5)
    {
        data = SHRT_MIN;
    }
    if(globalFive==5)
    {
        {
            --data;
            short result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    short data;
    data = 0;
    if(globalFive==5)
    {
        data = SHRT_MIN;
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > SHRT_MIN)
        {
            --data;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    if(globalFive==5)
    {
        data = SHRT_MIN;
    }
    if(globalFive==5)
    {
        if (data > SHRT_MIN)
        {
            --data;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    short data;
    data = 0;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(globalFive==5)
    {
        {
            --data;
            short result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    short data;
    data = 0;
    if(globalFive==5)
    {
        data = -2;
    }
    if(globalFive==5)
    {
        {
            --data;
            short result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_rand_sub_64b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    short * dataPtr = (short *)dataVoidPtr;
    short data = (*dataPtr);
    {
        short result = data - 1;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    short * dataPtr = (short *)dataVoidPtr;
    short data = (*dataPtr);
    {
        short result = data - 1;
        printIntLine(result);
    }
}
void var(void * dataVoidPtr)
{
    short * dataPtr = (short *)dataVoidPtr;
    short data = (*dataPtr);
    if (data > SHRT_MIN)
    {
        short result = data - 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_postdec_02.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(1)
    {
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN)
        {
            data--;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(1)
    {
        if (data > INT_MIN)
        {
            data--;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(1)
    {
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(1)
    {
        data = -2;
    }
    if(1)
    {
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_rand_predec_08.c,CWE191,good,"#include ""std_testcase.h""
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(staticReturnsTrue())
    {
        data = (int64_t)RAND64();
    }
    if(staticReturnsTrue())
    {
        {
            --data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(staticReturnsTrue())
    {
        data = (int64_t)RAND64();
    }
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > LLONG_MIN)
        {
            --data;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(staticReturnsTrue())
    {
        data = (int64_t)RAND64();
    }
    if(staticReturnsTrue())
    {
        if (data > LLONG_MIN)
        {
            --data;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(staticReturnsTrue())
    {
        {
            --data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(staticReturnsTrue())
    {
        data = -2;
    }
    if(staticReturnsTrue())
    {
        {
            --data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_rand_postdec_52a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data);
void var()
{
    int64_t data;
    data = 0LL;
    data = (int64_t)RAND64();
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t data);
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = -2;
    var(data);
}
void var(int64_t data);
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    data = (int64_t)RAND64();
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_min_predec_68b.c,CWE191,good,"#include ""std_testcase.h""
extern short var;
extern short var;
extern short var;
#ifndef OMITBAD
void var()
{
    short data = var;
    {
        --data;
        short result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    short data = var;
    {
        --data;
        short result = data;
        printIntLine(result);
    }
}
void var()
{
    short data = var;
    if (data > SHRT_MIN)
    {
        --data;
        short result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_sub_41.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
static void badSink(int data)
{
    {
        int result = data - 1;
        printIntLine(result);
    }
}
void var()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(int data)
{
    {
        int result = data - 1;
        printIntLine(result);
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    data = -2;
    goodG2BSink(data);
}
static void goodB2GSink(int data)
{
    if (data > INT_MIN)
    {
        int result = data - 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
static void goodB2G()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    goodB2GSink(data);
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_predec_64b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    unsigned int * dataPtr = (unsigned int *)dataVoidPtr;
    unsigned int data = (*dataPtr);
    {
        --data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    unsigned int * dataPtr = (unsigned int *)dataVoidPtr;
    unsigned int data = (*dataPtr);
    {
        --data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
void var(void * dataVoidPtr)
{
    unsigned int * dataPtr = (unsigned int *)dataVoidPtr;
    unsigned int data = (*dataPtr);
    if (data > 0)
    {
        --data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__int_fscanf_sub_18.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    goto source;
source:
    fscanf(stdin, ""%d"", &data);
    goto sink;
sink:
    {
        int result = data - 1;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int data;
    data = 0;
    goto source;
source:
    fscanf(stdin, ""%d"", &data);
    goto sink;
sink:
    if (data > INT_MIN)
    {
        int result = data - 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    goto source;
source:
    data = -2;
    goto sink;
sink:
    {
        int result = data - 1;
        printIntLine(result);
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_postdec_17.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int i,j;
    int data;
    data = 0;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    for(j = 0; j < 1; j++)
    {
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int i,k;
    int data;
    data = 0;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    for(k = 0; k < 1; k++)
    {
        if (data > INT_MIN)
        {
            data--;
            int result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B()
{
    int h,j;
    int data;
    data = 0;
    for(h = 0; h < 1; h++)
    {
        data = -2;
    }
    for(j = 0; j < 1; j++)
    {
        {
            data--;
            int result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_min_sub_51b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data)
{
    {
        char result = data - 1;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(char data)
{
    {
        char result = data - 1;
        printHexCharLine(result);
    }
}
void var(char data)
{
    if (data > CHAR_MIN)
    {
        char result = data - 1;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
#endif"
CWE191_Integer_Underflow__char_rand_postdec_03.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(5==5)
    {
        data = (char)RAND32();
    }
    if(5==5)
    {
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(5==5)
    {
        data = (char)RAND32();
    }
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > CHAR_MIN)
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(5==5)
    {
        data = (char)RAND32();
    }
    if(5==5)
    {
        if (data > CHAR_MIN)
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(5==5)
    {
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(5==5)
    {
        data = -2;
    }
    if(5==5)
    {
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_multiply_17.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int i,j;
    int data;
    data = 0;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    for(j = 0; j < 1; j++)
    {
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int i,k;
    int data;
    data = 0;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    for(k = 0; k < 1; k++)
    {
        if(data < 0) 
        {
            if (data > (INT_MIN/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodG2B()
{
    int h,j;
    int data;
    data = 0;
    for(h = 0; h < 1; h++)
    {
        data = -2;
    }
    for(j = 0; j < 1; j++)
    {
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_54e.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data)
{
    {
        data--;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data)
{
    {
        data--;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
void var(unsigned int data)
{
    if (data > 0)
    {
        data--;
        unsigned int result = data;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__int_rand_multiply_52c.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data)
{
    if(data < 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    if(data < 0) 
    {
        int result = data * 2;
        printIntLine(result);
    }
}
void var(int data)
{
    if(data < 0) 
    {
        if (data > (INT_MIN/2))
        {
            int result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
#endif"
CWE191_Integer_Underflow__int_fgets_predec_52c.c,CWE191,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data)
{
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
void var(int data)
{
    if (data > INT_MIN)
    {
        --data;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__int64_t_rand_predec_51b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data)
{
    {
        --data;
        int64_t result = data;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int64_t data)
{
    {
        --data;
        int64_t result = data;
        printLongLongLine(result);
    }
}
void var(int64_t data)
{
    if (data > LLONG_MIN)
    {
        --data;
        int64_t result = data;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__char_rand_postdec_22b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
extern int var;
void var(char data)
{
    if(var)
    {
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
extern int var;
extern int var;
extern int var;
void var(char data)
{
    if(var)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > CHAR_MIN)
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var(char data)
{
    if(var)
    {
        if (data > CHAR_MIN)
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var(char data)
{
    if(var)
    {
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
    }
}
#endif"
CWE191_Integer_Underflow__int64_t_fscanf_multiply_13.c,CWE191,bad,"#include <inttypes.h>
#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE==5)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE==5)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data < 0) 
        {
            if (data > (LLONG_MIN/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE==5)
    {
        fscanf (stdin, ""%"" SCNd64, &data);
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data < 0) 
        {
            if (data > (LLONG_MIN/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = -2;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_fscanf_predec_53a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data);
void var()
{
    short data;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(short data);
static void goodG2B()
{
    short data;
    data = 0;
    data = -2;
    var(data);
}
void var(short data);
static void goodB2G()
{
    short data;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_rand_multiply_54e.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data)
{
    if(data < 0) 
    {
        char result = data * 2;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(char data)
{
    if(data < 0) 
    {
        char result = data * 2;
        printHexCharLine(result);
    }
}
void var(char data)
{
    if(data < 0) 
    {
        if (data > (CHAR_MIN/2))
        {
            char result = data * 2;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
#endif"
CWE191_Integer_Underflow__int_fgets_sub_06.c,CWE191,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int result = data - 1;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > INT_MIN)
        {
            int result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        if (data > INT_MIN)
        {
            int result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int result = data - 1;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(STATIC_CONST_FIVE==5)
    {
        data = -2;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int result = data - 1;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_listen_socket_multiply_14.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFive==5)
    {
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data < 0) 
        {
            if (data > (INT_MIN/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFive==5)
    {
        if(data < 0) 
        {
            if (data > (INT_MIN/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(globalFive==5)
    {
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        data = -2;
    }
    if(globalFive==5)
    {
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_sub_53c.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__short_rand_multiply_66b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short dataArray[])
{
    short data = dataArray[2];
    if(data < 0) 
    {
        short result = data * 2;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(short dataArray[])
{
    short data = dataArray[2];
    if(data < 0) 
    {
        short result = data * 2;
        printIntLine(result);
    }
}
void var(short dataArray[])
{
    short data = dataArray[2];
    if(data < 0) 
    {
        if (data > (SHRT_MIN/2))
        {
            short result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
#endif"
CWE191_Integer_Underflow__int_fgets_sub_52a.c,CWE191,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data);
void var()
{
    int data;
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = -2;
    var(data);
}
void var(int data);
static void goodB2G()
{
    int data;
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_postdec_64a.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(void * dataVoidPtr);
void var()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr);
static void goodG2B()
{
    int data;
    data = 0;
    data = -2;
    var(&data);
}
void var(void * dataVoidPtr);
static void goodB2G()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var(&data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_fscanf_postdec_15.c,CWE191,good,"#include <inttypes.h>
#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    switch(6)
    {
    case 6:
        fscanf (stdin, ""%"" SCNd64, &data);
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        data--;
        int64_t result = data;
        printLongLongLine(result);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    switch(6)
    {
    case 6:
        fscanf (stdin, ""%"" SCNd64, &data);
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(8)
    {
    case 7:
        printLine(""Benign, fixed string"");
        break;
    default:
        if (data > LLONG_MIN)
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
        break;
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    switch(6)
    {
    case 6:
        fscanf (stdin, ""%"" SCNd64, &data);
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        if (data > LLONG_MIN)
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        data = -2;
        break;
    }
    switch(7)
    {
    case 7:
    {
        data--;
        int64_t result = data;
        printLongLongLine(result);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    switch(6)
    {
    case 6:
        data = -2;
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        data--;
        int64_t result = data;
        printLongLongLine(result);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_rand_postdec_07.c,CWE191,good,"#include ""std_testcase.h""
static int staticFive = 5;
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(staticFive==5)
    {
        data = (char)RAND32();
    }
    if(staticFive==5)
    {
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(staticFive==5)
    {
        data = (char)RAND32();
    }
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > CHAR_MIN)
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(staticFive==5)
    {
        data = (char)RAND32();
    }
    if(staticFive==5)
    {
        if (data > CHAR_MIN)
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(staticFive==5)
    {
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(staticFive==5)
    {
        data = -2;
    }
    if(staticFive==5)
    {
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_min_predec_61a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
int64_t var(int64_t data);
void var()
{
    int64_t data;
    data = 0LL;
    data = var(data);
    {
        --data;
        int64_t result = data;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
int64_t var(int64_t data);
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = var(data);
    {
        --data;
        int64_t result = data;
        printLongLongLine(result);
    }
}
int64_t var(int64_t data);
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    data = var(data);
    if (data > LLONG_MIN)
    {
        --data;
        int64_t result = data;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_rand_sub_10.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    if(globalTrue)
    {
        data = (short)RAND32();
    }
    if(globalTrue)
    {
        {
            short result = data - 1;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    short data;
    data = 0;
    if(globalTrue)
    {
        data = (short)RAND32();
    }
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > SHRT_MIN)
        {
            short result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    if(globalTrue)
    {
        data = (short)RAND32();
    }
    if(globalTrue)
    {
        if (data > SHRT_MIN)
        {
            short result = data - 1;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodG2B1()
{
    short data;
    data = 0;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(globalTrue)
    {
        {
            short result = data - 1;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    short data;
    data = 0;
    if(globalTrue)
    {
        data = -2;
    }
    if(globalTrue)
    {
        {
            short result = data - 1;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_min_predec_66a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int dataArray[]);
void var()
{
    int data;
    int dataArray[5];
    data = 0;
    data = INT_MIN;
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(int dataArray[]);
static void goodG2B()
{
    int data;
    int dataArray[5];
    data = 0;
    data = -2;
    dataArray[2] = data;
    var(dataArray);
}
void var(int dataArray[]);
static void goodB2G()
{
    int data;
    int dataArray[5];
    data = 0;
    data = INT_MIN;
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_fgets_predec_01.c,CWE191,bad,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int data;
    data = 0;
    data = -2;
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
static void goodB2G()
{
    int data;
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    if (data > INT_MIN)
    {
        --data;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_rand_predec_14.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    if(globalFive==5)
    {
        data = (short)RAND32();
    }
    if(globalFive==5)
    {
        {
            --data;
            short result = data;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    short data;
    data = 0;
    if(globalFive==5)
    {
        data = (short)RAND32();
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > SHRT_MIN)
        {
            --data;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    if(globalFive==5)
    {
        data = (short)RAND32();
    }
    if(globalFive==5)
    {
        if (data > SHRT_MIN)
        {
            --data;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    short data;
    data = 0;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(globalFive==5)
    {
        {
            --data;
            short result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    short data;
    data = 0;
    if(globalFive==5)
    {
        data = -2;
    }
    if(globalFive==5)
    {
        {
            --data;
            short result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_min_sub_44.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
static void badSink(char data)
{
    {
        char result = data - 1;
        printHexCharLine(result);
    }
}
void var()
{
    char data;
    void (*funcPtr) (char) = badSink;
    data = ' ';
    data = CHAR_MIN;
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(char data)
{
    {
        char result = data - 1;
        printHexCharLine(result);
    }
}
static void goodG2B()
{
    char data;
    void (*funcPtr) (char) = goodG2BSink;
    data = ' ';
    data = -2;
    funcPtr(data);
}
static void goodB2GSink(char data)
{
    if (data > CHAR_MIN)
    {
        char result = data - 1;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
static void goodB2G()
{
    char data;
    void (*funcPtr) (char) = goodB2GSink;
    data = ' ';
    data = CHAR_MIN;
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_predec_44.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
static void badSink(unsigned int data)
{
    {
        --data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
void var()
{
    unsigned int data;
    void (*funcPtr) (unsigned int) = badSink;
    data = 0;
    data = (unsigned int)RAND32();
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(unsigned int data)
{
    {
        --data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
static void goodG2B()
{
    unsigned int data;
    void (*funcPtr) (unsigned int) = goodG2BSink;
    data = 0;
    data = -2;
    funcPtr(data);
}
static void goodB2GSink(unsigned int data)
{
    if (data > 0)
    {
        --data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodB2G()
{
    unsigned int data;
    void (*funcPtr) (unsigned int) = goodB2GSink;
    data = 0;
    data = (unsigned int)RAND32();
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_rand_postdec_54e.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data)
{
    {
        data--;
        short result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(short data)
{
    {
        data--;
        short result = data;
        printIntLine(result);
    }
}
void var(short data)
{
    if (data > SHRT_MIN)
    {
        data--;
        short result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__char_min_multiply_41.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
static void badSink(char data)
{
    if(data < 0) 
    {
        char result = data * 2;
        printHexCharLine(result);
    }
}
void var()
{
    char data;
    data = ' ';
    data = CHAR_MIN;
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(char data)
{
    if(data < 0) 
    {
        char result = data * 2;
        printHexCharLine(result);
    }
}
static void goodG2B()
{
    char data;
    data = ' ';
    data = -2;
    goodG2BSink(data);
}
static void goodB2GSink(char data)
{
    if(data < 0) 
    {
        if (data > (CHAR_MIN/2))
        {
            char result = data * 2;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
static void goodB2G()
{
    char data;
    data = ' ';
    data = CHAR_MIN;
    goodB2GSink(data);
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_predec_61b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
unsigned int var(unsigned int data)
{
    data = (unsigned int)RAND32();
    return data;
}
#endif 
#ifndef OMITGOOD
unsigned int var(unsigned int data)
{
    data = -2;
    return data;
}
unsigned int var(unsigned int data)
{
    data = (unsigned int)RAND32();
    return data;
}
#endif"
CWE191_Integer_Underflow__short_min_postdec_53a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data);
void var()
{
    short data;
    data = 0;
    data = SHRT_MIN;
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(short data);
static void goodG2B()
{
    short data;
    data = 0;
    data = -2;
    var(data);
}
void var(short data);
static void goodB2G()
{
    short data;
    data = 0;
    data = SHRT_MIN;
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_fscanf_predec_11.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(globalReturnsTrue())
    {
        fscanf (stdin, ""%c"", &data);
    }
    if(globalReturnsTrue())
    {
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(globalReturnsTrue())
    {
        fscanf (stdin, ""%c"", &data);
    }
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > CHAR_MIN)
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(globalReturnsTrue())
    {
        fscanf (stdin, ""%c"", &data);
    }
    if(globalReturnsTrue())
    {
        if (data > CHAR_MIN)
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(globalReturnsTrue())
    {
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(globalReturnsTrue())
    {
        data = -2;
    }
    if(globalReturnsTrue())
    {
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_fscanf_multiply_05.c,CWE191,bad,"#include ""std_testcase.h""
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    if(staticTrue)
    {
        fscanf (stdin, ""%hd"", &data);
    }
    if(staticTrue)
    {
        if(data < 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    short data;
    data = 0;
    if(staticTrue)
    {
        fscanf (stdin, ""%hd"", &data);
    }
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data < 0) 
        {
            if (data > (SHRT_MIN/2))
            {
                short result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    if(staticTrue)
    {
        fscanf (stdin, ""%hd"", &data);
    }
    if(staticTrue)
    {
        if(data < 0) 
        {
            if (data > (SHRT_MIN/2))
            {
                short result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodG2B1()
{
    short data;
    data = 0;
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(staticTrue)
    {
        if(data < 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    short data;
    data = 0;
    if(staticTrue)
    {
        data = -2;
    }
    if(staticTrue)
    {
        if(data < 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_fgets_predec_61a.c,CWE191,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
int var(int data);
void var()
{
    int data;
    data = 0;
    data = var(data);
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
int var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = var(data);
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
int var(int data);
static void goodB2G()
{
    int data;
    data = 0;
    data = var(data);
    if (data > INT_MIN)
    {
        --data;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_rand_sub_22b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
extern int var;
void var(char data)
{
    if(var)
    {
        {
            char result = data - 1;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
extern int var;
extern int var;
extern int var;
void var(char data)
{
    if(var)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > CHAR_MIN)
        {
            char result = data - 1;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
void var(char data)
{
    if(var)
    {
        if (data > CHAR_MIN)
        {
            char result = data - 1;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
void var(char data)
{
    if(var)
    {
        {
            char result = data - 1;
            printHexCharLine(result);
        }
    }
}
#endif"
CWE191_Integer_Underflow__short_rand_multiply_67a.c,CWE191,good,"#include ""std_testcase.h""
typedef struct _CWE191_Integer_Underflow__short_rand_multiply_67_structType
{
    short structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct);
void var()
{
    short data;
    var myStruct;
    data = 0;
    data = (short)RAND32();
    myStruct.structFirst = data;
    var(myStruct);
}
#endif 
#ifndef OMITGOOD
void var(var myStruct);
static void goodG2B()
{
    short data;
    var myStruct;
    data = 0;
    data = -2;
    myStruct.structFirst = data;
    var(myStruct);
}
void var(var myStruct);
static void goodB2G()
{
    short data;
    var myStruct;
    data = 0;
    data = (short)RAND32();
    myStruct.structFirst = data;
    var(myStruct);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_sub_63b.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int * dataPtr)
{
    int data = *dataPtr;
    {
        int result = data - 1;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int * dataPtr)
{
    int data = *dataPtr;
    {
        int result = data - 1;
        printIntLine(result);
    }
}
void var(int * dataPtr)
{
    int data = *dataPtr;
    if (data > INT_MIN)
    {
        int result = data - 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
#endif"
CWE191_Integer_Underflow__short_min_multiply_02.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    if(1)
    {
        data = SHRT_MIN;
    }
    if(1)
    {
        if(data < 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    short data;
    data = 0;
    if(1)
    {
        data = SHRT_MIN;
    }
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data < 0) 
        {
            if (data > (SHRT_MIN/2))
            {
                short result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    if(1)
    {
        data = SHRT_MIN;
    }
    if(1)
    {
        if(data < 0) 
        {
            if (data > (SHRT_MIN/2))
            {
                short result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodG2B1()
{
    short data;
    data = 0;
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(1)
    {
        if(data < 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    short data;
    data = 0;
    if(1)
    {
        data = -2;
    }
    if(1)
    {
        if(data < 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_min_postdec_54c.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__int_listen_socket_predec_65a.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data);
void var()
{
    int data;
    void (*funcPtr) (int) = var;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
static void goodG2B()
{
    int data;
    void (*funcPtr) (int) = var;
    data = 0;
    data = -2;
    funcPtr(data);
}
void var(int data);
static void goodB2G()
{
    int data;
    void (*funcPtr) (int) = var;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_postdec_54c.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
void var(unsigned int data);
void var(unsigned int data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__int_rand_predec_18.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    goto source;
source:
    data = RAND32();
    goto sink;
sink:
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int data;
    data = 0;
    goto source;
source:
    data = RAND32();
    goto sink;
sink:
    if (data > INT_MIN)
    {
        --data;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodG2B()
{
    int data;
    data = 0;
    goto source;
source:
    data = -2;
    goto sink;
sink:
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_fgets_multiply_52a.c,CWE191,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data);
void var()
{
    int data;
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = -2;
    var(data);
}
void var(int data);
static void goodB2G()
{
    int data;
    data = 0;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_predec_52c.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data)
{
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
void var(int data)
{
    if (data > INT_MIN)
    {
        --data;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__int64_t_fscanf_sub_18.c,CWE191,bad,"#include <inttypes.h>
#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    goto source;
source:
    fscanf (stdin, ""%"" SCNd64, &data);
    goto sink;
sink:
    {
        int64_t result = data - 1;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    goto source;
source:
    fscanf (stdin, ""%"" SCNd64, &data);
    goto sink;
sink:
    if (data > LLONG_MIN)
    {
        int64_t result = data - 1;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    goto source;
source:
    data = -2;
    goto sink;
sink:
    {
        int64_t result = data - 1;
        printLongLongLine(result);
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_fscanf_multiply_15.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    switch(6)
    {
    case 6:
        fscanf (stdin, ""%hd"", &data);
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        if(data < 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    short data;
    data = 0;
    switch(6)
    {
    case 6:
        fscanf (stdin, ""%hd"", &data);
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(8)
    {
    case 7:
        printLine(""Benign, fixed string"");
        break;
    default:
        if(data < 0) 
        {
            if (data > (SHRT_MIN/2))
            {
                short result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
        break;
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    switch(6)
    {
    case 6:
        fscanf (stdin, ""%hd"", &data);
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        if(data < 0) 
        {
            if (data > (SHRT_MIN/2))
            {
                short result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B1()
{
    short data;
    data = 0;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        data = -2;
        break;
    }
    switch(7)
    {
    case 7:
        if(data < 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B2()
{
    short data;
    data = 0;
    switch(6)
    {
    case 6:
        data = -2;
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        if(data < 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_rand_postdec_16.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    while(1)
    {
        data = (char)RAND32();
        break;
    }
    while(1)
    {
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    char data;
    data = ' ';
    while(1)
    {
        data = (char)RAND32();
        break;
    }
    while(1)
    {
        if (data > CHAR_MIN)
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
        break;
    }
}
static void goodG2B()
{
    char data;
    data = ' ';
    while(1)
    {
        data = -2;
        break;
    }
    while(1)
    {
        {
            data--;
            char result = data;
            printHexCharLine(result);
        }
        break;
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_rand_multiply_64a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(void * dataVoidPtr);
void var()
{
    int64_t data;
    data = 0LL;
    data = (int64_t)RAND64();
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr);
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = -2;
    var(&data);
}
void var(void * dataVoidPtr);
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    data = (int64_t)RAND64();
    var(&data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_rand_sub_53c.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data);
void var(short data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(short data);
void var(short data)
{
    var(data);
}
void var(short data);
void var(short data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_multiply_53a.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data);
void var()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
static void goodG2B()
{
    int data;
    data = 0;
    data = -2;
    var(data);
}
void var(int data);
static void goodB2G()
{
    int data;
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_fscanf_predec_21.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
static int badStatic = 0;
static void badSink(short data)
{
    if(badStatic)
    {
        {
            --data;
            short result = data;
            printIntLine(result);
        }
    }
}
void var()
{
    short data;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    badStatic = 1; 
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static int goodB2G1Static = 0;
static int goodB2G2Static = 0;
static int goodG2BStatic = 0;
static void goodB2G1Sink(short data)
{
    if(goodB2G1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > SHRT_MIN)
        {
            --data;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G1()
{
    short data;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    goodB2G1Static = 0; 
    goodB2G1Sink(data);
}
static void goodB2G2Sink(short data)
{
    if(goodB2G2Static)
    {
        if (data > SHRT_MIN)
        {
            --data;
            short result = data;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    goodB2G2Static = 1; 
    goodB2G2Sink(data);
}
static void goodG2BSink(short data)
{
    if(goodG2BStatic)
    {
        {
            --data;
            short result = data;
            printIntLine(result);
        }
    }
}
static void goodG2B()
{
    short data;
    data = 0;
    data = -2;
    goodG2BStatic = 1; 
    goodG2BSink(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_min_postdec_45.c,CWE191,good,"#include ""std_testcase.h""
static char var;
static char var;
static char var;
#ifndef OMITBAD
static void badSink()
{
    char data = var;
    {
        data--;
        char result = data;
        printHexCharLine(result);
    }
}
void var()
{
    char data;
    data = ' ';
    data = CHAR_MIN;
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    char data = var;
    {
        data--;
        char result = data;
        printHexCharLine(result);
    }
}
static void goodG2B()
{
    char data;
    data = ' ';
    data = -2;
    var = data;
    goodG2BSink();
}
static void goodB2GSink()
{
    char data = var;
    if (data > CHAR_MIN)
    {
        data--;
        char result = data;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodB2G()
{
    char data;
    data = ' ';
    data = CHAR_MIN;
    var = data;
    goodB2GSink();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_fscanf_sub_45.c,CWE191,bad,"#include ""std_testcase.h""
static char var;
static char var;
static char var;
#ifndef OMITBAD
static void badSink()
{
    char data = var;
    {
        char result = data - 1;
        printHexCharLine(result);
    }
}
void var()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    char data = var;
    {
        char result = data - 1;
        printHexCharLine(result);
    }
}
static void goodG2B()
{
    char data;
    data = ' ';
    data = -2;
    var = data;
    goodG2BSink();
}
static void goodB2GSink()
{
    char data = var;
    if (data > CHAR_MIN)
    {
        char result = data - 1;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
static void goodB2G()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    var = data;
    goodB2GSink();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_min_multiply_54d.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__int64_t_min_postdec_51b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data)
{
    {
        data--;
        int64_t result = data;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int64_t data)
{
    {
        data--;
        int64_t result = data;
        printLongLongLine(result);
    }
}
void var(int64_t data)
{
    if (data > LLONG_MIN)
    {
        data--;
        int64_t result = data;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__int64_t_fscanf_postdec_61a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
int64_t var(int64_t data);
void var()
{
    int64_t data;
    data = 0LL;
    data = var(data);
    {
        data--;
        int64_t result = data;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
int64_t var(int64_t data);
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = var(data);
    {
        data--;
        int64_t result = data;
        printLongLongLine(result);
    }
}
int64_t var(int64_t data);
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    data = var(data);
    if (data > LLONG_MIN)
    {
        data--;
        int64_t result = data;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_fscanf_multiply_22a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
int var = 0;
void var(char data);
void var()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    var = 1; 
    var(data);
}
#endif 
#ifndef OMITGOOD
int var = 0;
int var = 0;
int var = 0;
void var(char data);
static void goodB2G1()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    var = 0; 
    var(data);
}
void var(char data);
static void goodB2G2()
{
    char data;
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    var = 1; 
    var(data);
}
void var(char data);
static void goodG2B()
{
    char data;
    data = ' ';
    data = -2;
    var = 1; 
    var(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_fscanf_sub_67b.c,CWE191,good,"#include ""std_testcase.h""
typedef struct _CWE191_Integer_Underflow__short_fscanf_sub_67_structType
{
    short structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct)
{
    short data = myStruct.structFirst;
    {
        short result = data - 1;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(var myStruct)
{
    short data = myStruct.structFirst;
    {
        short result = data - 1;
        printIntLine(result);
    }
}
void var(var myStruct)
{
    short data = myStruct.structFirst;
    if (data > SHRT_MIN)
    {
        short result = data - 1;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
#endif"
CWE191_Integer_Underflow__short_fscanf_multiply_54b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(short data);
void var(short data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(short data);
void var(short data)
{
    var(data);
}
void var(short data);
void var(short data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__int64_t_min_multiply_34.c,CWE191,bad,"#include ""std_testcase.h""
typedef union
{
    int64_t unionFirst;
    int64_t unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    int64_t data;
    var myUnion;
    data = 0LL;
    data = LLONG_MIN;
    myUnion.unionFirst = data;
    {
        int64_t data = myUnion.unionSecond;
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int64_t data;
    var myUnion;
    data = 0LL;
    data = -2;
    myUnion.unionFirst = data;
    {
        int64_t data = myUnion.unionSecond;
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
static void goodB2G()
{
    int64_t data;
    var myUnion;
    data = 0LL;
    data = LLONG_MIN;
    myUnion.unionFirst = data;
    {
        int64_t data = myUnion.unionSecond;
        if(data < 0) 
        {
            if (data > (LLONG_MIN/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_rand_postdec_41.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
static void badSink(short data)
{
    {
        data--;
        short result = data;
        printIntLine(result);
    }
}
void var()
{
    short data;
    data = 0;
    data = (short)RAND32();
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(short data)
{
    {
        data--;
        short result = data;
        printIntLine(result);
    }
}
static void goodG2B()
{
    short data;
    data = 0;
    data = -2;
    goodG2BSink(data);
}
static void goodB2GSink(short data)
{
    if (data > SHRT_MIN)
    {
        data--;
        short result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodB2G()
{
    short data;
    data = 0;
    data = (short)RAND32();
    goodB2GSink(data);
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_fscanf_predec_51b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t data)
{
    {
        --data;
        int64_t result = data;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int64_t data)
{
    {
        --data;
        int64_t result = data;
        printLongLongLine(result);
    }
}
void var(int64_t data)
{
    if (data > LLONG_MIN)
    {
        --data;
        int64_t result = data;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__char_min_postdec_52c.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data)
{
    {
        data--;
        char result = data;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(char data)
{
    {
        data--;
        char result = data;
        printHexCharLine(result);
    }
}
void var(char data)
{
    if (data > CHAR_MIN)
    {
        data--;
        char result = data;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__int_rand_sub_53c.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__int64_t_min_predec_31.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    data = LLONG_MIN;
    {
        int64_t dataCopy = data;
        int64_t data = dataCopy;
        {
            --data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = -2;
    {
        int64_t dataCopy = data;
        int64_t data = dataCopy;
        {
            --data;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    data = LLONG_MIN;
    {
        int64_t dataCopy = data;
        int64_t data = dataCopy;
        if (data > LLONG_MIN)
        {
            --data;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_predec_14.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(globalFive==5)
    {
        data = (unsigned int)RAND32();
    }
    if(globalFive==5)
    {
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(globalFive==5)
    {
        data = (unsigned int)RAND32();
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > 0)
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(globalFive==5)
    {
        data = (unsigned int)RAND32();
    }
    if(globalFive==5)
    {
        if (data > 0)
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(globalFive==5)
    {
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(globalFive==5)
    {
        data = -2;
    }
    if(globalFive==5)
    {
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_fscanf_predec_65b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data)
{
    {
        --data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data)
{
    {
        --data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
void var(unsigned int data)
{
    if (data > 0)
    {
        --data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__short_fscanf_multiply_01.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    if(data < 0) 
    {
        short result = data * 2;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    short data;
    data = 0;
    data = -2;
    if(data < 0) 
    {
        short result = data * 2;
        printIntLine(result);
    }
}
static void goodB2G()
{
    short data;
    data = 0;
    fscanf (stdin, ""%hd"", &data);
    if(data < 0) 
    {
        if (data > (SHRT_MIN/2))
        {
            short result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_min_sub_61a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
int64_t var(int64_t data);
void var()
{
    int64_t data;
    data = 0LL;
    data = var(data);
    {
        int64_t result = data - 1;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
int64_t var(int64_t data);
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = var(data);
    {
        int64_t result = data - 1;
        printLongLongLine(result);
    }
}
int64_t var(int64_t data);
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    data = var(data);
    if (data > LLONG_MIN)
    {
        int64_t result = data - 1;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_fscanf_postdec_54d.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_predec_52a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data);
void var()
{
    unsigned int data;
    data = 0;
    data = (unsigned int)RAND32();
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data);
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = -2;
    var(data);
}
void var(unsigned int data);
static void goodB2G()
{
    unsigned int data;
    data = 0;
    data = (unsigned int)RAND32();
    var(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_fscanf_multiply_14.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(globalFive==5)
    {
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data < 0) 
        {
            if (data > (INT_MIN/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(globalFive==5)
    {
        if(data < 0) 
        {
            if (data > (INT_MIN/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(globalFive==5)
    {
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(globalFive==5)
    {
        data = -2;
    }
    if(globalFive==5)
    {
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_rand_predec_67a.c,CWE191,good,"#include ""std_testcase.h""
typedef struct _CWE191_Integer_Underflow__char_rand_predec_67_structType
{
    char structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct);
void var()
{
    char data;
    var myStruct;
    data = ' ';
    data = (char)RAND32();
    myStruct.structFirst = data;
    var(myStruct);
}
#endif 
#ifndef OMITGOOD
void var(var myStruct);
static void goodG2B()
{
    char data;
    var myStruct;
    data = ' ';
    data = -2;
    myStruct.structFirst = data;
    var(myStruct);
}
void var(var myStruct);
static void goodB2G()
{
    char data;
    var myStruct;
    data = ' ';
    data = (char)RAND32();
    myStruct.structFirst = data;
    var(myStruct);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_rand_postdec_18.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    goto source;
source:
    data = (short)RAND32();
    goto sink;
sink:
    {
        data--;
        short result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    short data;
    data = 0;
    goto source;
source:
    data = (short)RAND32();
    goto sink;
sink:
    if (data > SHRT_MIN)
    {
        data--;
        short result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodG2B()
{
    short data;
    data = 0;
    goto source;
source:
    data = -2;
    goto sink;
sink:
    {
        data--;
        short result = data;
        printIntLine(result);
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_rand_predec_01.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    data = (char)RAND32();
    {
        --data;
        char result = data;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char data;
    data = ' ';
    data = -2;
    {
        --data;
        char result = data;
        printHexCharLine(result);
    }
}
static void goodB2G()
{
    char data;
    data = ' ';
    data = (char)RAND32();
    if (data > CHAR_MIN)
    {
        --data;
        char result = data;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_fscanf_postdec_45.c,CWE191,good,"#include <inttypes.h>
#include ""std_testcase.h""
static int64_t var;
static int64_t var;
static int64_t var;
#ifndef OMITBAD
static void badSink()
{
    int64_t data = var;
    {
        data--;
        int64_t result = data;
        printLongLongLine(result);
    }
}
void var()
{
    int64_t data;
    data = 0LL;
    fscanf (stdin, ""%"" SCNd64, &data);
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    int64_t data = var;
    {
        data--;
        int64_t result = data;
        printLongLongLine(result);
    }
}
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = -2;
    var = data;
    goodG2BSink();
}
static void goodB2GSink()
{
    int64_t data = var;
    if (data > LLONG_MIN)
    {
        data--;
        int64_t result = data;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodB2G()
{
    int64_t data;
    data = 0LL;
    fscanf (stdin, ""%"" SCNd64, &data);
    var = data;
    goodB2GSink();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_min_multiply_31.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    data = SHRT_MIN;
    {
        short dataCopy = data;
        short data = dataCopy;
        if(data < 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    short data;
    data = 0;
    data = -2;
    {
        short dataCopy = data;
        short data = dataCopy;
        if(data < 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodB2G()
{
    short data;
    data = 0;
    data = SHRT_MIN;
    {
        short dataCopy = data;
        short data = dataCopy;
        if(data < 0) 
        {
            if (data > (SHRT_MIN/2))
            {
                short result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_fscanf_predec_68b.c,CWE191,good,"#include ""std_testcase.h""
extern short var;
extern short var;
extern short var;
#ifndef OMITBAD
void var()
{
    short data = var;
    {
        --data;
        short result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    short data = var;
    {
        --data;
        short result = data;
        printIntLine(result);
    }
}
void var()
{
    short data = var;
    if (data > SHRT_MIN)
    {
        --data;
        short result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__int_rand_predec_54e.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data)
{
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
void var(int data)
{
    if (data > INT_MIN)
    {
        --data;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_sub_10.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(globalTrue)
    {
        data = (unsigned int)RAND32();
    }
    if(globalTrue)
    {
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(globalTrue)
    {
        data = (unsigned int)RAND32();
    }
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > 0)
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(globalTrue)
    {
        data = (unsigned int)RAND32();
    }
    if(globalTrue)
    {
        if (data > 0)
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(globalTrue)
    {
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(globalTrue)
    {
        data = -2;
    }
    if(globalTrue)
    {
        {
            unsigned int result = data - 1;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_predec_10.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    if(globalTrue)
    {
        data = (unsigned int)RAND32();
    }
    if(globalTrue)
    {
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    if(globalTrue)
    {
        data = (unsigned int)RAND32();
    }
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > 0)
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    if(globalTrue)
    {
        data = (unsigned int)RAND32();
    }
    if(globalTrue)
    {
        if (data > 0)
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(globalTrue)
    {
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    if(globalTrue)
    {
        data = -2;
    }
    if(globalTrue)
    {
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_min_sub_21.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
static int badStatic = 0;
static void badSink(int64_t data)
{
    if(badStatic)
    {
        {
            int64_t result = data - 1;
            printLongLongLine(result);
        }
    }
}
void var()
{
    int64_t data;
    data = 0LL;
    data = LLONG_MIN;
    badStatic = 1; 
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static int goodB2G1Static = 0;
static int goodB2G2Static = 0;
static int goodG2BStatic = 0;
static void goodB2G1Sink(int64_t data)
{
    if(goodB2G1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > LLONG_MIN)
        {
            int64_t result = data - 1;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    data = LLONG_MIN;
    goodB2G1Static = 0; 
    goodB2G1Sink(data);
}
static void goodB2G2Sink(int64_t data)
{
    if(goodB2G2Static)
    {
        if (data > LLONG_MIN)
        {
            int64_t result = data - 1;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    data = LLONG_MIN;
    goodB2G2Static = 1; 
    goodB2G2Sink(data);
}
static void goodG2BSink(int64_t data)
{
    if(goodG2BStatic)
    {
        {
            int64_t result = data - 1;
            printLongLongLine(result);
        }
    }
}
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = -2;
    goodG2BStatic = 1; 
    goodG2BSink(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_fscanf_postdec_68b.c,CWE191,good,"#include ""std_testcase.h""
extern int64_t var;
extern int64_t var;
extern int64_t var;
#ifndef OMITBAD
void var()
{
    int64_t data = var;
    {
        data--;
        int64_t result = data;
        printLongLongLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    int64_t data = var;
    {
        data--;
        int64_t result = data;
        printLongLongLine(result);
    }
}
void var()
{
    int64_t data = var;
    if (data > LLONG_MIN)
    {
        data--;
        int64_t result = data;
        printLongLongLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__int_rand_multiply_02.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = 0;
    if(1)
    {
        data = RAND32();
    }
    if(1)
    {
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = 0;
    if(1)
    {
        data = RAND32();
    }
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data < 0) 
        {
            if (data > (INT_MIN/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodB2G2()
{
    int data;
    data = 0;
    if(1)
    {
        data = RAND32();
    }
    if(1)
    {
        if(data < 0) 
        {
            if (data > (INT_MIN/2))
            {
                int result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodG2B1()
{
    int data;
    data = 0;
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(1)
    {
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = 0;
    if(1)
    {
        data = -2;
    }
    if(1)
    {
        if(data < 0) 
        {
            int result = data * 2;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_postdec_15.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    unsigned int data;
    data = 0;
    switch(6)
    {
    case 6:
        data = (unsigned int)RAND32();
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        data--;
        unsigned int result = data;
        printUnsignedLine(result);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    switch(6)
    {
    case 6:
        data = (unsigned int)RAND32();
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(8)
    {
    case 7:
        printLine(""Benign, fixed string"");
        break;
    default:
        if (data > 0)
        {
            data--;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
        break;
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    switch(6)
    {
    case 6:
        data = (unsigned int)RAND32();
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
        if (data > 0)
        {
            data--;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B1()
{
    unsigned int data;
    data = 0;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        data = -2;
        break;
    }
    switch(7)
    {
    case 7:
    {
        data--;
        unsigned int result = data;
        printUnsignedLine(result);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B2()
{
    unsigned int data;
    data = 0;
    switch(6)
    {
    case 6:
        data = -2;
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        data--;
        unsigned int result = data;
        printUnsignedLine(result);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_rand_postdec_32.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    int64_t *dataPtr1 = &data;
    int64_t *dataPtr2 = &data;
    data = 0LL;
    {
        int64_t data = *dataPtr1;
        data = (int64_t)RAND64();
        *dataPtr1 = data;
    }
    {
        int64_t data = *dataPtr2;
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int64_t data;
    int64_t *dataPtr1 = &data;
    int64_t *dataPtr2 = &data;
    data = 0LL;
    {
        int64_t data = *dataPtr1;
        data = -2;
        *dataPtr1 = data;
    }
    {
        int64_t data = *dataPtr2;
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
    }
}
static void goodB2G()
{
    int64_t data;
    int64_t *dataPtr1 = &data;
    int64_t *dataPtr2 = &data;
    data = 0LL;
    {
        int64_t data = *dataPtr1;
        data = (int64_t)RAND64();
        *dataPtr1 = data;
    }
    {
        int64_t data = *dataPtr2;
        if (data > LLONG_MIN)
        {
            data--;
            int64_t result = data;
            printLongLongLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__short_fscanf_multiply_61a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
short var(short data);
void var()
{
    short data;
    data = 0;
    data = var(data);
    if(data < 0) 
    {
        short result = data * 2;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
short var(short data);
static void goodG2B()
{
    short data;
    data = 0;
    data = var(data);
    if(data < 0) 
    {
        short result = data * 2;
        printIntLine(result);
    }
}
short var(short data);
static void goodB2G()
{
    short data;
    data = 0;
    data = var(data);
    if(data < 0) 
    {
        if (data > (SHRT_MIN/2))
        {
            short result = data * 2;
            printIntLine(result);
        }
        else
        {
            printLine(""data value is too small to perform multiplication."");
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_min_postdec_22a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
int var = 0;
void var(int64_t data);
void var()
{
    int64_t data;
    data = 0LL;
    data = LLONG_MIN;
    var = 1; 
    var(data);
}
#endif 
#ifndef OMITGOOD
int var = 0;
int var = 0;
int var = 0;
void var(int64_t data);
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    data = LLONG_MIN;
    var = 0; 
    var(data);
}
void var(int64_t data);
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    data = LLONG_MIN;
    var = 1; 
    var(data);
}
void var(int64_t data);
static void goodG2B()
{
    int64_t data;
    data = 0LL;
    data = -2;
    var = 1; 
    var(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_min_sub_53d.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char data)
{
    {
        char result = data - 1;
        printHexCharLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(char data)
{
    {
        char result = data - 1;
        printHexCharLine(result);
    }
}
void var(char data)
{
    if (data > CHAR_MIN)
    {
        char result = data - 1;
        printHexCharLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
#endif"
CWE191_Integer_Underflow__short_min_multiply_04.c,CWE191,good,"#include ""std_testcase.h""
static const int STATIC_CONST_TRUE = 1; 
static const int STATIC_CONST_FALSE = 0; 
#ifndef OMITBAD
void var()
{
    short data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        data = SHRT_MIN;
    }
    if(STATIC_CONST_TRUE)
    {
        if(data < 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    short data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        data = SHRT_MIN;
    }
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data < 0) 
        {
            if (data > (SHRT_MIN/2))
            {
                short result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodB2G2()
{
    short data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        data = SHRT_MIN;
    }
    if(STATIC_CONST_TRUE)
    {
        if(data < 0) 
        {
            if (data > (SHRT_MIN/2))
            {
                short result = data * 2;
                printIntLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodG2B1()
{
    short data;
    data = 0;
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(STATIC_CONST_TRUE)
    {
        if(data < 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
    }
}
static void goodG2B2()
{
    short data;
    data = 0;
    if(STATIC_CONST_TRUE)
    {
        data = -2;
    }
    if(STATIC_CONST_TRUE)
    {
        if(data < 0) 
        {
            short result = data * 2;
            printIntLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_listen_socket_predec_66a.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int dataArray[]);
void var()
{
    int data;
    int dataArray[5];
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(int dataArray[]);
static void goodG2B()
{
    int data;
    int dataArray[5];
    data = 0;
    data = -2;
    dataArray[2] = data;
    var(dataArray);
}
void var(int dataArray[]);
static void goodB2G()
{
    int data;
    int dataArray[5];
    data = 0;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_postdec_65a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data);
void var()
{
    unsigned int data;
    void (*funcPtr) (unsigned int) = var;
    data = 0;
    data = (unsigned int)RAND32();
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data);
static void goodG2B()
{
    unsigned int data;
    void (*funcPtr) (unsigned int) = var;
    data = 0;
    data = -2;
    funcPtr(data);
}
void var(unsigned int data);
static void goodB2G()
{
    unsigned int data;
    void (*funcPtr) (unsigned int) = var;
    data = 0;
    data = (unsigned int)RAND32();
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_postdec_54d.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__short_min_postdec_64b.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    short * dataPtr = (short *)dataVoidPtr;
    short data = (*dataPtr);
    {
        data--;
        short result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    short * dataPtr = (short *)dataVoidPtr;
    short data = (*dataPtr);
    {
        data--;
        short result = data;
        printIntLine(result);
    }
}
void var(void * dataVoidPtr)
{
    short * dataPtr = (short *)dataVoidPtr;
    short data = (*dataPtr);
    if (data > SHRT_MIN)
    {
        data--;
        short result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_predec_21.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
static int badStatic = 0;
static void badSink(unsigned int data)
{
    if(badStatic)
    {
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
void var()
{
    unsigned int data;
    data = 0;
    data = (unsigned int)RAND32();
    badStatic = 1; 
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static int goodB2G1Static = 0;
static int goodB2G2Static = 0;
static int goodG2BStatic = 0;
static void goodB2G1Sink(unsigned int data)
{
    if(goodB2G1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > 0)
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G1()
{
    unsigned int data;
    data = 0;
    data = (unsigned int)RAND32();
    goodB2G1Static = 0; 
    goodB2G1Sink(data);
}
static void goodB2G2Sink(unsigned int data)
{
    if(goodB2G2Static)
    {
        if (data > 0)
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    unsigned int data;
    data = 0;
    data = (unsigned int)RAND32();
    goodB2G2Static = 1; 
    goodB2G2Sink(data);
}
static void goodG2BSink(unsigned int data)
{
    if(goodG2BStatic)
    {
        {
            --data;
            unsigned int result = data;
            printUnsignedLine(result);
        }
    }
}
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = -2;
    goodG2BStatic = 1; 
    goodG2BSink(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_predec_51b.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data)
{
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
void var(int data)
{
    if (data > INT_MIN)
    {
        --data;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__unsigned_int_rand_sub_54e.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(unsigned int data)
{
    {
        unsigned int result = data - 1;
        printUnsignedLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(unsigned int data)
{
    {
        unsigned int result = data - 1;
        printUnsignedLine(result);
    }
}
void var(unsigned int data)
{
    if (data > 0)
    {
        unsigned int result = data - 1;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform subtraction."");
    }
}
#endif"
CWE191_Integer_Underflow__char_rand_predec_14.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(globalFive==5)
    {
        data = (char)RAND32();
    }
    if(globalFive==5)
    {
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(globalFive==5)
    {
        data = (char)RAND32();
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > CHAR_MIN)
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(globalFive==5)
    {
        data = (char)RAND32();
    }
    if(globalFive==5)
    {
        if (data > CHAR_MIN)
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform arithmetic safely."");
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(globalFive==5)
    {
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(globalFive==5)
    {
        data = -2;
    }
    if(globalFive==5)
    {
        {
            --data;
            char result = data;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_listen_socket_predec_67b.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
typedef struct _CWE191_Integer_Underflow__int_listen_socket_predec_67_structType
{
    int structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct)
{
    int data = myStruct.structFirst;
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
#endif 
#ifndef OMITGOOD
void var(var myStruct)
{
    int data = myStruct.structFirst;
    {
        --data;
        int result = data;
        printIntLine(result);
    }
}
void var(var myStruct)
{
    int data = myStruct.structFirst;
    if (data > INT_MIN)
    {
        --data;
        int result = data;
        printIntLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
#endif"
CWE191_Integer_Underflow__unsigned_int_min_predec_45.c,CWE191,bad,"#include ""std_testcase.h""
static unsigned int var;
static unsigned int var;
static unsigned int var;
#ifndef OMITBAD
static void badSink()
{
    unsigned int data = var;
    {
        --data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
void var()
{
    unsigned int data;
    data = 0;
    data = 0;
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    unsigned int data = var;
    {
        --data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
}
static void goodG2B()
{
    unsigned int data;
    data = 0;
    data = -2;
    var = data;
    goodG2BSink();
}
static void goodB2GSink()
{
    unsigned int data = var;
    if (data > 0)
    {
        --data;
        unsigned int result = data;
        printUnsignedLine(result);
    }
    else
    {
        printLine(""data value is too large to perform arithmetic safely."");
    }
}
static void goodB2G()
{
    unsigned int data;
    data = 0;
    data = 0;
    var = data;
    goodB2GSink();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int64_t_min_multiply_10.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t data;
    data = 0LL;
    if(globalTrue)
    {
        data = LLONG_MIN;
    }
    if(globalTrue)
    {
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int64_t data;
    data = 0LL;
    if(globalTrue)
    {
        data = LLONG_MIN;
    }
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if(data < 0) 
        {
            if (data > (LLONG_MIN/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodB2G2()
{
    int64_t data;
    data = 0LL;
    if(globalTrue)
    {
        data = LLONG_MIN;
    }
    if(globalTrue)
    {
        if(data < 0) 
        {
            if (data > (LLONG_MIN/2))
            {
                int64_t result = data * 2;
                printLongLongLine(result);
            }
            else
            {
                printLine(""data value is too small to perform multiplication."");
            }
        }
    }
}
static void goodG2B1()
{
    int64_t data;
    data = 0LL;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(globalTrue)
    {
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
static void goodG2B2()
{
    int64_t data;
    data = 0LL;
    if(globalTrue)
    {
        data = -2;
    }
    if(globalTrue)
    {
        if(data < 0) 
        {
            int64_t result = data * 2;
            printLongLongLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__char_fscanf_sub_66a.c,CWE191,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(char dataArray[]);
void var()
{
    char data;
    char dataArray[5];
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(char dataArray[]);
static void goodG2B()
{
    char data;
    char dataArray[5];
    data = ' ';
    data = -2;
    dataArray[2] = data;
    var(dataArray);
}
void var(char dataArray[]);
static void goodB2G()
{
    char data;
    char dataArray[5];
    data = ' ';
    fscanf (stdin, ""%c"", &data);
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE191_Integer_Underflow__int_connect_socket_sub_52b.c,CWE191,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE191_Integer_Underflow__char_min_sub_11.c,CWE191,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    char data;
    data = ' ';
    if(globalReturnsTrue())
    {
        data = CHAR_MIN;
    }
    if(globalReturnsTrue())
    {
        {
            char result = data - 1;
            printHexCharLine(result);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    char data;
    data = ' ';
    if(globalReturnsTrue())
    {
        data = CHAR_MIN;
    }
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        if (data > CHAR_MIN)
        {
            char result = data - 1;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodB2G2()
{
    char data;
    data = ' ';
    if(globalReturnsTrue())
    {
        data = CHAR_MIN;
    }
    if(globalReturnsTrue())
    {
        if (data > CHAR_MIN)
        {
            char result = data - 1;
            printHexCharLine(result);
        }
        else
        {
            printLine(""data value is too large to perform subtraction."");
        }
    }
}
static void goodG2B1()
{
    char data;
    data = ' ';
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = -2;
    }
    if(globalReturnsTrue())
    {
        {
            char result = data - 1;
            printHexCharLine(result);
        }
    }
}
static void goodG2B2()
{
    char data;
    data = ' ';
    if(globalReturnsTrue())
    {
        data = -2;
    }
    if(globalReturnsTrue())
    {
        {
            char result = data - 1;
            printHexCharLine(result);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_41.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
static void badSink(int data)
{
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
void var()
{
    int data;
    data = -1;
    fscanf(stdin, ""%d"", &data);
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(int data)
{
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
static void goodG2B()
{
    int data;
    data = -1;
    data = 7;
    goodG2BSink(data);
}
static void goodB2GSink(int data)
{
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
        free(buffer);
    }
}
static void goodB2G()
{
    int data;
    data = -1;
    fscanf(stdin, ""%d"", &data);
    goodB2GSink(data);
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_snprintf_06.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF swprintf
#endif
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = (wchar_t *)malloc(50*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = NULL;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_16.c,CWE122,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    while(1)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
        break;
    }
    while(1)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int data;
    data = -1;
    while(1)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
        break;
    }
    while(1)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
        break;
    }
}
static void goodG2B()
{
    int data;
    data = -1;
    while(1)
    {
        data = 7;
        break;
    }
    while(1)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
        break;
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_11.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int * data;
    data = NULL;
    if(globalReturnsTrue())
    {
        data = (int *)malloc(50*sizeof(int));
        if (data == NULL) {exit(-1);}
    }
    {
        int source[100] = {0}; 
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    int * data;
    data = NULL;
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
    }
    {
        int source[100] = {0}; 
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
static void goodG2B2()
{
    int * data;
    data = NULL;
    if(globalReturnsTrue())
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
    }
    {
        int source[100] = {0}; 
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_12.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = (char *)malloc(50*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    else
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcpy(data, source);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    else
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcpy(data, source);
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__sizeof_int64_t_61a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
int64_t * var(int64_t * data);
void var()
{
    int64_t * data;
    data = NULL;
    data = var(data);
    printLongLongLine(*data);
    free(data);
}
#endif 
#ifndef OMITGOOD
int64_t * var(int64_t * data);
static void goodG2B()
{
    int64_t * data;
    data = NULL;
    data = var(data);
    printLongLongLine(*data);
    free(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_45.c,CWE122,bad,"#include ""std_testcase.h""
#include <wchar.h>
static char * var;
static char * var;
#ifndef OMITBAD
static void badSink()
{
    char * data = var;
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
void var()
{
    char * data;
    data = NULL;
    data = (char *)malloc(50*sizeof(char));
    if (data == NULL) {exit(-1);}
    data[0] = '\0'; 
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    char * data = var;
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
static void goodG2B()
{
    char * data;
    data = NULL;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    data[0] = '\0'; 
    var = data;
    goodG2BSink();
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_53d.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        memmove(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        memmove(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_loop_05.c,CWE122,good,"#include ""std_testcase.h""
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void var()
{
    int64_t * data;
    data = NULL;
    if(staticTrue)
    {
        data = (int64_t *)malloc(50*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
    }
    {
        int64_t source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
            free(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    int64_t * data;
    data = NULL;
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
    }
    {
        int64_t source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
            free(data);
        }
    }
}
static void goodG2B2()
{
    int64_t * data;
    data = NULL;
    if(staticTrue)
    {
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
    }
    {
        int64_t source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
            free(data);
        }
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__CWE135_67b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
typedef struct _CWE122_Heap_Based_Buffer_Overflow__CWE135_67_structType
{
    void * structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct)
{
    void * data = myStruct.structFirst;
    {
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t));
        if (dest == NULL) {exit(-1);}
        (void)wcscpy(dest, data);
        printLine((char *)dest);
        free(dest);
    }
}
#endif 
#ifndef OMITGOOD
void var(var myStruct)
{
    void * data = myStruct.structFirst;
    {
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)calloc(dataLen+1, 1);
        if (dest == NULL) {exit(-1);}
        (void)strcpy(dest, data);
        printLine((char *)dest);
        free(dest);
    }
}
void var(var myStruct)
{
    void * data = myStruct.structFirst;
    {
        size_t dataLen = wcslen((wchar_t *)data);
        void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t));
        if (dest == NULL) {exit(-1);}
        (void)wcscpy(dest, data);
        printWLine((wchar_t *)dest);
        free(dest);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_42.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
static int badSource(int data)
{
    fscanf(stdin, ""%d"", &data);
    return data;
}
void var()
{
    int data;
    data = -1;
    data = badSource(data);
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
#endif 
#ifndef OMITGOOD
static int goodG2BSource(int data)
{
    data = 7;
    return data;
}
static void goodG2B()
{
    int data;
    data = -1;
    data = goodG2BSource(data);
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
static int goodB2GSource(int data)
{
    fscanf(stdin, ""%d"", &data);
    return data;
}
static void goodB2G()
{
    int data;
    data = -1;
    data = goodB2GSource(data);
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
        free(buffer);
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memmove_15.c,CWE122,bad,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STR ""0123456789abcdef0123456789abcde""
typedef struct _charVoid
{
    char charFirst[16];
    void * voidSecond;
    void * voidThird;
} charVoid;
#ifndef OMITBAD
void var()
{
    switch(6)
    {
    case 6:
    {
        charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
        if (structCharVoid == NULL) {exit(-1);}
        structCharVoid->voidSecond = (void *)SRC_STR;
        printLine((char *)structCharVoid->voidSecond);
        memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
        structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; 
        printLine((char *)structCharVoid->charFirst);
        printLine((char *)structCharVoid->voidSecond);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void good1()
{
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
        if (structCharVoid == NULL) {exit(-1);}
        structCharVoid->voidSecond = (void *)SRC_STR;
        printLine((char *)structCharVoid->voidSecond);
        memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
        structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; 
        printLine((char *)structCharVoid->charFirst);
        printLine((char *)structCharVoid->voidSecond);
    }
    break;
    }
}
static void good2()
{
    switch(6)
    {
    case 6:
    {
        charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
        if (structCharVoid == NULL) {exit(-1);}
        structCharVoid->voidSecond = (void *)SRC_STR;
        printLine((char *)structCharVoid->voidSecond);
        memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
        structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; 
        printLine((char *)structCharVoid->charFirst);
        printLine((char *)structCharVoid->voidSecond);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
void var()
{
    good1();
    good2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_large_15.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    switch(6)
    {
    case 6:
        data = 10;
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = -1;
    switch(6)
    {
    case 6:
        data = 10;
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(8)
    {
    case 7:
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
        free(buffer);
    }
    break;
    }
}
static void goodB2G2()
{
    int data;
    data = -1;
    switch(6)
    {
    case 6:
        data = 10;
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
        free(buffer);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B1()
{
    int data;
    data = -1;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        data = 7;
        break;
    }
    switch(7)
    {
    case 7:
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B2()
{
    int data;
    data = -1;
    switch(6)
    {
    case 6:
        data = 7;
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_44.c,CWE122,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
static void badSink(char * data)
{
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
void var()
{
    char * data;
    void (*funcPtr) (char *) = badSink;
    data = NULL;
    data = (char *)malloc(50*sizeof(char));
    if (data == NULL) {exit(-1);}
    data[0] = '\0'; 
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(char * data)
{
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
static void goodG2B()
{
    char * data;
    void (*funcPtr) (char *) = goodG2BSink;
    data = NULL;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    data[0] = '\0'; 
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_34.c,CWE122,bad,"#include ""std_testcase.h""
#include <wchar.h>
typedef union
{
    char * unionFirst;
    char * unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    char * data;
    var myUnion;
    data = NULL;
    data = (char *)malloc(50*sizeof(char));
    if (data == NULL) {exit(-1);}
    data[0] = '\0'; 
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char source[100];
            memset(source, 'C', 100-1); 
            source[100-1] = '\0'; 
            strncpy(data, source, 100-1);
            data[100-1] = '\0'; 
            printLine(data);
            free(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    var myUnion;
    data = NULL;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    data[0] = '\0'; 
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char source[100];
            memset(source, 'C', 100-1); 
            source[100-1] = '\0'; 
            strncpy(data, source, 100-1);
            data[100-1] = '\0'; 
            printLine(data);
            free(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_loop_52a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var()
{
    char * data;
    data = NULL;
    data = (char *)malloc(50*sizeof(char));
    data[0] = '\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
static void goodG2B()
{
    char * data;
    data = NULL;
    data = (char *)malloc(100*sizeof(char));
    data[0] = '\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncat_52c.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncat(data, source, 100);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncat(data, source, 100);
        printWLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_snprintf_66a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var(wchar_t * dataArray[]);
void var()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    data = NULL;
    data = (wchar_t *)malloc(50*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0'; 
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * dataArray[]);
static void goodG2B()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    data = NULL;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0'; 
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_54a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(char * data);
void var()
{
    char * data;
    data = NULL;
    data = (char *)malloc(10*sizeof(char));
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
static void goodG2B()
{
    char * data;
    data = NULL;
    data = (char *)malloc((10+1)*sizeof(char));
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_52c.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data)
{
    {
        char dest[50] = """";
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * data)
{
    {
        char dest[50] = """";
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_snprintf_53b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_loop_06.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = (char *)malloc(50*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = NULL;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_45.c,CWE122,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
static int var;
static int var;
static int var;
#ifndef OMITBAD
static void badSink()
{
    int data = var;
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
void var()
{
    int data;
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    int data = var;
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
static void goodG2B()
{
    int data;
    data = -1;
    data = 7;
    var = data;
    goodG2BSink();
}
static void goodB2GSink()
{
    int data = var;
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
        free(buffer);
    }
}
static void goodB2G()
{
    int data;
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    var = data;
    goodB2GSink();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_09.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(GLOBAL_CONST_TRUE)
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(GLOBAL_CONST_TRUE)
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_src_wchar_t_cpy_52b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_14.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    if(globalFive==5)
    {
        data = (char *)malloc(50*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcat(data, source);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = NULL;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcat(data, source);
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = NULL;
    if(globalFive==5)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcat(data, source);
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_11.c,CWE122,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsTrue())
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = -1;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodB2G2()
{
    int data;
    data = -1;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsTrue())
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodG2B1()
{
    int data;
    data = -1;
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 7;
    }
    if(globalReturnsTrue())
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = -1;
    if(globalReturnsTrue())
    {
        data = 7;
    }
    if(globalReturnsTrue())
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_68a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
char * var;
char * var;
#ifndef OMITBAD
void var();
void var()
{
    char * data;
    data = NULL;
    data = (char *)malloc(50*sizeof(char));
    data[0] = '\0'; 
    var = data;
    var();
}
#endif 
#ifndef OMITGOOD
void var();
static void goodG2B()
{
    char * data;
    data = NULL;
    data = (char *)malloc(100*sizeof(char));
    data[0] = '\0'; 
    var = data;
    var();
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__sizeof_struct_53b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(twoIntsStruct * data);
void var(twoIntsStruct * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(twoIntsStruct * data);
void var(twoIntsStruct * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__sizeof_struct_67b.c,CWE122,good,"#include ""std_testcase.h""
typedef struct _CWE122_Heap_Based_Buffer_Overflow__sizeof_struct_67_structType
{
    twoIntsStruct * structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct)
{
    twoIntsStruct * data = myStruct.structFirst;
    printStructLine(data);
    free(data);
}
#endif 
#ifndef OMITGOOD
void var(var myStruct)
{
    twoIntsStruct * data = myStruct.structFirst;
    printStructLine(data);
    free(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_14.c,CWE122,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    if(globalFive==5)
    {
        data = (char *)malloc(50*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = NULL;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = NULL;
    if(globalFive==5)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_ncpy_63b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    {
        wchar_t source[10+1] = SRC_STRING;
        wcsncpy(data, source, wcslen(source) + 1);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    {
        wchar_t source[10+1] = SRC_STRING;
        wcsncpy(data, source, wcslen(source) + 1);
        printWLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_53c.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_61a.c,CWE122,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
int var(int data);
void var()
{
    int data;
    data = -1;
    data = var(data);
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
#endif 
#ifndef OMITGOOD
int var(int data);
static void goodG2B()
{
    int data;
    data = -1;
    data = var(data);
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
int var(int data);
static void goodB2G()
{
    int data;
    data = -1;
    data = var(data);
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
        free(buffer);
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_54e.c,CWE122,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data)
{
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
void var(int data)
{
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
        free(buffer);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memcpy_18.c,CWE122,bad,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STR ""0123456789abcdef0123456789abcde""
typedef struct _charVoid
{
    char charFirst[16];
    void * voidSecond;
    void * voidThird;
} charVoid;
#ifndef OMITBAD
void var()
{
    goto sink;
sink:
    {
        charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
        if (structCharVoid == NULL) {exit(-1);}
        structCharVoid->voidSecond = (void *)SRC_STR;
        printLine((char *)structCharVoid->voidSecond);
        memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
        structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; 
        printLine((char *)structCharVoid->charFirst);
        printLine((char *)structCharVoid->voidSecond);
        free(structCharVoid);
    }
}
#endif 
#ifndef OMITGOOD
static void good1()
{
    goto sink;
sink:
    {
        charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
        if (structCharVoid == NULL) {exit(-1);}
        structCharVoid->voidSecond = (void *)SRC_STR;
        printLine((char *)structCharVoid->voidSecond);
        memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
        structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; 
        printLine((char *)structCharVoid->charFirst);
        printLine((char *)structCharVoid->voidSecond);
        free(structCharVoid);
    }
}
void var()
{
    good1();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_18.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    goto source;
source:
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    {
        char dest[50] = """";
        strcat(dest, data);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    goto source;
source:
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    {
        char dest[50] = """";
        strcat(dest, data);
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cpy_15.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = NULL;
    switch(6)
    {
    case 6:
        data = (wchar_t *)malloc(50*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscpy(data, source);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = NULL;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
        break;
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscpy(data, source);
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = NULL;
    switch(6)
    {
    case 6:
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscpy(data, source);
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_03.c,CWE122,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(5==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = -1;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodB2G2()
{
    int data;
    data = -1;
    if(5==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(5==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodG2B1()
{
    int data;
    data = -1;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 7;
    }
    if(5==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = -1;
    if(5==5)
    {
        data = 7;
    }
    if(5==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_snprintf_68b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif
extern char * var;
extern char * var;
#ifndef OMITBAD
void var()
{
    char * data = var;
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        SNPRINTF(data, 100, ""%s"", source);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    char * data = var;
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        SNPRINTF(data, 100, ""%s"", source);
        printLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_08.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STR L""0123456789abcdef0123456789abcde""
typedef struct _charVoid
{
    wchar_t charFirst[16];
    void * voidSecond;
    void * voidThird;
} charVoid;
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    if(staticReturnsTrue())
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            printWLine((wchar_t *)structCharVoid->voidSecond);
            memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; 
            printWLine((wchar_t *)structCharVoid->charFirst);
            printWLine((wchar_t *)structCharVoid->voidSecond);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void good1()
{
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            printWLine((wchar_t *)structCharVoid->voidSecond);
            memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; 
            printWLine((wchar_t *)structCharVoid->charFirst);
            printWLine((wchar_t *)structCharVoid->voidSecond);
        }
    }
}
static void good2()
{
    if(staticReturnsTrue())
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            printWLine((wchar_t *)structCharVoid->voidSecond);
            memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; 
            printWLine((wchar_t *)structCharVoid->charFirst);
            printWLine((wchar_t *)structCharVoid->voidSecond);
        }
    }
}
void var()
{
    good1();
    good2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_66a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * dataArray[]);
void var()
{
    char * data;
    char * dataArray[5];
    data = (char *)malloc(100*sizeof(char));
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(char * dataArray[]);
static void goodG2B()
{
    char * data;
    char * dataArray[5];
    data = (char *)malloc(100*sizeof(char));
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_53b.c,CWE122,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_loop_22b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
extern int var;
int64_t * var(int64_t * data)
{
    if(var)
    {
        data = (int64_t *)malloc(50*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
    }
    return data;
}
#endif 
#ifndef OMITGOOD
extern int var;
extern int var;
int64_t * var(int64_t * data)
{
    if(var)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
    }
    return data;
}
int64_t * var(int64_t * data)
{
    if(var)
    {
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
    }
    return data;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_34.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
typedef union
{
    wchar_t * unionFirst;
    wchar_t * unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    var myUnion;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t dest[50] = L"""";
            wcsncpy(dest, data, wcslen(data));
            dest[50-1] = L'\0'; 
            printWLine(data);
            free(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    var myUnion;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t dest[50] = L"""";
            wcsncpy(dest, data, wcslen(data));
            dest[50-1] = L'\0'; 
            printWLine(data);
            free(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_51a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_02.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    if(1)
    {
        data = (char *)malloc(10*sizeof(char));
        if (data == NULL) {exit(-1);}
    }
    {
        char source[10+1] = SRC_STRING;
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = NULL;
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (char *)malloc((10+1)*sizeof(char));
        if (data == NULL) {exit(-1);}
    }
    {
        char source[10+1] = SRC_STRING;
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = NULL;
    if(1)
    {
        data = (char *)malloc((10+1)*sizeof(char));
        if (data == NULL) {exit(-1);}
    }
    {
        char source[10+1] = SRC_STRING;
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_12.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(globalReturnsTrueOrFalse())
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(globalReturnsTrueOrFalse())
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_53a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(twoIntsStruct * data);
void var()
{
    twoIntsStruct * data;
    data = NULL;
    data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(twoIntsStruct * data);
static void goodG2B()
{
    twoIntsStruct * data;
    data = NULL;
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_loop_68b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
extern char * var;
extern char * var;
#ifndef OMITBAD
void var()
{
    char * data = var;
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    char * data = var;
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_src_wchar_t_cat_53c.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_61b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
twoIntsStruct * var(twoIntsStruct * data)
{
    data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    return data;
}
#endif 
#ifndef OMITGOOD
twoIntsStruct * var(twoIntsStruct * data)
{
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    if (data == NULL) {exit(-1);}
    return data;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_52b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_14.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int * data;
    data = NULL;
    if(globalFive==5)
    {
        data = (int *)malloc(10);
        if (data == NULL) {exit(-1);}
    }
    {
        int source[10] = {0};
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    int * data;
    data = NULL;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (int *)malloc(10*sizeof(int));
        if (data == NULL) {exit(-1);}
    }
    {
        int source[10] = {0};
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
static void goodG2B2()
{
    int * data;
    data = NULL;
    if(globalFive==5)
    {
        data = (int *)malloc(10*sizeof(int));
        if (data == NULL) {exit(-1);}
    }
    {
        int source[10] = {0};
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_loop_68b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
extern char * var;
extern char * var;
#ifndef OMITBAD
void var()
{
    char * data = var;
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    char * data = var;
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_54b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_snprintf_17.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var()
{
    int i;
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    for(i = 0; i < 1; i++)
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int h;
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    for(h = 0; h < 1; h++)
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__CWE135_34.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
typedef union
{
    void * unionFirst;
    void * unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    void * data;
    var myUnion;
    data = NULL;
    {
        wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));
        if (dataBadBuffer == NULL) {exit(-1);}
        wmemset(dataBadBuffer, L'A', 50-1);
        dataBadBuffer[50-1] = L'\0';
        data = (void *)dataBadBuffer;
    }
    myUnion.unionFirst = data;
    {
        void * data = myUnion.unionSecond;
        {
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t));
            if (dest == NULL) {exit(-1);}
            (void)wcscpy(dest, data);
            printLine((char *)dest);
            free(dest);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    void * data;
    var myUnion;
    data = NULL;
    {
        char * dataGoodBuffer = (char *)malloc(50*sizeof(char));
        if (dataGoodBuffer == NULL) {exit(-1);}
        memset(dataGoodBuffer, 'A', 50-1);
        dataGoodBuffer[50-1] = '\0';
        data = (void *)dataGoodBuffer;
    }
    myUnion.unionFirst = data;
    {
        void * data = myUnion.unionSecond;
        {
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)calloc(dataLen+1, 1);
            if (dest == NULL) {exit(-1);}
            (void)strcpy(dest, data);
            printLine((char *)dest);
            free(dest);
        }
    }
}
static void goodB2G()
{
    void * data;
    var myUnion;
    data = NULL;
    {
        wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));
        if (dataBadBuffer == NULL) {exit(-1);}
        wmemset(dataBadBuffer, L'A', 50-1);
        dataBadBuffer[50-1] = L'\0';
        data = (void *)dataBadBuffer;
    }
    myUnion.unionFirst = data;
    {
        void * data = myUnion.unionSecond;
        {
            size_t dataLen = wcslen((wchar_t *)data);
            void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t));
            if (dest == NULL) {exit(-1);}
            (void)wcscpy(dest, data);
            printWLine((wchar_t *)dest);
            free(dest);
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_61a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
wchar_t * var(wchar_t * data);
void var()
{
    wchar_t * data;
    data = NULL;
    data = var(data);
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memmove(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
wchar_t * var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    data = NULL;
    data = var(data);
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memmove(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_22b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
extern int var;
char * var(char * data)
{
    if(var)
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    return data;
}
#endif 
#ifndef OMITGOOD
extern int var;
extern int var;
char * var(char * data)
{
    if(var)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    return data;
}
char * var(char * data)
{
    if(var)
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    return data;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_65a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var()
{
    char * data;
    void (*funcPtr) (char *) = var;
    data = NULL;
    data = (char *)malloc(50*sizeof(char));
    data[0] = '\0'; 
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
static void goodG2B()
{
    char * data;
    void (*funcPtr) (char *) = var;
    data = NULL;
    data = (char *)malloc(100*sizeof(char));
    data[0] = '\0'; 
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_loop_52a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * data);
void var()
{
    int64_t * data;
    data = NULL;
    data = (int64_t *)malloc(50*sizeof(int64_t));
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t * data);
static void goodG2B()
{
    int64_t * data;
    data = NULL;
    data = (int64_t *)malloc(100*sizeof(int64_t));
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_src_wchar_t_cpy_31.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    {
        wchar_t * dataCopy = data;
        wchar_t * data = dataCopy;
        {
            wchar_t dest[50] = L"""";
            wcscpy(dest, data);
            printWLine(data);
            free(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    {
        wchar_t * dataCopy = data;
        wchar_t * data = dataCopy;
        {
            wchar_t dest[50] = L"""";
            wcscpy(dest, data);
            printWLine(data);
            free(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_cpy_52c.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        wchar_t source[10+1] = SRC_STRING;
        wcscpy(data, source);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        wchar_t source[10+1] = SRC_STRING;
        wcscpy(data, source);
        printWLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_loop_64a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(void * dataVoidPtr);
void var()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc(50*sizeof(wchar_t));
    data[0] = L'\0'; 
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr);
static void goodG2B()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    data[0] = L'\0'; 
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_loop_12.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    twoIntsStruct * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
    }
    else
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printStructLine(&data[0]);
            free(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    twoIntsStruct * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
    }
    else
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printStructLine(&data[0]);
            free(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_snprintf_54b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_67a.c,CWE122,good,"#include ""std_testcase.h""
typedef struct _CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_67_structType
{
    int * structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct);
void var()
{
    int * data;
    var myStruct;
    data = NULL;
    data = (int *)malloc(10);
    myStruct.structFirst = data;
    var(myStruct);
}
#endif 
#ifndef OMITGOOD
void var(var myStruct);
static void goodG2B()
{
    int * data;
    var myStruct;
    data = NULL;
    data = (int *)malloc(10*sizeof(int));
    myStruct.structFirst = data;
    var(myStruct);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_snprintf_11.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF swprintf
#endif
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = NULL;
    if(globalReturnsTrue())
    {
        data = (wchar_t *)malloc(50*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = NULL;
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = NULL;
    if(globalReturnsTrue())
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_08.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    if(staticReturnsTrue())
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strcpy(dest, data);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strcpy(dest, data);
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    if(staticReturnsTrue())
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strcpy(dest, data);
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_loop_22a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
int var = 0;
wchar_t * var(wchar_t * data);
void var()
{
    wchar_t * data;
    data = NULL;
    var = 1; 
    data = var(data);
    {
        wchar_t source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = wcslen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
int var = 0;
int var = 0;
wchar_t * var(wchar_t * data);
static void goodG2B1()
{
    wchar_t * data;
    data = NULL;
    var = 0; 
    data = var(data);
    {
        wchar_t source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = wcslen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printWLine(data);
        free(data);
    }
}
wchar_t * var(wchar_t * data);
static void goodG2B2()
{
    wchar_t * data;
    data = NULL;
    var = 1; 
    data = var(data);
    {
        wchar_t source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = wcslen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memmove_09.c,CWE122,bad,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STR ""0123456789abcdef0123456789abcde""
typedef struct _charVoid
{
    char charFirst[16];
    void * voidSecond;
    void * voidThird;
} charVoid;
#ifndef OMITBAD
void var()
{
    if(GLOBAL_CONST_TRUE)
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            printLine((char *)structCharVoid->voidSecond);
            memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; 
            printLine((char *)structCharVoid->charFirst);
            printLine((char *)structCharVoid->voidSecond);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void good1()
{
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            printLine((char *)structCharVoid->voidSecond);
            memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; 
            printLine((char *)structCharVoid->charFirst);
            printLine((char *)structCharVoid->voidSecond);
        }
    }
}
static void good2()
{
    if(GLOBAL_CONST_TRUE)
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            printLine((char *)structCharVoid->voidSecond);
            memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; 
            printLine((char *)structCharVoid->charFirst);
            printLine((char *)structCharVoid->voidSecond);
        }
    }
}
void var()
{
    good1();
    good2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_32.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int * data;
    int * *dataPtr1 = &data;
    int * *dataPtr2 = &data;
    data = NULL;
    {
        int * data = *dataPtr1;
        data = (int *)malloc(50*sizeof(int));
        if (data == NULL) {exit(-1);}
        *dataPtr1 = data;
    }
    {
        int * data = *dataPtr2;
        {
            int source[100] = {0}; 
            memcpy(data, source, 100*sizeof(int));
            printIntLine(data[0]);
            free(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int * data;
    int * *dataPtr1 = &data;
    int * *dataPtr2 = &data;
    data = NULL;
    {
        int * data = *dataPtr1;
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        *dataPtr1 = data;
    }
    {
        int * data = *dataPtr2;
        {
            int source[100] = {0}; 
            memcpy(data, source, 100*sizeof(int));
            printIntLine(data[0]);
            free(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_32.c,CWE122,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    data = NULL;
    {
        char * data = *dataPtr1;
        data = (char *)malloc(50*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char source[100];
            memset(source, 'C', 100-1); 
            source[100-1] = '\0'; 
            strncpy(data, source, 100-1);
            data[100-1] = '\0'; 
            printLine(data);
            free(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    data = NULL;
    {
        char * data = *dataPtr1;
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char source[100];
            memset(source, 'C', 100-1); 
            source[100-1] = '\0'; 
            strncpy(data, source, 100-1);
            data[100-1] = '\0'; 
            printLine(data);
            free(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_snprintf_52b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_large_08.c,CWE122,good,"#include ""std_testcase.h""
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    if(staticReturnsTrue())
    {
        data = 10;
    }
    if(staticReturnsTrue())
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = -1;
    if(staticReturnsTrue())
    {
        data = 10;
    }
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodB2G2()
{
    int data;
    data = -1;
    if(staticReturnsTrue())
    {
        data = 10;
    }
    if(staticReturnsTrue())
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodG2B1()
{
    int data;
    data = -1;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 7;
    }
    if(staticReturnsTrue())
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = -1;
    if(staticReturnsTrue())
    {
        data = 7;
    }
    if(staticReturnsTrue())
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_snprintf_22b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
extern int var;
wchar_t * var(wchar_t * data)
{
    if(var)
    {
        data = (wchar_t *)malloc(50*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    return data;
}
#endif 
#ifndef OMITGOOD
extern int var;
extern int var;
wchar_t * var(wchar_t * data)
{
    if(var)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    return data;
}
wchar_t * var(wchar_t * data)
{
    if(var)
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    return data;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_rand_12.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    if(globalReturnsTrueOrFalse())
    {
        data = RAND32();
    }
    else
    {
        data = 7;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
    else
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int data;
    data = -1;
    if(globalReturnsTrueOrFalse())
    {
        data = RAND32();
    }
    else
    {
        data = RAND32();
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
    else
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodG2B()
{
    int data;
    data = -1;
    if(globalReturnsTrueOrFalse())
    {
        data = 7;
    }
    else
    {
        data = 7;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
    else
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cat_12.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = (wchar_t *)malloc(50*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    else
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscat(data, source);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    else
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscat(data, source);
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_snprintf_65a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var(wchar_t * data);
void var()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = var;
    data = NULL;
    data = (wchar_t *)malloc(50*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0'; 
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = var;
    data = NULL;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0'; 
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_61b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
int * var(int * data)
{
    data = (int *)malloc(50*sizeof(int));
    if (data == NULL) {exit(-1);}
    return data;
}
#endif 
#ifndef OMITGOOD
int * var(int * data)
{
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    return data;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memcpy_31.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t * data;
    data = NULL;
    data = (int64_t *)malloc(50*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    {
        int64_t * dataCopy = data;
        int64_t * data = dataCopy;
        {
            int64_t source[100] = {0}; 
            memcpy(data, source, 100*sizeof(int64_t));
            printLongLongLine(data[0]);
            free(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int64_t * data;
    data = NULL;
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    {
        int64_t * dataCopy = data;
        int64_t * data = dataCopy;
        {
            int64_t source[100] = {0}; 
            memcpy(data, source, 100*sizeof(int64_t));
            printLongLongLine(data[0]);
            free(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_21.c,CWE122,bad,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
static int badStatic = 0;
static char * badSource(char * data)
{
    if(badStatic)
    {
        data = (char *)malloc(10*sizeof(char));
        if (data == NULL) {exit(-1);}
    }
    return data;
}
void var()
{
    char * data;
    data = NULL;
    badStatic = 1; 
    data = badSource(data);
    {
        char source[10+1] = SRC_STRING;
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static int goodG2B1Static = 0;
static int goodG2B2Static = 0;
static char * goodG2B1Source(char * data)
{
    if(goodG2B1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (char *)malloc((10+1)*sizeof(char));
        if (data == NULL) {exit(-1);}
    }
    return data;
}
static void goodG2B1()
{
    char * data;
    data = NULL;
    goodG2B1Static = 0; 
    data = goodG2B1Source(data);
    {
        char source[10+1] = SRC_STRING;
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
        free(data);
    }
}
static char * goodG2B2Source(char * data)
{
    if(goodG2B2Static)
    {
        data = (char *)malloc((10+1)*sizeof(char));
        if (data == NULL) {exit(-1);}
    }
    return data;
}
static void goodG2B2()
{
    char * data;
    data = NULL;
    goodG2B2Static = 1; 
    data = goodG2B2Source(data);
    {
        char source[10+1] = SRC_STRING;
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_68a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
wchar_t * var;
wchar_t * var;
#ifndef OMITBAD
void var();
void var()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    var = data;
    var();
}
#endif 
#ifndef OMITGOOD
void var();
static void goodG2B()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    var = data;
    var();
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_15.c,CWE122,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    switch(6)
    {
    case 6:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = -1;
    switch(6)
    {
    case 6:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(8)
    {
    case 7:
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
        free(buffer);
    }
    break;
    }
}
static void goodB2G2()
{
    int data;
    data = -1;
    switch(6)
    {
    case 6:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
        free(buffer);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B1()
{
    int data;
    data = -1;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        data = 7;
        break;
    }
    switch(7)
    {
    case 7:
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
static void goodG2B2()
{
    int data;
    data = -1;
    switch(6)
    {
    case 6:
        data = 7;
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
    break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_65b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * data)
{
    {
        int source[10] = {0};
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(int * data)
{
    {
        int source[10] = {0};
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_snprintf_14.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    if(globalFive==5)
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    if(globalFive==5)
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_07.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
static int staticFive = 5;
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(staticFive==5)
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        memmove(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        memmove(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(staticFive==5)
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        memmove(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_61a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
char * var(char * data);
void var()
{
    char * data;
    data = NULL;
    data = var(data);
    {
        char source[10+1] = SRC_STRING;
        strcpy(data, source);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
char * var(char * data);
static void goodG2B()
{
    char * data;
    data = NULL;
    data = var(data);
    {
        char source[10+1] = SRC_STRING;
        strcpy(data, source);
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_loop_42.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
static char * badSource(char * data)
{
    data = (char *)malloc(10*sizeof(char));
    if (data == NULL) {exit(-1);}
    return data;
}
void var()
{
    char * data;
    data = NULL;
    data = badSource(data);
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static char * goodG2BSource(char * data)
{
    data = (char *)malloc((10+1)*sizeof(char));
    if (data == NULL) {exit(-1);}
    return data;
}
static void goodG2B()
{
    char * data;
    data = NULL;
    data = goodG2BSource(data);
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_54e.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data)
{
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * data)
{
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_45.c,CWE122,bad,"#include ""std_testcase.h""
static int * var;
static int * var;
#ifndef OMITBAD
static void badSink()
{
    int * data = var;
    {
        int source[10] = {0};
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
void var()
{
    int * data;
    data = NULL;
    data = (int *)malloc(10);
    if (data == NULL) {exit(-1);}
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    int * data = var;
    {
        int source[10] = {0};
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
static void goodG2B()
{
    int * data;
    data = NULL;
    data = (int *)malloc(10*sizeof(int));
    if (data == NULL) {exit(-1);}
    var = data;
    goodG2BSink();
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_loop_53c.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * data);
void var(int * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int * data);
void var(int * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_54e.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data)
{
    {
        char dest[50] = """";
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * data)
{
    {
        char dest[50] = """";
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_10.c,CWE122,bad,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = NULL;
    if(globalTrue)
    {
        data = (wchar_t *)malloc(10*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = NULL;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = NULL;
    if(globalTrue)
    {
        data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_31.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc(50*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0'; 
    {
        wchar_t * dataCopy = data;
        wchar_t * data = dataCopy;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); 
            source[100-1] = L'\0'; 
            memmove(data, source, 100*sizeof(wchar_t));
            data[100-1] = L'\0'; 
            printWLine(data);
            free(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0'; 
    {
        wchar_t * dataCopy = data;
        wchar_t * data = dataCopy;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); 
            source[100-1] = L'\0'; 
            memmove(data, source, 100*sizeof(wchar_t));
            data[100-1] = L'\0'; 
            printWLine(data);
            free(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_11.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    twoIntsStruct * data;
    data = NULL;
    if(globalReturnsTrue())
    {
        data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    twoIntsStruct * data;
    data = NULL;
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
        free(data);
    }
}
static void goodG2B2()
{
    twoIntsStruct * data;
    data = NULL;
    if(globalReturnsTrue())
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_06.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STR L""0123456789abcdef0123456789abcde""
typedef struct _charVoid
{
    wchar_t charFirst[16];
    void * voidSecond;
    void * voidThird;
} charVoid;
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    if(STATIC_CONST_FIVE==5)
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            printWLine((wchar_t *)structCharVoid->voidSecond);
            memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; 
            printWLine((wchar_t *)structCharVoid->charFirst);
            printWLine((wchar_t *)structCharVoid->voidSecond);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void good1()
{
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            printWLine((wchar_t *)structCharVoid->voidSecond);
            memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; 
            printWLine((wchar_t *)structCharVoid->charFirst);
            printWLine((wchar_t *)structCharVoid->voidSecond);
        }
    }
}
static void good2()
{
    if(STATIC_CONST_FIVE==5)
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            printWLine((wchar_t *)structCharVoid->voidSecond);
            memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; 
            printWLine((wchar_t *)structCharVoid->charFirst);
            printWLine((wchar_t *)structCharVoid->voidSecond);
        }
    }
}
void var()
{
    good1();
    good2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_04.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
static const int STATIC_CONST_TRUE = 1; 
static const int STATIC_CONST_FALSE = 0; 
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        data = (char *)malloc(50*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = NULL;
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memcpy_44.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
static void badSink(int64_t * data)
{
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        free(data);
    }
}
void var()
{
    int64_t * data;
    void (*funcPtr) (int64_t *) = badSink;
    data = NULL;
    data = (int64_t *)malloc(50*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(int64_t * data)
{
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        free(data);
    }
}
static void goodG2B()
{
    int64_t * data;
    void (*funcPtr) (int64_t *) = goodG2BSink;
    data = NULL;
    data = (int64_t *)malloc(100*sizeof(int64_t));
    if (data == NULL) {exit(-1);}
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_64a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(void * dataVoidPtr);
void var()
{
    char * data;
    data = NULL;
    data = (char *)malloc(50*sizeof(char));
    data[0] = '\0'; 
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr);
static void goodG2B()
{
    char * data;
    data = NULL;
    data = (char *)malloc(100*sizeof(char));
    data[0] = '\0'; 
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_13.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    if(GLOBAL_CONST_FIVE==5)
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    if(GLOBAL_CONST_FIVE==5)
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_loop_05.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = NULL;
    if(staticTrue)
    {
        data = (wchar_t *)malloc(50*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = NULL;
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = NULL;
    if(staticTrue)
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_53b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * data);
void var(int * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int * data);
void var(int * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__CWE135_63a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(void * * dataPtr);
void var()
{
    void * data;
    data = NULL;
    {
        wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));
        if (dataBadBuffer == NULL) {exit(-1);}
        wmemset(dataBadBuffer, L'A', 50-1);
        dataBadBuffer[50-1] = L'\0';
        data = (void *)dataBadBuffer;
    }
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(void * * data);
static void goodG2B()
{
    void * data;
    data = NULL;
    {
        char * dataGoodBuffer = (char *)malloc(50*sizeof(char));
        if (dataGoodBuffer == NULL) {exit(-1);}
        memset(dataGoodBuffer, 'A', 50-1);
        dataGoodBuffer[50-1] = '\0';
        data = (void *)dataGoodBuffer;
    }
    var(&data);
}
void var(void * * data);
static void goodB2G()
{
    void * data;
    data = NULL;
    {
        wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));
        if (dataBadBuffer == NULL) {exit(-1);}
        wmemset(dataBadBuffer, L'A', 50-1);
        dataBadBuffer[50-1] = L'\0';
        data = (void *)dataBadBuffer;
    }
    var(&data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_66b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    {
        wchar_t dest[50] = L"""";
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    {
        wchar_t dest[50] = L"""";
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_44.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
static void badSink(char * data)
{
    {
        char dest[50] = """";
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
void var()
{
    char * data;
    void (*funcPtr) (char *) = badSink;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(char * data)
{
    {
        char dest[50] = """";
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
static void goodG2B()
{
    char * data;
    void (*funcPtr) (char *) = goodG2BSink;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memmove_16.c,CWE122,bad,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STR ""0123456789abcdef0123456789abcde""
typedef struct _charVoid
{
    char charFirst[16];
    void * voidSecond;
    void * voidThird;
} charVoid;
#ifndef OMITBAD
void var()
{
    while(1)
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            printLine((char *)structCharVoid->voidSecond);
            memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; 
            printLine((char *)structCharVoid->charFirst);
            printLine((char *)structCharVoid->voidSecond);
        }
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void good1()
{
    while(1)
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            printLine((char *)structCharVoid->voidSecond);
            memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; 
            printLine((char *)structCharVoid->charFirst);
            printLine((char *)structCharVoid->voidSecond);
        }
        break;
    }
}
void var()
{
    good1();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_14.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    if(globalFive==5)
    {
        data = (char *)malloc(50*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcpy(data, source);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = NULL;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcpy(data, source);
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = NULL;
    if(globalFive==5)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcpy(data, source);
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_12.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STR L""0123456789abcdef0123456789abcde""
typedef struct _charVoid
{
    wchar_t charFirst[16];
    void * voidSecond;
    void * voidThird;
} charVoid;
#ifndef OMITBAD
void var()
{
    if(globalReturnsTrueOrFalse())
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            printWLine((wchar_t *)structCharVoid->voidSecond);
            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; 
            printWLine((wchar_t *)structCharVoid->charFirst);
            printWLine((wchar_t *)structCharVoid->voidSecond);
            free(structCharVoid);
        }
    }
    else
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            printWLine((wchar_t *)structCharVoid->voidSecond);
            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; 
            printWLine((wchar_t *)structCharVoid->charFirst);
            printWLine((wchar_t *)structCharVoid->voidSecond);
            free(structCharVoid);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void good1()
{
    if(globalReturnsTrueOrFalse())
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            printWLine((wchar_t *)structCharVoid->voidSecond);
            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; 
            printWLine((wchar_t *)structCharVoid->charFirst);
            printWLine((wchar_t *)structCharVoid->voidSecond);
            free(structCharVoid);
        }
    }
    else
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            printWLine((wchar_t *)structCharVoid->voidSecond);
            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; 
            printWLine((wchar_t *)structCharVoid->charFirst);
            printWLine((wchar_t *)structCharVoid->voidSecond);
            free(structCharVoid);
        }
    }
}
void var()
{
    good1();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_41.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * data)
{
    {
        int source[10] = {0};
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
void var()
{
    int * data;
    data = NULL;
    data = (int *)malloc(10);
    if (data == NULL) {exit(-1);}
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int * data)
{
    {
        int source[10] = {0};
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
static void goodG2B()
{
    int * data;
    data = NULL;
    data = (int *)malloc(10*sizeof(int));
    if (data == NULL) {exit(-1);}
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_64b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    char * * dataPtr = (char * *)dataVoidPtr;
    char * data = (*dataPtr);
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    char * * dataPtr = (char * *)dataVoidPtr;
    char * data = (*dataPtr);
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_loop_44.c,CWE122,bad,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
static void badSink(wchar_t * data)
{
    {
        wchar_t source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = wcslen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printWLine(data);
        free(data);
    }
}
void var()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = badSink;
    data = NULL;
    data = (wchar_t *)malloc(10*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(wchar_t * data)
{
    {
        wchar_t source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = wcslen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printWLine(data);
        free(data);
    }
}
static void goodG2B()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = goodG2BSink;
    data = NULL;
    data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_loop_04.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
static const int STATIC_CONST_TRUE = 1; 
static const int STATIC_CONST_FALSE = 0; 
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        data = (char *)malloc(50*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = NULL;
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_src_wchar_t_cat_64b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;
    wchar_t * data = (*dataPtr);
    {
        wchar_t dest[50] = L"""";
        wcscat(dest, data);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;
    wchar_t * data = (*dataPtr);
    {
        wchar_t dest[50] = L"""";
        wcscat(dest, data);
        printWLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_65b.c,CWE122,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data)
{
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
void var(int data)
{
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
        free(buffer);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_66b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * dataArray[])
{
    char * data = dataArray[2];
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * dataArray[])
{
    char * data = dataArray[2];
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_02.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    if(1)
    {
        data = (char *)malloc(50*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = NULL;
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = NULL;
    if(1)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_loop_21.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
static int badStatic = 0;
static int * badSource(int * data)
{
    if(badStatic)
    {
        data = (int *)malloc(50*sizeof(int));
        if (data == NULL) {exit(-1);}
    }
    return data;
}
void var()
{
    int * data;
    data = NULL;
    badStatic = 1; 
    data = badSource(data);
    {
        int source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            free(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static int goodG2B1Static = 0;
static int goodG2B2Static = 0;
static int * goodG2B1Source(int * data)
{
    if(goodG2B1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
    }
    return data;
}
static void goodG2B1()
{
    int * data;
    data = NULL;
    goodG2B1Static = 0; 
    data = goodG2B1Source(data);
    {
        int source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            free(data);
        }
    }
}
static int * goodG2B2Source(int * data)
{
    if(goodG2B2Static)
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
    }
    return data;
}
static void goodG2B2()
{
    int * data;
    data = NULL;
    goodG2B2Static = 1; 
    data = goodG2B2Source(data);
    {
        int source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            free(data);
        }
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_65b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memmove(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memmove(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_loop_54e.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * data)
{
    {
        int source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            free(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
void var(int * data)
{
    {
        int source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            free(data);
        }
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_45.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
static char * var;
static char * var;
#ifndef OMITBAD
static void badSink()
{
    char * data = var;
    {
        char dest[50] = """";
        strcpy(dest, data);
        printLine(data);
        free(data);
    }
}
void var()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    char * data = var;
    {
        char dest[50] = """";
        strcpy(dest, data);
        printLine(data);
        free(data);
    }
}
static void goodG2B()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    var = data;
    goodG2BSink();
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncpy_16.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    while(1)
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
        break;
    }
    {
        char dest[50] = """";
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    while(1)
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
        break;
    }
    {
        char dest[50] = """";
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_cpy_44.c,CWE122,bad,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
static void badSink(wchar_t * data)
{
    {
        wchar_t source[10+1] = SRC_STRING;
        wcscpy(data, source);
        printWLine(data);
        free(data);
    }
}
void var()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = badSink;
    data = NULL;
    data = (wchar_t *)malloc(10*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(wchar_t * data)
{
    {
        wchar_t source[10+1] = SRC_STRING;
        wcscpy(data, source);
        printWLine(data);
        free(data);
    }
}
static void goodG2B()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = goodG2BSink;
    data = NULL;
    data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_cpy_22b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
extern int var;
wchar_t * var(wchar_t * data)
{
    if(var)
    {
        data = (wchar_t *)malloc(10*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
    }
    return data;
}
#endif 
#ifndef OMITGOOD
extern int var;
extern int var;
wchar_t * var(wchar_t * data)
{
    if(var)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
    }
    return data;
}
wchar_t * var(wchar_t * data)
{
    if(var)
    {
        data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
    }
    return data;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cpy_07.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
static int staticFive = 5;
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = NULL;
    if(staticFive==5)
    {
        data = (wchar_t *)malloc(50*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscpy(data, source);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = NULL;
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscpy(data, source);
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = NULL;
    if(staticFive==5)
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscpy(data, source);
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_68b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
extern char * var;
extern char * var;
#ifndef OMITBAD
void var()
{
    char * data = var;
    {
        char source[10+1] = SRC_STRING;
        strcpy(data, source);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    char * data = var;
    {
        char source[10+1] = SRC_STRING;
        strcpy(data, source);
        printLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncpy_01.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc(50*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0'; 
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncpy(data, source, 100-1);
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0'; 
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncpy(data, source, 100-1);
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_loop_66b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(twoIntsStruct * dataArray[])
{
    twoIntsStruct * data = dataArray[2];
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printStructLine(&data[0]);
            free(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
void var(twoIntsStruct * dataArray[])
{
    twoIntsStruct * data = dataArray[2];
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printStructLine(&data[0]);
            free(data);
        }
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_09.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    if(GLOBAL_CONST_TRUE)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = -1;
    if(GLOBAL_CONST_TRUE)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodB2G2()
{
    int data;
    data = -1;
    if(GLOBAL_CONST_TRUE)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodG2B1()
{
    int data;
    data = -1;
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 7;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = -1;
    if(GLOBAL_CONST_TRUE)
    {
        data = 7;
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_snprintf_67b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF swprintf
#endif
typedef struct _CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_snprintf_67_structType
{
    wchar_t * structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t dest[50] = L"""";
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(var myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t dest[50] = L"""";
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_05.c,CWE122,bad,"#include ""std_testcase.h""
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void var()
{
    int * data;
    data = NULL;
    if(staticTrue)
    {
        data = (int *)malloc(10);
        if (data == NULL) {exit(-1);}
    }
    {
        int source[10] = {0};
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    int * data;
    data = NULL;
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (int *)malloc(10*sizeof(int));
        if (data == NULL) {exit(-1);}
    }
    {
        int source[10] = {0};
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
static void goodG2B2()
{
    int * data;
    data = NULL;
    if(staticTrue)
    {
        data = (int *)malloc(10*sizeof(int));
        if (data == NULL) {exit(-1);}
    }
    {
        int source[10] = {0};
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_ncpy_65a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var(wchar_t * data);
void var()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = var;
    data = NULL;
    data = (wchar_t *)malloc(10*sizeof(wchar_t));
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = var;
    data = NULL;
    data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_loop_08.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        data = (wchar_t *)malloc(10*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = wcslen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = NULL;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = wcslen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = wcslen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_src_wchar_t_cat_11.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(globalReturnsTrue())
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcscat(dest, data);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcscat(dest, data);
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(globalReturnsTrue())
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcscat(dest, data);
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_02.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    if(1)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(1)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = -1;
    if(1)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodB2G2()
{
    int data;
    data = -1;
    if(1)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(1)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodG2B1()
{
    int data;
    data = -1;
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 7;
    }
    if(1)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = -1;
    if(1)
    {
        data = 7;
    }
    if(1)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncpy_12.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    if(globalReturnsTrueOrFalse())
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    if(globalReturnsTrueOrFalse())
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_ncpy_15.c,CWE122,bad,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = NULL;
    switch(6)
    {
    case 6:
        data = (wchar_t *)malloc(10*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        wcsncpy(data, source, wcslen(source) + 1);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = NULL;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        break;
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        wcsncpy(data, source, wcslen(source) + 1);
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = NULL;
    switch(6)
    {
    case 6:
        data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        wcsncpy(data, source, wcslen(source) + 1);
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_18.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int * data;
    data = NULL;
    goto source;
source:
    data = (int *)malloc(50*sizeof(int));
    if (data == NULL) {exit(-1);}
    {
        int source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int * data;
    data = NULL;
    goto source;
source:
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    {
        int source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_rand_63b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * dataPtr)
{
    int data = *dataPtr;
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
#endif 
#ifndef OMITGOOD
void var(int * dataPtr)
{
    int data = *dataPtr;
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
void var(int * dataPtr)
{
    int data = *dataPtr;
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
        free(buffer);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cat_54a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc(50*sizeof(wchar_t));
    data[0] = L'\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    data[0] = L'\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__sizeof_struct_21.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
static int badStatic = 0;
static twoIntsStruct * badSource(twoIntsStruct * data)
{
    if(badStatic)
    {
        data = (twoIntsStruct *)malloc(sizeof(data));
        if (data == NULL) {exit(-1);}
        data->intOne = 1;
        data->intTwo = 2;
    }
    return data;
}
void var()
{
    twoIntsStruct * data;
    data = NULL;
    badStatic = 1; 
    data = badSource(data);
    printStructLine(data);
    free(data);
}
#endif 
#ifndef OMITGOOD
static int goodG2B1Static = 0;
static int goodG2B2Static = 0;
static twoIntsStruct * goodG2B1Source(twoIntsStruct * data)
{
    if(goodG2B1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (twoIntsStruct *)malloc(sizeof(*data));
        if (data == NULL) {exit(-1);}
        data->intOne = 1;
        data->intTwo = 2;
    }
    return data;
}
static void goodG2B1()
{
    twoIntsStruct * data;
    data = NULL;
    goodG2B1Static = 0; 
    data = goodG2B1Source(data);
    printStructLine(data);
    free(data);
}
static twoIntsStruct * goodG2B2Source(twoIntsStruct * data)
{
    if(goodG2B2Static)
    {
        data = (twoIntsStruct *)malloc(sizeof(*data));
        if (data == NULL) {exit(-1);}
        data->intOne = 1;
        data->intTwo = 2;
    }
    return data;
}
static void goodG2B2()
{
    twoIntsStruct * data;
    data = NULL;
    goodG2B2Static = 1; 
    data = goodG2B2Source(data);
    printStructLine(data);
    free(data);
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_15.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    twoIntsStruct * data;
    data = NULL;
    switch(6)
    {
    case 6:
        data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    twoIntsStruct * data;
    data = NULL;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        break;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
        free(data);
    }
}
static void goodG2B2()
{
    twoIntsStruct * data;
    data = NULL;
    switch(6)
    {
    case 6:
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_07.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
static int staticFive = 5;
#ifndef OMITBAD
void var()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    if(staticFive==5)
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strcat(dest, data);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strcat(dest, data);
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    if(staticFive==5)
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strcat(dest, data);
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_52a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(twoIntsStruct * data);
void var()
{
    twoIntsStruct * data;
    data = NULL;
    data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(twoIntsStruct * data);
static void goodG2B()
{
    twoIntsStruct * data;
    data = NULL;
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_06.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = (char *)malloc(50*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = NULL;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_53d.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data)
{
    {
        char dest[50] = """";
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * data)
{
    {
        char dest[50] = """";
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_16.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int * data;
    data = NULL;
    while(1)
    {
        data = (int *)malloc(50*sizeof(int));
        if (data == NULL) {exit(-1);}
        break;
    }
    {
        int source[100] = {0}; 
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int * data;
    data = NULL;
    while(1)
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        break;
    }
    {
        int source[100] = {0}; 
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_53b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(twoIntsStruct * data);
void var(twoIntsStruct * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(twoIntsStruct * data);
void var(twoIntsStruct * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_61a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
wchar_t * var(wchar_t * data);
void var()
{
    wchar_t * data;
    data = NULL;
    data = var(data);
    {
        wchar_t source[10+1] = SRC_STRING;
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
wchar_t * var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    data = NULL;
    data = var(data);
    {
        wchar_t source[10+1] = SRC_STRING;
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_loop_63a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var(wchar_t * * dataPtr);
void var()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc(10*sizeof(wchar_t));
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * * data);
static void goodG2B()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_10.c,CWE122,bad,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    if(globalTrue)
    {
        data = (char *)malloc(10*sizeof(char));
        if (data == NULL) {exit(-1);}
    }
    {
        char source[10+1] = SRC_STRING;
        memmove(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = NULL;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (char *)malloc((10+1)*sizeof(char));
        if (data == NULL) {exit(-1);}
    }
    {
        char source[10+1] = SRC_STRING;
        memmove(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = NULL;
    if(globalTrue)
    {
        data = (char *)malloc((10+1)*sizeof(char));
        if (data == NULL) {exit(-1);}
    }
    {
        char source[10+1] = SRC_STRING;
        memmove(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_53a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(char * data);
void var()
{
    char * data;
    data = NULL;
    data = (char *)malloc(10*sizeof(char));
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
static void goodG2B()
{
    char * data;
    data = NULL;
    data = (char *)malloc((10+1)*sizeof(char));
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_snprintf_68a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF snprintf
#endif
wchar_t * var;
wchar_t * var;
#ifndef OMITBAD
void var();
void var()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc(50*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0'; 
    var = data;
    var();
}
#endif 
#ifndef OMITGOOD
void var();
static void goodG2B()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0'; 
    var = data;
    var();
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_53a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var()
{
    char * data;
    data = NULL;
    data = (char *)malloc(50*sizeof(char));
    data[0] = '\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
static void goodG2B()
{
    char * data;
    data = NULL;
    data = (char *)malloc(100*sizeof(char));
    data[0] = '\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memmove_16.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t * data;
    data = NULL;
    while(1)
    {
        data = (int64_t *)malloc(50*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        break;
    }
    {
        int64_t source[100] = {0}; 
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int64_t * data;
    data = NULL;
    while(1)
    {
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
        break;
    }
    {
        int64_t source[100] = {0}; 
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_snprintf_15.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF swprintf
#endif
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = NULL;
    switch(6)
    {
    case 6:
        data = (wchar_t *)malloc(50*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = NULL;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
        break;
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = NULL;
    switch(6)
    {
    case 6:
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_16.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    while(1)
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
        break;
    }
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    while(1)
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
        break;
    }
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__sizeof_struct_08.c,CWE122,good,"#include ""std_testcase.h""
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    twoIntsStruct * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        data = (twoIntsStruct *)malloc(sizeof(data));
        if (data == NULL) {exit(-1);}
        data->intOne = 1;
        data->intTwo = 2;
    }
    printStructLine(data);
    free(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    twoIntsStruct * data;
    data = NULL;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (twoIntsStruct *)malloc(sizeof(*data));
        if (data == NULL) {exit(-1);}
        data->intOne = 1;
        data->intTwo = 2;
    }
    printStructLine(data);
    free(data);
}
static void goodG2B2()
{
    twoIntsStruct * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        data = (twoIntsStruct *)malloc(sizeof(*data));
        if (data == NULL) {exit(-1);}
        data->intOne = 1;
        data->intTwo = 2;
    }
    printStructLine(data);
    free(data);
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_54b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_51a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(twoIntsStruct * data);
void var()
{
    twoIntsStruct * data;
    data = NULL;
    data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(twoIntsStruct * data);
static void goodG2B()
{
    twoIntsStruct * data;
    data = NULL;
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_61b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
char * var(char * data)
{
    data = (char *)malloc(50*sizeof(char));
    if (data == NULL) {exit(-1);}
    data[0] = '\0'; 
    return data;
}
#endif 
#ifndef OMITGOOD
char * var(char * data)
{
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    data[0] = '\0'; 
    return data;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_03.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    if(5==5)
    {
        data = (char *)malloc(50*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcat(data, source);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = NULL;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcat(data, source);
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = NULL;
    if(5==5)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcat(data, source);
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_68a.c,CWE122,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
int var;
int var;
int var;
#ifndef OMITBAD
void var();
void var()
{
    int data;
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var = data;
    var();
}
#endif 
#ifndef OMITGOOD
void var();
void var();
static void goodG2B()
{
    int data;
    data = -1;
    data = 7;
    var = data;
    var();
}
static void goodB2G()
{
    int data;
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    var = data;
    var();
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_53b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_52c.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data)
{
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
void var(int data)
{
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
        free(buffer);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_loop_63a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * * dataPtr);
void var()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(char * * data);
static void goodG2B()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_loop_54e.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        size_t i, dataLen;
        dataLen = wcslen(data);
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        size_t i, dataLen;
        dataLen = wcslen(data);
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_loop_22b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
extern int var;
twoIntsStruct * var(twoIntsStruct * data)
{
    if(var)
    {
        data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
    }
    return data;
}
#endif 
#ifndef OMITGOOD
extern int var;
extern int var;
twoIntsStruct * var(twoIntsStruct * data)
{
    if(var)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
    }
    return data;
}
twoIntsStruct * var(twoIntsStruct * data)
{
    if(var)
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
    }
    return data;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__CWE135_09.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    void * data;
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        {
            wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));
            if (dataBadBuffer == NULL) {exit(-1);}
            wmemset(dataBadBuffer, L'A', 50-1);
            dataBadBuffer[50-1] = L'\0';
            data = (void *)dataBadBuffer;
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t));
            if (dest == NULL) {exit(-1);}
            (void)wcscpy(dest, data);
            printLine((char *)dest);
            free(dest);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    void * data;
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        {
            wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));
            if (dataBadBuffer == NULL) {exit(-1);}
            wmemset(dataBadBuffer, L'A', 50-1);
            dataBadBuffer[50-1] = L'\0';
            data = (void *)dataBadBuffer;
        }
    }
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            size_t dataLen = wcslen((wchar_t *)data);
            void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t));
            if (dest == NULL) {exit(-1);}
            (void)wcscpy(dest, data);
            printWLine((wchar_t *)dest);
            free(dest);
        }
    }
}
static void goodB2G2()
{
    void * data;
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        {
            wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));
            if (dataBadBuffer == NULL) {exit(-1);}
            wmemset(dataBadBuffer, L'A', 50-1);
            dataBadBuffer[50-1] = L'\0';
            data = (void *)dataBadBuffer;
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            size_t dataLen = wcslen((wchar_t *)data);
            void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t));
            if (dest == NULL) {exit(-1);}
            (void)wcscpy(dest, data);
            printWLine((wchar_t *)dest);
            free(dest);
        }
    }
}
static void goodG2B1()
{
    void * data;
    data = NULL;
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char * dataGoodBuffer = (char *)malloc(50*sizeof(char));
            if (dataGoodBuffer == NULL) {exit(-1);}
            memset(dataGoodBuffer, 'A', 50-1);
            dataGoodBuffer[50-1] = '\0';
            data = (void *)dataGoodBuffer;
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)calloc(dataLen+1, 1);
            if (dest == NULL) {exit(-1);}
            (void)strcpy(dest, data);
            printLine((char *)dest);
            free(dest);
        }
    }
}
static void goodG2B2()
{
    void * data;
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        {
            char * dataGoodBuffer = (char *)malloc(50*sizeof(char));
            if (dataGoodBuffer == NULL) {exit(-1);}
            memset(dataGoodBuffer, 'A', 50-1);
            dataGoodBuffer[50-1] = '\0';
            data = (void *)dataGoodBuffer;
        }
    }
    if(GLOBAL_CONST_TRUE)
    {
        {
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)calloc(dataLen+1, 1);
            if (dest == NULL) {exit(-1);}
            (void)strcpy(dest, data);
            printLine((char *)dest);
            free(dest);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_snprintf_52a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var(char * data);
void var()
{
    char * data;
    data = NULL;
    data = (char *)malloc(50*sizeof(char));
    data[0] = '\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
static void goodG2B()
{
    char * data;
    data = NULL;
    data = (char *)malloc(100*sizeof(char));
    data[0] = '\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_07.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
static int staticFive = 5;
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    if(staticFive==5)
    {
        data = (char *)malloc(50*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcpy(data, source);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = NULL;
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcpy(data, source);
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = NULL;
    if(staticFive==5)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcpy(data, source);
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_src_wchar_t_cpy_64b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;
    wchar_t * data = (*dataPtr);
    {
        wchar_t dest[50] = L"""";
        wcscpy(dest, data);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;
    wchar_t * data = (*dataPtr);
    {
        wchar_t dest[50] = L"""";
        wcscpy(dest, data);
        printWLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_06.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(STATIC_CONST_FIVE==5)
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(STATIC_CONST_FIVE==5)
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_64a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(void * dataVoidPtr);
void var()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr);
static void goodG2B()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_snprintf_63a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var(wchar_t * * dataPtr);
void var()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * * data);
static void goodG2B()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_loop_41.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
void var()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc(50*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
static void goodG2B()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_05.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void var()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    if(staticTrue)
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strcat(dest, data);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strcat(dest, data);
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    if(staticTrue)
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strcat(dest, data);
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncat_44.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
static void badSink(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncat(data, source, 100);
        printWLine(data);
        free(data);
    }
}
void var()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = badSink;
    data = NULL;
    data = (wchar_t *)malloc(50*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0'; 
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncat(data, source, 100);
        printWLine(data);
        free(data);
    }
}
static void goodG2B()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = goodG2BSink;
    data = NULL;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0'; 
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_64b.c,CWE122,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    int * dataPtr = (int *)dataVoidPtr;
    int data = (*dataPtr);
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    int * dataPtr = (int *)dataVoidPtr;
    int data = (*dataPtr);
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
void var(void * dataVoidPtr)
{
    int * dataPtr = (int *)dataVoidPtr;
    int data = (*dataPtr);
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
        free(buffer);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_63b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * * dataPtr)
{
    char * data = *dataPtr;
    {
        char dest[50] = """";
        strcat(dest, data);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * * dataPtr)
{
    char * data = *dataPtr;
    {
        char dest[50] = """";
        strcat(dest, data);
        printLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__CWE131_loop_16.c,CWE122,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int * data;
    data = NULL;
    while(1)
    {
        data = (int *)malloc(10);
        if (data == NULL) {exit(-1);}
        break;
    }
    {
        int source[10] = {0};
        size_t i;
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int * data;
    data = NULL;
    while(1)
    {
        data = (int *)malloc(10*sizeof(int));
        if (data == NULL) {exit(-1);}
        break;
    }
    {
        int source[10] = {0};
        size_t i;
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_64a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(void * dataVoidPtr);
void var()
{
    twoIntsStruct * data;
    data = NULL;
    data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr);
static void goodG2B()
{
    twoIntsStruct * data;
    data = NULL;
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memmove_54a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * data);
void var()
{
    int64_t * data;
    data = NULL;
    data = (int64_t *)malloc(50*sizeof(int64_t));
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t * data);
static void goodG2B()
{
    int64_t * data;
    data = NULL;
    data = (int64_t *)malloc(100*sizeof(int64_t));
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_51a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var()
{
    char * data;
    data = NULL;
    data = (char *)malloc(50*sizeof(char));
    data[0] = '\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
static void goodG2B()
{
    char * data;
    data = NULL;
    data = (char *)malloc(100*sizeof(char));
    data[0] = '\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cpy_66b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscpy(data, source);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscpy(data, source);
        printWLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_loop_12.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = (int64_t *)malloc(50*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
    }
    else
    {
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
    }
    {
        int64_t source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
            free(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int64_t * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
    }
    else
    {
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
    }
    {
        int64_t source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
            free(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_67a.c,CWE122,good,"#include ""std_testcase.h""
typedef struct _CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_67_structType
{
    twoIntsStruct * structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct);
void var()
{
    twoIntsStruct * data;
    var myStruct;
    data = NULL;
    data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));
    myStruct.structFirst = data;
    var(myStruct);
}
#endif 
#ifndef OMITGOOD
void var(var myStruct);
static void goodG2B()
{
    twoIntsStruct * data;
    var myStruct;
    data = NULL;
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    myStruct.structFirst = data;
    var(myStruct);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_loop_54a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(twoIntsStruct * data);
void var()
{
    twoIntsStruct * data;
    data = NULL;
    data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(twoIntsStruct * data);
static void goodG2B()
{
    twoIntsStruct * data;
    data = NULL;
    data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_14.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    twoIntsStruct * data;
    data = NULL;
    if(globalFive==5)
    {
        data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    twoIntsStruct * data;
    data = NULL;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
        free(data);
    }
}
static void goodG2B2()
{
    twoIntsStruct * data;
    data = NULL;
    if(globalFive==5)
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_05.c,CWE122,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticTrue)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = -1;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodB2G2()
{
    int data;
    data = -1;
    if(staticTrue)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(staticTrue)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodG2B1()
{
    int data;
    data = -1;
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 7;
    }
    if(staticTrue)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = -1;
    if(staticTrue)
    {
        data = 7;
    }
    if(staticTrue)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_54b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * data);
void var(int * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int * data);
void var(int * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_snprintf_64b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF swprintf
#endif
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;
    wchar_t * data = (*dataPtr);
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;
    wchar_t * data = (*dataPtr);
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_02.c,CWE122,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(1)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = -1;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodB2G2()
{
    int data;
    data = -1;
    if(1)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(1)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodG2B1()
{
    int data;
    data = -1;
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 7;
    }
    if(1)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = -1;
    if(1)
    {
        data = 7;
    }
    if(1)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_51b.c,CWE122,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data)
{
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
void var(int data)
{
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
        free(buffer);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_snprintf_10.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    if(globalTrue)
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    if(globalTrue)
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_snprintf_61b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
wchar_t * var(wchar_t * data)
{
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    return data;
}
#endif 
#ifndef OMITGOOD
wchar_t * var(wchar_t * data)
{
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    return data;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__CWE135_14.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    void * data;
    data = NULL;
    if(globalFive==5)
    {
        {
            wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));
            if (dataBadBuffer == NULL) {exit(-1);}
            wmemset(dataBadBuffer, L'A', 50-1);
            dataBadBuffer[50-1] = L'\0';
            data = (void *)dataBadBuffer;
        }
    }
    if(globalFive==5)
    {
        {
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t));
            if (dest == NULL) {exit(-1);}
            (void)wcscpy(dest, data);
            printLine((char *)dest);
            free(dest);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    void * data;
    data = NULL;
    if(globalFive==5)
    {
        {
            wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));
            if (dataBadBuffer == NULL) {exit(-1);}
            wmemset(dataBadBuffer, L'A', 50-1);
            dataBadBuffer[50-1] = L'\0';
            data = (void *)dataBadBuffer;
        }
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            size_t dataLen = wcslen((wchar_t *)data);
            void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t));
            if (dest == NULL) {exit(-1);}
            (void)wcscpy(dest, data);
            printWLine((wchar_t *)dest);
            free(dest);
        }
    }
}
static void goodB2G2()
{
    void * data;
    data = NULL;
    if(globalFive==5)
    {
        {
            wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));
            if (dataBadBuffer == NULL) {exit(-1);}
            wmemset(dataBadBuffer, L'A', 50-1);
            dataBadBuffer[50-1] = L'\0';
            data = (void *)dataBadBuffer;
        }
    }
    if(globalFive==5)
    {
        {
            size_t dataLen = wcslen((wchar_t *)data);
            void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t));
            if (dest == NULL) {exit(-1);}
            (void)wcscpy(dest, data);
            printWLine((wchar_t *)dest);
            free(dest);
        }
    }
}
static void goodG2B1()
{
    void * data;
    data = NULL;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            char * dataGoodBuffer = (char *)malloc(50*sizeof(char));
            if (dataGoodBuffer == NULL) {exit(-1);}
            memset(dataGoodBuffer, 'A', 50-1);
            dataGoodBuffer[50-1] = '\0';
            data = (void *)dataGoodBuffer;
        }
    }
    if(globalFive==5)
    {
        {
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)calloc(dataLen+1, 1);
            if (dest == NULL) {exit(-1);}
            (void)strcpy(dest, data);
            printLine((char *)dest);
            free(dest);
        }
    }
}
static void goodG2B2()
{
    void * data;
    data = NULL;
    if(globalFive==5)
    {
        {
            char * dataGoodBuffer = (char *)malloc(50*sizeof(char));
            if (dataGoodBuffer == NULL) {exit(-1);}
            memset(dataGoodBuffer, 'A', 50-1);
            dataGoodBuffer[50-1] = '\0';
            data = (void *)dataGoodBuffer;
        }
    }
    if(globalFive==5)
    {
        {
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)calloc(dataLen+1, 1);
            if (dest == NULL) {exit(-1);}
            (void)strcpy(dest, data);
            printLine((char *)dest);
            free(dest);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_10.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    if(globalTrue)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(globalTrue)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = -1;
    if(globalTrue)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodB2G2()
{
    int data;
    data = -1;
    if(globalTrue)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(globalTrue)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodG2B1()
{
    int data;
    data = -1;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 7;
    }
    if(globalTrue)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = -1;
    if(globalTrue)
    {
        data = 7;
    }
    if(globalTrue)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncat_51a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc(50*sizeof(wchar_t));
    data[0] = L'\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    data[0] = L'\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_16.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STR L""0123456789abcdef0123456789abcde""
typedef struct _charVoid
{
    wchar_t charFirst[16];
    void * voidSecond;
    void * voidThird;
} charVoid;
#ifndef OMITBAD
void var()
{
    while(1)
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            printWLine((wchar_t *)structCharVoid->voidSecond);
            memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; 
            printWLine((wchar_t *)structCharVoid->charFirst);
            printWLine((wchar_t *)structCharVoid->voidSecond);
        }
        break;
    }
}
#endif 
#ifndef OMITGOOD
static void good1()
{
    while(1)
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            printWLine((wchar_t *)structCharVoid->voidSecond);
            memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; 
            printWLine((wchar_t *)structCharVoid->charFirst);
            printWLine((wchar_t *)structCharVoid->voidSecond);
        }
        break;
    }
}
void var()
{
    good1();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cpy_04.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
static const int STATIC_CONST_TRUE = 1; 
static const int STATIC_CONST_FALSE = 0; 
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        data = (wchar_t *)malloc(50*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscpy(data, source);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = NULL;
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscpy(data, source);
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscpy(data, source);
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_src_wchar_t_cat_53d.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        wcscat(dest, data);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        wcscat(dest, data);
        printWLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_loop_53a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_68b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
extern wchar_t * var;
extern wchar_t * var;
#ifndef OMITBAD
void var()
{
    wchar_t * data = var;
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    wchar_t * data = var;
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memmove_52a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * data);
void var()
{
    int64_t * data;
    data = NULL;
    data = (int64_t *)malloc(50*sizeof(int64_t));
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t * data);
static void goodG2B()
{
    int64_t * data;
    data = NULL;
    data = (int64_t *)malloc(100*sizeof(int64_t));
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncat_63b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncat(data, source, 100);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncat(data, source, 100);
        printWLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_snprintf_65a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var(wchar_t * data);
void var()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = var;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = var;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_snprintf_08.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF swprintf
#endif
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        data = (wchar_t *)malloc(50*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = NULL;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__sizeof_int64_t_54a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * data);
void var()
{
    int64_t * data;
    data = NULL;
    data = (int64_t *)malloc(sizeof(data));
    *data = 2147483643LL;
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t * data);
static void goodG2B()
{
    int64_t * data;
    data = NULL;
    data = (int64_t *)malloc(sizeof(*data));
    *data = 2147483643LL;
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__CWE135_21.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
static int badStatic = 0;
static void badSink(void * data)
{
    if(badStatic)
    {
        {
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t));
            if (dest == NULL) {exit(-1);}
            (void)wcscpy(dest, data);
            printLine((char *)dest);
            free(dest);
        }
    }
}
void var()
{
    void * data;
    data = NULL;
    {
        wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));
        if (dataBadBuffer == NULL) {exit(-1);}
        wmemset(dataBadBuffer, L'A', 50-1);
        dataBadBuffer[50-1] = L'\0';
        data = (void *)dataBadBuffer;
    }
    badStatic = 1; 
    badSink(data);
}
#endif 
#ifndef OMITGOOD
static int goodB2G1Static = 0;
static int goodB2G2Static = 0;
static int goodG2BStatic = 0;
static void goodB2G1Sink(void * data)
{
    if(goodB2G1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            size_t dataLen = wcslen((wchar_t *)data);
            void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t));
            if (dest == NULL) {exit(-1);}
            (void)wcscpy(dest, data);
            printWLine((wchar_t *)dest);
            free(dest);
        }
    }
}
static void goodB2G1()
{
    void * data;
    data = NULL;
    {
        wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));
        if (dataBadBuffer == NULL) {exit(-1);}
        wmemset(dataBadBuffer, L'A', 50-1);
        dataBadBuffer[50-1] = L'\0';
        data = (void *)dataBadBuffer;
    }
    goodB2G1Static = 0; 
    goodB2G1Sink(data);
}
static void goodB2G2Sink(void * data)
{
    if(goodB2G2Static)
    {
        {
            size_t dataLen = wcslen((wchar_t *)data);
            void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t));
            if (dest == NULL) {exit(-1);}
            (void)wcscpy(dest, data);
            printWLine((wchar_t *)dest);
            free(dest);
        }
    }
}
static void goodB2G2()
{
    void * data;
    data = NULL;
    {
        wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));
        if (dataBadBuffer == NULL) {exit(-1);}
        wmemset(dataBadBuffer, L'A', 50-1);
        dataBadBuffer[50-1] = L'\0';
        data = (void *)dataBadBuffer;
    }
    goodB2G2Static = 1; 
    goodB2G2Sink(data);
}
static void goodG2BSink(void * data)
{
    if(goodG2BStatic)
    {
        {
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)calloc(dataLen+1, 1);
            if (dest == NULL) {exit(-1);}
            (void)strcpy(dest, data);
            printLine((char *)dest);
            free(dest);
        }
    }
}
static void goodG2B()
{
    void * data;
    data = NULL;
    {
        char * dataGoodBuffer = (char *)malloc(50*sizeof(char));
        if (dataGoodBuffer == NULL) {exit(-1);}
        memset(dataGoodBuffer, 'A', 50-1);
        dataGoodBuffer[50-1] = '\0';
        data = (void *)dataGoodBuffer;
    }
    goodG2BStatic = 1; 
    goodG2BSink(data);
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncpy_64b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    char * * dataPtr = (char * *)dataVoidPtr;
    char * data = (*dataPtr);
    {
        char dest[50] = """";
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    char * * dataPtr = (char * *)dataVoidPtr;
    char * data = (*dataPtr);
    {
        char dest[50] = """";
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_loop_05.c,CWE122,good,"#include ""std_testcase.h""
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void var()
{
    int * data;
    data = NULL;
    if(staticTrue)
    {
        data = (int *)malloc(50*sizeof(int));
        if (data == NULL) {exit(-1);}
    }
    {
        int source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            free(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    int * data;
    data = NULL;
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
    }
    {
        int source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            free(data);
        }
    }
}
static void goodG2B2()
{
    int * data;
    data = NULL;
    if(staticTrue)
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
    }
    {
        int source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            free(data);
        }
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_large_63b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * dataPtr)
{
    int data = *dataPtr;
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
#endif 
#ifndef OMITGOOD
void var(int * dataPtr)
{
    int data = *dataPtr;
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
void var(int * dataPtr)
{
    int data = *dataPtr;
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
        free(buffer);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cat_22a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
int var = 0;
wchar_t * var(wchar_t * data);
void var()
{
    wchar_t * data;
    data = NULL;
    var = 1; 
    data = var(data);
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscat(data, source);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
int var = 0;
int var = 0;
wchar_t * var(wchar_t * data);
static void goodG2B1()
{
    wchar_t * data;
    data = NULL;
    var = 0; 
    data = var(data);
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscat(data, source);
        printWLine(data);
        free(data);
    }
}
wchar_t * var(wchar_t * data);
static void goodG2B2()
{
    wchar_t * data;
    data = NULL;
    var = 1; 
    data = var(data);
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscat(data, source);
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_07.c,CWE122,bad,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
static int staticFive = 5;
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    if(staticFive==5)
    {
        data = (char *)malloc(10*sizeof(char));
        if (data == NULL) {exit(-1);}
    }
    {
        char source[10+1] = SRC_STRING;
        memmove(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = NULL;
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (char *)malloc((10+1)*sizeof(char));
        if (data == NULL) {exit(-1);}
    }
    {
        char source[10+1] = SRC_STRING;
        memmove(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = NULL;
    if(staticFive==5)
    {
        data = (char *)malloc((10+1)*sizeof(char));
        if (data == NULL) {exit(-1);}
    }
    {
        char source[10+1] = SRC_STRING;
        memmove(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_loop_16.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    while(1)
    {
        data = (char *)malloc(10*sizeof(char));
        if (data == NULL) {exit(-1);}
        break;
    }
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    data = NULL;
    while(1)
    {
        data = (char *)malloc((10+1)*sizeof(char));
        if (data == NULL) {exit(-1);}
        break;
    }
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_snprintf_42.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF swprintf
#endif
#ifndef OMITBAD
static wchar_t * badSource(wchar_t * data)
{
    data = (wchar_t *)malloc(50*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0'; 
    return data;
}
void var()
{
    wchar_t * data;
    data = NULL;
    data = badSource(data);
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static wchar_t * goodG2BSource(wchar_t * data)
{
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0'; 
    return data;
}
static void goodG2B()
{
    wchar_t * data;
    data = NULL;
    data = goodG2BSource(data);
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_loop_54b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_61b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
wchar_t * var(wchar_t * data)
{
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    return data;
}
#endif 
#ifndef OMITGOOD
wchar_t * var(wchar_t * data)
{
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    return data;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_loop_18.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    goto source;
source:
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    {
        char dest[50] = """";
        size_t i, dataLen;
        dataLen = strlen(data);
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    goto source;
source:
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    {
        char dest[50] = """";
        size_t i, dataLen;
        dataLen = strlen(data);
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_loop_09.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        data = (char *)malloc(10*sizeof(char));
        if (data == NULL) {exit(-1);}
    }
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = NULL;
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (char *)malloc((10+1)*sizeof(char));
        if (data == NULL) {exit(-1);}
    }
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        data = (char *)malloc((10+1)*sizeof(char));
        if (data == NULL) {exit(-1);}
    }
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncpy_32.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    {
        char * data = *dataPtr1;
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char dest[50] = """";
            strncpy(dest, data, strlen(data));
            dest[50-1] = '\0'; 
            printLine(data);
            free(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    {
        char * data = *dataPtr1;
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char dest[50] = """";
            strncpy(dest, data, strlen(data));
            dest[50-1] = '\0'; 
            printLine(data);
            free(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncat_44.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
static void badSink(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
void var()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = badSink;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
static void goodG2B()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = goodG2BSink;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__sizeof_int64_t_52a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * data);
void var()
{
    int64_t * data;
    data = NULL;
    data = (int64_t *)malloc(sizeof(data));
    *data = 2147483643LL;
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t * data);
static void goodG2B()
{
    int64_t * data;
    data = NULL;
    data = (int64_t *)malloc(sizeof(*data));
    *data = 2147483643LL;
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_12.c,CWE122,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = (char *)malloc(50*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    else
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    else
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_61b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
char * var(char * data)
{
    data = (char *)malloc(50*sizeof(char));
    if (data == NULL) {exit(-1);}
    data[0] = '\0'; 
    return data;
}
#endif 
#ifndef OMITGOOD
char * var(char * data)
{
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    data[0] = '\0'; 
    return data;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_loop_03.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int * data;
    data = NULL;
    if(5==5)
    {
        data = (int *)malloc(50*sizeof(int));
        if (data == NULL) {exit(-1);}
    }
    {
        int source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            free(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    int * data;
    data = NULL;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
    }
    {
        int source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            free(data);
        }
    }
}
static void goodG2B2()
{
    int * data;
    data = NULL;
    if(5==5)
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
    }
    {
        int source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            free(data);
        }
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_42.c,CWE122,bad,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
static char * badSource(char * data)
{
    data = (char *)malloc(10*sizeof(char));
    if (data == NULL) {exit(-1);}
    return data;
}
void var()
{
    char * data;
    data = NULL;
    data = badSource(data);
    {
        char source[10+1] = SRC_STRING;
        memmove(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static char * goodG2BSource(char * data)
{
    data = (char *)malloc((10+1)*sizeof(char));
    if (data == NULL) {exit(-1);}
    return data;
}
static void goodG2B()
{
    char * data;
    data = NULL;
    data = goodG2BSource(data);
    {
        char source[10+1] = SRC_STRING;
        memmove(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cpy_12.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = (wchar_t *)malloc(50*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    else
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscpy(data, source);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    else
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscpy(data, source);
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_snprintf_17.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF swprintf
#endif
#ifndef OMITBAD
void var()
{
    int i;
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    for(i = 0; i < 1; i++)
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int h;
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    for(h = 0; h < 1; h++)
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cpy_53d.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscpy(data, source);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscpy(data, source);
        printWLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_loop_54a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
static void goodG2B()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cat_53a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc(50*sizeof(wchar_t));
    data[0] = L'\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    data[0] = L'\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_67a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
typedef struct _CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_67_structType
{
    char * structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct);
void var()
{
    char * data;
    var myStruct;
    data = NULL;
    data = (char *)malloc(10*sizeof(char));
    myStruct.structFirst = data;
    var(myStruct);
}
#endif 
#ifndef OMITGOOD
void var(var myStruct);
static void goodG2B()
{
    char * data;
    var myStruct;
    data = NULL;
    data = (char *)malloc((10+1)*sizeof(char));
    myStruct.structFirst = data;
    var(myStruct);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_09.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    twoIntsStruct * data;
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    twoIntsStruct * data;
    data = NULL;
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
        free(data);
    }
}
static void goodG2B2()
{
    twoIntsStruct * data;
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_66b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * dataArray[])
{
    char * data = dataArray[2];
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncat(data, source, 100);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * dataArray[])
{
    char * data = dataArray[2];
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncat(data, source, 100);
        printLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_51b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data)
{
    {
        char dest[50] = """";
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * data)
{
    {
        char dest[50] = """";
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_53a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cpy_67a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
typedef struct _CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cpy_67_structType
{
    wchar_t * structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct);
void var()
{
    wchar_t * data;
    var myStruct;
    data = NULL;
    data = (wchar_t *)malloc(50*sizeof(wchar_t));
    data[0] = L'\0'; 
    myStruct.structFirst = data;
    var(myStruct);
}
#endif 
#ifndef OMITGOOD
void var(var myStruct);
static void goodG2B()
{
    wchar_t * data;
    var myStruct;
    data = NULL;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    data[0] = L'\0'; 
    myStruct.structFirst = data;
    var(myStruct);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_large_32.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    data = -1;
    {
        int data = *dataPtr1;
        data = 10;
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    data = -1;
    {
        int data = *dataPtr1;
        data = 7;
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
static void goodB2G()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    data = -1;
    {
        int data = *dataPtr1;
        data = 10;
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_loop_67b.c,CWE122,good,"#include ""std_testcase.h""
typedef struct _CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_loop_67_structType
{
    twoIntsStruct * structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct)
{
    twoIntsStruct * data = myStruct.structFirst;
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printStructLine(&data[0]);
            free(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
void var(var myStruct)
{
    twoIntsStruct * data = myStruct.structFirst;
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printStructLine(&data[0]);
            free(data);
        }
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_52b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(twoIntsStruct * data);
void var(twoIntsStruct * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(twoIntsStruct * data);
void var(twoIntsStruct * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_63a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * * dataPtr);
void var()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(char * * data);
static void goodG2B()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_63b.c,CWE122,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int * dataPtr)
{
    int data = *dataPtr;
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
#endif 
#ifndef OMITGOOD
void var(int * dataPtr)
{
    int data = *dataPtr;
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
void var(int * dataPtr)
{
    int data = *dataPtr;
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
        free(buffer);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_09.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        data = (char *)malloc(50*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcpy(data, source);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = NULL;
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcpy(data, source);
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = NULL;
    if(GLOBAL_CONST_TRUE)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcpy(data, source);
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncat_06.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = (wchar_t *)malloc(50*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncat(data, source, 100);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = NULL;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncat(data, source, 100);
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncat(data, source, 100);
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_53d.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data)
{
    {
        char dest[50] = """";
        strcat(dest, data);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * data)
{
    {
        char dest[50] = """";
        strcat(dest, data);
        printLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_snprintf_34.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF swprintf
#endif
typedef union
{
    wchar_t * unionFirst;
    wchar_t * unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    var myUnion;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t dest[50] = L"""";
            SNPRINTF(dest, wcslen(data), L""%s"", data);
            printWLine(data);
            free(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    var myUnion;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t dest[50] = L"""";
            SNPRINTF(dest, wcslen(data), L""%s"", data);
            printWLine(data);
            free(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncpy_67b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
typedef struct _CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncpy_67_structType
{
    wchar_t * structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncpy(data, source, 100-1);
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(var myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncpy(data, source, 100-1);
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_07.c,CWE122,bad,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
static int staticFive = 5;
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = NULL;
    if(staticFive==5)
    {
        data = (wchar_t *)malloc(10*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = NULL;
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = NULL;
    if(staticFive==5)
    {
        data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_41.c,CWE122,bad,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(char * data)
{
    {
        char source[10+1] = SRC_STRING;
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
        free(data);
    }
}
void var()
{
    char * data;
    data = NULL;
    data = (char *)malloc(10*sizeof(char));
    if (data == NULL) {exit(-1);}
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data)
{
    {
        char source[10+1] = SRC_STRING;
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
        free(data);
    }
}
static void goodG2B()
{
    char * data;
    data = NULL;
    data = (char *)malloc((10+1)*sizeof(char));
    if (data == NULL) {exit(-1);}
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_53c.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__CWE131_loop_17.c,CWE122,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int i;
    int * data;
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        data = (int *)malloc(10);
        if (data == NULL) {exit(-1);}
    }
    {
        int source[10] = {0};
        size_t i;
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int h;
    int * data;
    data = NULL;
    for(h = 0; h < 1; h++)
    {
        data = (int *)malloc(10*sizeof(int));
        if (data == NULL) {exit(-1);}
    }
    {
        int source[10] = {0};
        size_t i;
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_34.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
typedef union
{
    char * unionFirst;
    char * unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    char * data;
    var myUnion;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char dest[50] = """";
            memmove(dest, data, strlen(data)*sizeof(char));
            dest[50-1] = '\0'; 
            printLine(data);
            free(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    var myUnion;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char dest[50] = """";
            memmove(dest, data, strlen(data)*sizeof(char));
            dest[50-1] = '\0'; 
            printLine(data);
            free(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_63b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(char * * dataPtr)
{
    char * data = *dataPtr;
    {
        char source[10+1] = SRC_STRING;
        strcpy(data, source);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * * dataPtr)
{
    char * data = *dataPtr;
    {
        char source[10+1] = SRC_STRING;
        strcpy(data, source);
        printLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncpy_18.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    goto source;
source:
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    {
        char dest[50] = """";
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    goto source;
source:
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    {
        char dest[50] = """";
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_10.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    twoIntsStruct * data;
    data = NULL;
    if(globalTrue)
    {
        data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    twoIntsStruct * data;
    data = NULL;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
        free(data);
    }
}
static void goodG2B2()
{
    twoIntsStruct * data;
    data = NULL;
    if(globalTrue)
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_53a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * data);
void var()
{
    int * data;
    data = NULL;
    data = (int *)malloc(50*sizeof(int));
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int * data);
static void goodG2B()
{
    int * data;
    data = NULL;
    data = (int *)malloc(100*sizeof(int));
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_loop_03.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    if(5==5)
    {
        data = (char *)malloc(10*sizeof(char));
        if (data == NULL) {exit(-1);}
    }
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = NULL;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (char *)malloc((10+1)*sizeof(char));
        if (data == NULL) {exit(-1);}
    }
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = NULL;
    if(5==5)
    {
        data = (char *)malloc((10+1)*sizeof(char));
        if (data == NULL) {exit(-1);}
    }
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_34.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
typedef union
{
    wchar_t * unionFirst;
    wchar_t * unionSecond;
} var;
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    var myUnion;
    data = NULL;
    data = (wchar_t *)malloc(50*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0'; 
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); 
            source[100-1] = L'\0'; 
            memmove(data, source, 100*sizeof(wchar_t));
            data[100-1] = L'\0'; 
            printWLine(data);
            free(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    var myUnion;
    data = NULL;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0'; 
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); 
            source[100-1] = L'\0'; 
            memmove(data, source, 100*sizeof(wchar_t));
            data[100-1] = L'\0'; 
            printWLine(data);
            free(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_rand_53b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_53b.c,CWE122,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_53d.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data)
{
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * data)
{
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_11.c,CWE122,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int * data;
    data = NULL;
    if(globalReturnsTrue())
    {
        data = (int *)malloc(10);
        if (data == NULL) {exit(-1);}
    }
    {
        int source[10] = {0};
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    int * data;
    data = NULL;
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (int *)malloc(10*sizeof(int));
        if (data == NULL) {exit(-1);}
    }
    {
        int source[10] = {0};
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
static void goodG2B2()
{
    int * data;
    data = NULL;
    if(globalReturnsTrue())
    {
        data = (int *)malloc(10*sizeof(int));
        if (data == NULL) {exit(-1);}
    }
    {
        int source[10] = {0};
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_52b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * data);
void var(int * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int * data);
void var(int * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_53d.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data)
{
    {
        char dest[50] = """";
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * data)
{
    {
        char dest[50] = """";
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_loop_52c.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_51b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data)
{
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncat(data, source, 100);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * data)
{
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncat(data, source, 100);
        printLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_66b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_07.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
static int staticFive = 5;
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(staticFive==5)
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(staticFive==5)
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_09.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STR L""0123456789abcdef0123456789abcde""
typedef struct _charVoid
{
    wchar_t charFirst[16];
    void * voidSecond;
    void * voidThird;
} charVoid;
#ifndef OMITBAD
void var()
{
    if(GLOBAL_CONST_TRUE)
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            printWLine((wchar_t *)structCharVoid->voidSecond);
            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; 
            printWLine((wchar_t *)structCharVoid->charFirst);
            printWLine((wchar_t *)structCharVoid->voidSecond);
            free(structCharVoid);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void good1()
{
    if(GLOBAL_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            printWLine((wchar_t *)structCharVoid->voidSecond);
            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; 
            printWLine((wchar_t *)structCharVoid->charFirst);
            printWLine((wchar_t *)structCharVoid->voidSecond);
            free(structCharVoid);
        }
    }
}
static void good2()
{
    if(GLOBAL_CONST_TRUE)
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            printWLine((wchar_t *)structCharVoid->voidSecond);
            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; 
            printWLine((wchar_t *)structCharVoid->charFirst);
            printWLine((wchar_t *)structCharVoid->voidSecond);
            free(structCharVoid);
        }
    }
}
void var()
{
    good1();
    good2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memcpy_21.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
static int badStatic = 0;
static int64_t * badSource(int64_t * data)
{
    if(badStatic)
    {
        data = (int64_t *)malloc(50*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
    }
    return data;
}
void var()
{
    int64_t * data;
    data = NULL;
    badStatic = 1; 
    data = badSource(data);
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static int goodG2B1Static = 0;
static int goodG2B2Static = 0;
static int64_t * goodG2B1Source(int64_t * data)
{
    if(goodG2B1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
    }
    return data;
}
static void goodG2B1()
{
    int64_t * data;
    data = NULL;
    goodG2B1Static = 0; 
    data = goodG2B1Source(data);
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        free(data);
    }
}
static int64_t * goodG2B2Source(int64_t * data)
{
    if(goodG2B2Static)
    {
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
    }
    return data;
}
static void goodG2B2()
{
    int64_t * data;
    data = NULL;
    goodG2B2Static = 1; 
    data = goodG2B2Source(data);
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_16.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    twoIntsStruct * data;
    data = NULL;
    while(1)
    {
        data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        break;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    twoIntsStruct * data;
    data = NULL;
    while(1)
    {
        data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
        if (data == NULL) {exit(-1);}
        break;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_52b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int data);
void var(int data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int data);
void var(int data)
{
    var(data);
}
void var(int data);
void var(int data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_loop_16.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int * data;
    data = NULL;
    while(1)
    {
        data = (int *)malloc(50*sizeof(int));
        if (data == NULL) {exit(-1);}
        break;
    }
    {
        int source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            free(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int * data;
    data = NULL;
    while(1)
    {
        data = (int *)malloc(100*sizeof(int));
        if (data == NULL) {exit(-1);}
        break;
    }
    {
        int source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            free(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_loop_52c.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        size_t i, dataLen;
        dataLen = wcslen(data);
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        size_t i, dataLen;
        dataLen = wcslen(data);
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_61a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
int * var(int * data);
void var()
{
    int * data;
    data = NULL;
    data = var(data);
    {
        int source[10] = {0};
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
int * var(int * data);
static void goodG2B()
{
    int * data;
    data = NULL;
    data = var(data);
    {
        int source[10] = {0};
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_loop_64a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(void * dataVoidPtr);
void var()
{
    char * data;
    data = NULL;
    data = (char *)malloc(10*sizeof(char));
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr);
static void goodG2B()
{
    char * data;
    data = NULL;
    data = (char *)malloc((10+1)*sizeof(char));
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_54b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_src_wchar_t_cpy_53d.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        wcscpy(dest, data);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        wcscpy(dest, data);
        printWLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_snprintf_08.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    if(staticReturnsTrue())
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    if(staticReturnsTrue())
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_loop_51b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * data)
{
    {
        int source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            free(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
void var(int * data)
{
    {
        int source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            free(data);
        }
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_68a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
wchar_t * var;
wchar_t * var;
#ifndef OMITBAD
void var();
void var()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc(10*sizeof(wchar_t));
    var = data;
    var();
}
#endif 
#ifndef OMITGOOD
void var();
static void goodG2B()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
    var = data;
    var();
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__sizeof_double_64b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    double * * dataPtr = (double * *)dataVoidPtr;
    double * data = (*dataPtr);
    printDoubleLine(*data);
    free(data);
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    double * * dataPtr = (double * *)dataVoidPtr;
    double * data = (*dataPtr);
    printDoubleLine(*data);
    free(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_loop_54a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var(wchar_t * data);
void var()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc(10*sizeof(wchar_t));
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_67b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
typedef struct _CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_67_structType
{
    char * structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct)
{
    char * data = myStruct.structFirst;
    {
        char dest[50] = """";
        strcpy(dest, data);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(var myStruct)
{
    char * data = myStruct.structFirst;
    {
        char dest[50] = """";
        strcpy(dest, data);
        printLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_rand_06.c,CWE122,good,"#include ""std_testcase.h""
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    if(STATIC_CONST_FIVE==5)
    {
        data = RAND32();
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = -1;
    if(STATIC_CONST_FIVE==5)
    {
        data = RAND32();
    }
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodB2G2()
{
    int data;
    data = -1;
    if(STATIC_CONST_FIVE==5)
    {
        data = RAND32();
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodG2B1()
{
    int data;
    data = -1;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 7;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = -1;
    if(STATIC_CONST_FIVE==5)
    {
        data = 7;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memmove_13.c,CWE122,bad,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STR ""0123456789abcdef0123456789abcde""
typedef struct _charVoid
{
    char charFirst[16];
    void * voidSecond;
    void * voidThird;
} charVoid;
#ifndef OMITBAD
void var()
{
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            printLine((char *)structCharVoid->voidSecond);
            memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; 
            printLine((char *)structCharVoid->charFirst);
            printLine((char *)structCharVoid->voidSecond);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void good1()
{
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            printLine((char *)structCharVoid->voidSecond);
            memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; 
            printLine((char *)structCharVoid->charFirst);
            printLine((char *)structCharVoid->voidSecond);
        }
    }
}
static void good2()
{
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            printLine((char *)structCharVoid->voidSecond);
            memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; 
            printLine((char *)structCharVoid->charFirst);
            printLine((char *)structCharVoid->voidSecond);
        }
    }
}
void var()
{
    good1();
    good2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_31.c,CWE122,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int data;
    data = -1;
    data = 7;
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
static void goodB2G()
{
    int data;
    data = -1;
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET connectSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (connectSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
            service.sin_port = htons(TCP_PORT);
            if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (connectSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(connectSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_52b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * data);
void var(int * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int * data);
void var(int * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_snprintf_04.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF swprintf
#endif
static const int STATIC_CONST_TRUE = 1; 
static const int STATIC_CONST_FALSE = 0; 
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(STATIC_CONST_TRUE)
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(STATIC_CONST_TRUE)
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__CWE131_loop_45.c,CWE122,bad,"#include ""std_testcase.h""
static int * var;
static int * var;
#ifndef OMITBAD
static void badSink()
{
    int * data = var;
    {
        int source[10] = {0};
        size_t i;
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
        free(data);
    }
}
void var()
{
    int * data;
    data = NULL;
    data = (int *)malloc(10);
    if (data == NULL) {exit(-1);}
    var = data;
    badSink();
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink()
{
    int * data = var;
    {
        int source[10] = {0};
        size_t i;
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
        free(data);
    }
}
static void goodG2B()
{
    int * data;
    data = NULL;
    data = (int *)malloc(10*sizeof(int));
    if (data == NULL) {exit(-1);}
    var = data;
    goodG2BSink();
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_05.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void var()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    if(staticTrue)
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    if(staticTrue)
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    {
        char dest[50] = """";
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_snprintf_64a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snprintf
#else
#define SNPRINTF snprintf
#endif
#ifndef OMITBAD
void var(void * dataVoidPtr);
void var()
{
    char * data;
    data = NULL;
    data = (char *)malloc(50*sizeof(char));
    data[0] = '\0'; 
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr);
static void goodG2B()
{
    char * data;
    data = NULL;
    data = (char *)malloc(100*sizeof(char));
    data[0] = '\0'; 
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memmove_66b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * dataArray[])
{
    int64_t * data = dataArray[2];
    {
        int64_t source[100] = {0}; 
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(int64_t * dataArray[])
{
    int64_t * data = dataArray[2];
    {
        int64_t source[100] = {0}; 
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_loop_05.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(staticTrue)
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        size_t i, dataLen;
        dataLen = wcslen(data);
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        size_t i, dataLen;
        dataLen = wcslen(data);
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(staticTrue)
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        size_t i, dataLen;
        dataLen = wcslen(data);
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_54b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_05.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(staticTrue)
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(staticTrue)
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_snprintf_06.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF swprintf
#endif
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(STATIC_CONST_FIVE==5)
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(STATIC_CONST_FIVE==5)
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_11.c,CWE122,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsTrue())
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = -1;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodB2G2()
{
    int data;
    data = -1;
    if(globalReturnsTrue())
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalReturnsTrue())
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodG2B1()
{
    int data;
    data = -1;
    if(globalReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 7;
    }
    if(globalReturnsTrue())
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = -1;
    if(globalReturnsTrue())
    {
        data = 7;
    }
    if(globalReturnsTrue())
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memcpy_68b.c,CWE122,good,"#include ""std_testcase.h""
extern int64_t * var;
extern int64_t * var;
#ifndef OMITBAD
void var()
{
    int64_t * data = var;
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    int64_t * data = var;
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_22b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
extern int var;
char * var(char * data)
{
    if(var)
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    return data;
}
#endif 
#ifndef OMITGOOD
extern int var;
extern int var;
char * var(char * data)
{
    if(var)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    return data;
}
char * var(char * data)
{
    if(var)
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    return data;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_53a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc(50*sizeof(wchar_t));
    data[0] = L'\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    data[0] = L'\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_16.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    while(1)
    {
        data = (char *)malloc(50*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
        break;
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcpy(data, source);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    data = NULL;
    while(1)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
        break;
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcpy(data, source);
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_68b.c,CWE122,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
extern int var;
extern int var;
extern int var;
#ifndef OMITBAD
void var()
{
    int data = var;
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    int data = var;
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
void var()
{
    int data = var;
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
        free(buffer);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__CWE135_54d.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(void * data);
void var(void * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(void * data);
void var(void * data)
{
    var(data);
}
void var(void * data);
void var(void * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_03.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(5==5)
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(5==5)
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_08.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        data = (char *)malloc(10*sizeof(char));
        if (data == NULL) {exit(-1);}
    }
    {
        char source[10+1] = SRC_STRING;
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = NULL;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (char *)malloc((10+1)*sizeof(char));
        if (data == NULL) {exit(-1);}
    }
    {
        char source[10+1] = SRC_STRING;
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        data = (char *)malloc((10+1)*sizeof(char));
        if (data == NULL) {exit(-1);}
    }
    {
        char source[10+1] = SRC_STRING;
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_64b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(void * dataVoidPtr)
{
    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;
    wchar_t * data = (*dataPtr);
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(void * dataVoidPtr)
{
    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;
    wchar_t * data = (*dataPtr);
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_loop_66b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_snprintf_12.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF swprintf
#endif
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(globalReturnsTrueOrFalse())
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(globalReturnsTrueOrFalse())
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memcpy_14.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t * data;
    data = NULL;
    if(globalFive==5)
    {
        data = (int64_t *)malloc(50*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
    }
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    int64_t * data;
    data = NULL;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
    }
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        free(data);
    }
}
static void goodG2B2()
{
    int64_t * data;
    data = NULL;
    if(globalFive==5)
    {
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
    }
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_loop_05.c,CWE122,bad,"#include ""std_testcase.h""
#include <wchar.h>
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    if(staticTrue)
    {
        data = (char *)malloc(50*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = NULL;
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = NULL;
    if(staticTrue)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_07.c,CWE122,bad,"#include ""std_testcase.h""
#include <wchar.h>
static int staticFive = 5;
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    if(staticFive==5)
    {
        data = (char *)malloc(50*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = NULL;
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = NULL;
    if(staticFive==5)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_loop_54e.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(twoIntsStruct * data)
{
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printStructLine(&data[0]);
            free(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
void var(twoIntsStruct * data)
{
    {
        twoIntsStruct source[100];
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printStructLine(&data[0]);
            free(data);
        }
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncpy_54e.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncpy(data, source, 100-1);
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncpy(data, source, 100-1);
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_13.c,CWE122,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = -1;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodB2G2()
{
    int data;
    data = -1;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET connectSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (connectSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
                service.sin_port = htons(TCP_PORT);
                if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (connectSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(connectSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodG2B1()
{
    int data;
    data = -1;
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 7;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = -1;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = 7;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_68b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
extern char * var;
extern char * var;
#ifndef OMITBAD
void var()
{
    char * data = var;
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var()
{
    char * data = var;
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_loop_67a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
typedef struct _CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_loop_67_structType
{
    char * structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct);
void var()
{
    char * data;
    var myStruct;
    data = (char *)malloc(100*sizeof(char));
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    myStruct.structFirst = data;
    var(myStruct);
}
#endif 
#ifndef OMITGOOD
void var(var myStruct);
static void goodG2B()
{
    char * data;
    var myStruct;
    data = (char *)malloc(100*sizeof(char));
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    myStruct.structFirst = data;
    var(myStruct);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memmove_12.c,CWE122,bad,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STR ""0123456789abcdef0123456789abcde""
typedef struct _charVoid
{
    char charFirst[16];
    void * voidSecond;
    void * voidThird;
} charVoid;
#ifndef OMITBAD
void var()
{
    if(globalReturnsTrueOrFalse())
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            printLine((char *)structCharVoid->voidSecond);
            memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; 
            printLine((char *)structCharVoid->charFirst);
            printLine((char *)structCharVoid->voidSecond);
        }
    }
    else
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            printLine((char *)structCharVoid->voidSecond);
            memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; 
            printLine((char *)structCharVoid->charFirst);
            printLine((char *)structCharVoid->voidSecond);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void good1()
{
    if(globalReturnsTrueOrFalse())
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            printLine((char *)structCharVoid->voidSecond);
            memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; 
            printLine((char *)structCharVoid->charFirst);
            printLine((char *)structCharVoid->voidSecond);
        }
    }
    else
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            printLine((char *)structCharVoid->voidSecond);
            memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; 
            printLine((char *)structCharVoid->charFirst);
            printLine((char *)structCharVoid->voidSecond);
        }
    }
}
void var()
{
    good1();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_loop_53d.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * data)
{
    {
        int64_t source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
            free(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
void var(int64_t * data)
{
    {
        int64_t source[100] = {0}; 
        {
            size_t i;
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
            free(data);
        }
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_loop_21.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
static int badStatic = 0;
static char * badSource(char * data)
{
    if(badStatic)
    {
        data = (char *)malloc(10*sizeof(char));
        if (data == NULL) {exit(-1);}
    }
    return data;
}
void var()
{
    char * data;
    data = NULL;
    badStatic = 1; 
    data = badSource(data);
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static int goodG2B1Static = 0;
static int goodG2B2Static = 0;
static char * goodG2B1Source(char * data)
{
    if(goodG2B1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (char *)malloc((10+1)*sizeof(char));
        if (data == NULL) {exit(-1);}
    }
    return data;
}
static void goodG2B1()
{
    char * data;
    data = NULL;
    goodG2B1Static = 0; 
    data = goodG2B1Source(data);
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
        free(data);
    }
}
static char * goodG2B2Source(char * data)
{
    if(goodG2B2Static)
    {
        data = (char *)malloc((10+1)*sizeof(char));
        if (data == NULL) {exit(-1);}
    }
    return data;
}
static void goodG2B2()
{
    char * data;
    data = NULL;
    goodG2B2Static = 1; 
    data = goodG2B2Source(data);
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncat_54e.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_07.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
static int staticFive = 5;
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(staticFive==5)
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(staticFive==5)
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memmove_54c.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * data);
void var(int64_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int64_t * data);
void var(int64_t * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_18.c,CWE122,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    goto source;
source:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    goto sink;
sink:
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int data;
    data = -1;
    goto source;
source:
    {
#ifdef _WIN32
        WSADATA wsaData;
        int wsaDataInit = 0;
#endif
        int recvResult;
        struct sockaddr_in service;
        SOCKET listenSocket = INVALID_SOCKET;
        SOCKET acceptSocket = INVALID_SOCKET;
        char inputBuffer[CHAR_ARRAY_SIZE];
        do
        {
#ifdef _WIN32
            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
            {
                break;
            }
            wsaDataInit = 1;
#endif
            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (listenSocket == INVALID_SOCKET)
            {
                break;
            }
            memset(&service, 0, sizeof(service));
            service.sin_family = AF_INET;
            service.sin_addr.s_addr = INADDR_ANY;
            service.sin_port = htons(TCP_PORT);
            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
            {
                break;
            }
            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
            {
                break;
            }
            acceptSocket = accept(listenSocket, NULL, NULL);
            if (acceptSocket == SOCKET_ERROR)
            {
                break;
            }
            recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
            if (recvResult == SOCKET_ERROR || recvResult == 0)
            {
                break;
            }
            inputBuffer[recvResult] = '\0';
            data = atoi(inputBuffer);
        }
        while (0);
        if (listenSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(listenSocket);
        }
        if (acceptSocket != INVALID_SOCKET)
        {
            CLOSE_SOCKET(acceptSocket);
        }
#ifdef _WIN32
        if (wsaDataInit)
        {
            WSACleanup();
        }
#endif
    }
    goto sink;
sink:
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
        free(buffer);
    }
}
static void goodG2B()
{
    int data;
    data = -1;
    goto source;
source:
    data = 7;
    goto sink;
sink:
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cat_68a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
wchar_t * var;
wchar_t * var;
#ifndef OMITBAD
void var();
void var()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc(50*sizeof(wchar_t));
    data[0] = L'\0'; 
    var = data;
    var();
}
#endif 
#ifndef OMITGOOD
void var();
static void goodG2B()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    data[0] = L'\0'; 
    var = data;
    var();
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncat_54b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_loop_06.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(STATIC_CONST_FIVE==5)
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        size_t i, dataLen;
        dataLen = wcslen(data);
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        size_t i, dataLen;
        dataLen = wcslen(data);
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(STATIC_CONST_FIVE==5)
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        size_t i, dataLen;
        dataLen = wcslen(data);
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_10.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    if(globalTrue)
    {
        data = (char *)malloc(50*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcpy(data, source);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = NULL;
    if(globalFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcpy(data, source);
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = NULL;
    if(globalTrue)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcpy(data, source);
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_66a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * dataArray[]);
void var()
{
    char * data;
    char * dataArray[5];
    data = (char *)malloc(100*sizeof(char));
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    dataArray[2] = data;
    var(dataArray);
}
#endif 
#ifndef OMITGOOD
void var(char * dataArray[]);
static void goodG2B()
{
    char * data;
    char * dataArray[5];
    data = (char *)malloc(100*sizeof(char));
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    dataArray[2] = data;
    var(dataArray);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_51a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var()
{
    char * data;
    data = NULL;
    data = (char *)malloc(50*sizeof(char));
    data[0] = '\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
static void goodG2B()
{
    char * data;
    data = NULL;
    data = (char *)malloc(100*sizeof(char));
    data[0] = '\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_53a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
static void goodG2B()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memmove_65b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * data)
{
    {
        int64_t source[100] = {0}; 
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(int64_t * data)
{
    {
        int64_t source[100] = {0}; 
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_src_wchar_t_cat_53a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_ncpy_12.c,CWE122,bad,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = (wchar_t *)malloc(10*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
    }
    else
    {
        data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        wcsncpy(data, source, wcslen(source) + 1);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
    }
    else
    {
        data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        wcsncpy(data, source, wcslen(source) + 1);
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_52a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var(char * data);
void var()
{
    char * data;
    data = NULL;
    data = (char *)malloc(10*sizeof(char));
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
static void goodG2B()
{
    char * data;
    data = NULL;
    data = (char *)malloc((10+1)*sizeof(char));
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_65a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var()
{
    char * data;
    void (*funcPtr) (char *) = var;
    data = NULL;
    data = (char *)malloc(50*sizeof(char));
    data[0] = '\0'; 
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
static void goodG2B()
{
    char * data;
    void (*funcPtr) (char *) = var;
    data = NULL;
    data = (char *)malloc(100*sizeof(char));
    data[0] = '\0'; 
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_large_66b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int dataArray[])
{
    int data = dataArray[2];
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
#endif 
#ifndef OMITGOOD
void var(int dataArray[])
{
    int data = dataArray[2];
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
void var(int dataArray[])
{
    int data = dataArray[2];
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
        free(buffer);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_15.c,CWE122,bad,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int * data;
    data = NULL;
    switch(6)
    {
    case 6:
        data = (int *)malloc(10);
        if (data == NULL) {exit(-1);}
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        int source[10] = {0};
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    int * data;
    data = NULL;
    switch(5)
    {
    case 6:
        printLine(""Benign, fixed string"");
        break;
    default:
        data = (int *)malloc(10*sizeof(int));
        if (data == NULL) {exit(-1);}
        break;
    }
    {
        int source[10] = {0};
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
static void goodG2B2()
{
    int * data;
    data = NULL;
    switch(6)
    {
    case 6:
        data = (int *)malloc(10*sizeof(int));
        if (data == NULL) {exit(-1);}
        break;
    default:
        printLine(""Benign, fixed string"");
        break;
    }
    {
        int source[10] = {0};
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_03.c,CWE122,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    if(5==5)
    {
        data = (char *)malloc(50*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = NULL;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = NULL;
    if(5==5)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_06.c,CWE122,good,"#include ""std_testcase.h""
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    if(STATIC_CONST_FIVE==5)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = -1;
    if(STATIC_CONST_FIVE==5)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodB2G2()
{
    int data;
    data = -1;
    if(STATIC_CONST_FIVE==5)
    {
        fscanf(stdin, ""%d"", &data);
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodG2B1()
{
    int data;
    data = -1;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 7;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = -1;
    if(STATIC_CONST_FIVE==5)
    {
        data = 7;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cpy_06.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = (wchar_t *)malloc(50*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscpy(data, source);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = NULL;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscpy(data, source);
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscpy(data, source);
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_01.c,CWE122,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    data = (char *)malloc(50*sizeof(char));
    if (data == NULL) {exit(-1);}
    data[0] = '\0'; 
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    data = NULL;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    data[0] = '\0'; 
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_52b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_loop_54a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var()
{
    char * data;
    data = NULL;
    data = (char *)malloc(50*sizeof(char));
    data[0] = '\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
static void goodG2B()
{
    char * data;
    data = NULL;
    data = (char *)malloc(100*sizeof(char));
    data[0] = '\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncat_05.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
static int staticTrue = 1; 
static int staticFalse = 0; 
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = NULL;
    if(staticTrue)
    {
        data = (wchar_t *)malloc(50*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncat(data, source, 100);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = NULL;
    if(staticFalse)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncat(data, source, 100);
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = NULL;
    if(staticTrue)
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncat(data, source, 100);
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cpy_17.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    int i;
    wchar_t * data;
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        data = (wchar_t *)malloc(50*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscpy(data, source);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int h;
    wchar_t * data;
    data = NULL;
    for(h = 0; h < 1; h++)
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscpy(data, source);
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncpy_67a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
typedef struct _CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncpy_67_structType
{
    char * structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct);
void var()
{
    char * data;
    var myStruct;
    data = (char *)malloc(100*sizeof(char));
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    myStruct.structFirst = data;
    var(myStruct);
}
#endif 
#ifndef OMITGOOD
void var(var myStruct);
static void goodG2B()
{
    char * data;
    var myStruct;
    data = (char *)malloc(100*sizeof(char));
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    myStruct.structFirst = data;
    var(myStruct);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_44.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
static void badSink(char * data)
{
    {
        char dest[50] = """";
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
void var()
{
    char * data;
    void (*funcPtr) (char *) = badSink;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(char * data)
{
    {
        char dest[50] = """";
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
static void goodG2B()
{
    char * data;
    void (*funcPtr) (char *) = goodG2BSink;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_13.c,CWE122,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = -1;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodB2G2()
{
    int data;
    data = -1;
    if(GLOBAL_CONST_FIVE==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodG2B1()
{
    int data;
    data = -1;
    if(GLOBAL_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 7;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = -1;
    if(GLOBAL_CONST_FIVE==5)
    {
        data = 7;
    }
    if(GLOBAL_CONST_FIVE==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_14.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = NULL;
    if(globalFive==5)
    {
        data = (wchar_t *)malloc(50*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memmove(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = NULL;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memmove(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = NULL;
    if(globalFive==5)
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memmove(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_18.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    goto source;
source:
    data = (char *)malloc(50*sizeof(char));
    if (data == NULL) {exit(-1);}
    data[0] = '\0'; 
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcat(data, source);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    data = NULL;
    goto source;
source:
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    data[0] = '\0'; 
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strcat(data, source);
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_loop_53b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * data);
void var(int * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int * data);
void var(int * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_31.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    data = (char *)malloc(10*sizeof(char));
    if (data == NULL) {exit(-1);}
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            char source[10+1] = SRC_STRING;
            strcpy(data, source);
            printLine(data);
            free(data);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    data = NULL;
    data = (char *)malloc((10+1)*sizeof(char));
    if (data == NULL) {exit(-1);}
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            char source[10+1] = SRC_STRING;
            strcpy(data, source);
            printLine(data);
            free(data);
        }
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_53b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(twoIntsStruct * data);
void var(twoIntsStruct * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(twoIntsStruct * data);
void var(twoIntsStruct * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__sizeof_struct_63a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(twoIntsStruct * * dataPtr);
void var()
{
    twoIntsStruct * data;
    data = NULL;
    data = (twoIntsStruct *)malloc(sizeof(data));
    data->intOne = 1;
    data->intTwo = 2;
    var(&data);
}
#endif 
#ifndef OMITGOOD
void var(twoIntsStruct * * data);
static void goodG2B()
{
    twoIntsStruct * data;
    data = NULL;
    data = (twoIntsStruct *)malloc(sizeof(*data));
    data->intOne = 1;
    data->intTwo = 2;
    var(&data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_17.c,CWE122,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int i,j;
    int data;
    data = -1;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    for(j = 0; j < 1; j++)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G()
{
    int i,k;
    int data;
    data = -1;
    for(i = 0; i < 1; i++)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    for(k = 0; k < 1; k++)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodG2B()
{
    int h,j;
    int data;
    data = -1;
    for(h = 0; h < 1; h++)
    {
        data = 7;
    }
    for(j = 0; j < 1; j++)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
void var()
{
    goodB2G();
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_snprintf_67a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifdef _WIN32
#define SNPRINTF _snwprintf
#else
#define SNPRINTF snprintf
#endif
typedef struct _CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_snprintf_67_structType
{
    wchar_t * structFirst;
} var;
#ifndef OMITBAD
void var(var myStruct);
void var()
{
    wchar_t * data;
    var myStruct;
    data = NULL;
    data = (wchar_t *)malloc(50*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0'; 
    myStruct.structFirst = data;
    var(myStruct);
}
#endif 
#ifndef OMITGOOD
void var(var myStruct);
static void goodG2B()
{
    wchar_t * data;
    var myStruct;
    data = NULL;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0'; 
    myStruct.structFirst = data;
    var(myStruct);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_ncpy_51a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    wmemset(data, L'A', 100-1); 
    data[100-1] = L'\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    wmemset(data, L'A', 50-1); 
    data[50-1] = L'\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__sizeof_double_07.c,CWE122,good,"#include ""std_testcase.h""
static int staticFive = 5;
#ifndef OMITBAD
void var()
{
    double * data;
    data = NULL;
    if(staticFive==5)
    {
        data = (double *)malloc(sizeof(data));
        if (data == NULL) {exit(-1);}
        *data = 1.7E300;
    }
    printDoubleLine(*data);
    free(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    double * data;
    data = NULL;
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (double *)malloc(sizeof(*data));
        if (data == NULL) {exit(-1);}
        *data = 1.7E300;
    }
    printDoubleLine(*data);
    free(data);
}
static void goodG2B2()
{
    double * data;
    data = NULL;
    if(staticFive==5)
    {
        data = (double *)malloc(sizeof(*data));
        if (data == NULL) {exit(-1);}
        *data = 1.7E300;
    }
    printDoubleLine(*data);
    free(data);
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_31.c,CWE122,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int data;
    data = -1;
    data = 7;
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
static void goodB2G()
{
    int data;
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_14.c,CWE122,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define LISTEN_BACKLOG 5
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFive==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = -1;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodB2G2()
{
    int data;
    data = -1;
    if(globalFive==5)
    {
        {
#ifdef _WIN32
            WSADATA wsaData;
            int wsaDataInit = 0;
#endif
            int recvResult;
            struct sockaddr_in service;
            SOCKET listenSocket = INVALID_SOCKET;
            SOCKET acceptSocket = INVALID_SOCKET;
            char inputBuffer[CHAR_ARRAY_SIZE];
            do
            {
#ifdef _WIN32
                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
                {
                    break;
                }
                wsaDataInit = 1;
#endif
                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (listenSocket == INVALID_SOCKET)
                {
                    break;
                }
                memset(&service, 0, sizeof(service));
                service.sin_family = AF_INET;
                service.sin_addr.s_addr = INADDR_ANY;
                service.sin_port = htons(TCP_PORT);
                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
                {
                    break;
                }
                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
                {
                    break;
                }
                acceptSocket = accept(listenSocket, NULL, NULL);
                if (acceptSocket == SOCKET_ERROR)
                {
                    break;
                }
                recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
                if (recvResult == SOCKET_ERROR || recvResult == 0)
                {
                    break;
                }
                inputBuffer[recvResult] = '\0';
                data = atoi(inputBuffer);
            }
            while (0);
            if (listenSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(listenSocket);
            }
            if (acceptSocket != INVALID_SOCKET)
            {
                CLOSE_SOCKET(acceptSocket);
            }
#ifdef _WIN32
            if (wsaDataInit)
            {
                WSACleanup();
            }
#endif
        }
    }
    if(globalFive==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodG2B1()
{
    int data;
    data = -1;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 7;
    }
    if(globalFive==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = -1;
    if(globalFive==5)
    {
        data = 7;
    }
    if(globalFive==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_44.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
static void badSink(char * data)
{
    {
        char dest[50] = """";
        strcat(dest, data);
        printLine(data);
        free(data);
    }
}
void var()
{
    char * data;
    void (*funcPtr) (char *) = badSink;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    memset(data, 'A', 100-1); 
    data[100-1] = '\0'; 
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(char * data)
{
    {
        char dest[50] = """";
        strcat(dest, data);
        printLine(data);
        free(data);
    }
}
static void goodG2B()
{
    char * data;
    void (*funcPtr) (char *) = goodG2BSink;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    memset(data, 'A', 50-1); 
    data[50-1] = '\0'; 
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_21.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
static int badStatic = 0;
static char * badSource(char * data)
{
    if(badStatic)
    {
        memset(data, 'A', 100-1); 
        data[100-1] = '\0'; 
    }
    return data;
}
void var()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    badStatic = 1; 
    data = badSource(data);
    {
        char dest[50] = """";
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static int goodG2B1Static = 0;
static int goodG2B2Static = 0;
static char * goodG2B1Source(char * data)
{
    if(goodG2B1Static)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    return data;
}
static void goodG2B1()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    goodG2B1Static = 0; 
    data = goodG2B1Source(data);
    {
        char dest[50] = """";
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
static char * goodG2B2Source(char * data)
{
    if(goodG2B2Static)
    {
        memset(data, 'A', 50-1); 
        data[50-1] = '\0'; 
    }
    return data;
}
static void goodG2B2()
{
    char * data;
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    goodG2B2Static = 1; 
    data = goodG2B2Source(data);
    {
        char dest[50] = """";
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncpy_53a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc(50*sizeof(wchar_t));
    data[0] = L'\0'; 
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    data[0] = L'\0'; 
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cat_06.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = (wchar_t *)malloc(50*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscat(data, source);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = NULL;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscat(data, source);
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = (wchar_t *)malloc(100*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
        data[0] = L'\0'; 
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcscat(data, source);
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncpy_44.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
static void badSink(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncpy(data, source, 100-1);
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
void var()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = badSink;
    data = NULL;
    data = (wchar_t *)malloc(50*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0'; 
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        wcsncpy(data, source, 100-1);
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
static void goodG2B()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = goodG2BSink;
    data = NULL;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0'; 
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memcpy_51b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int64_t * data)
{
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(int64_t * data)
{
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_03.c,CWE122,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    if(5==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(5==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = -1;
    if(5==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodB2G2()
{
    int data;
    data = -1;
    if(5==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(5==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodG2B1()
{
    int data;
    data = -1;
    if(5!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 7;
    }
    if(5==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = -1;
    if(5==5)
    {
        data = 7;
    }
    if(5==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_02.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(1)
    {
        wmemset(data, L'A', 100-1); 
        data[100-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        memmove(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(0)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        memmove(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    if(1)
    {
        wmemset(data, L'A', 50-1); 
        data[50-1] = L'\0'; 
    }
    {
        wchar_t dest[50] = L"""";
        memmove(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_ncpy_06.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = (wchar_t *)malloc(10*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        wcsncpy(data, source, wcslen(source) + 1);
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    wchar_t * data;
    data = NULL;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        wcsncpy(data, source, wcslen(source) + 1);
        printWLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    wchar_t * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
        if (data == NULL) {exit(-1);}
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        wcsncpy(data, source, wcslen(source) + 1);
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_61a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
char * var(char * data);
void var()
{
    char * data;
    data = NULL;
    data = var(data);
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
char * var(char * data);
static void goodG2B()
{
    char * data;
    data = NULL;
    data = var(data);
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_44.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
static void badSink(int * data)
{
    {
        int source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
void var()
{
    int * data;
    void (*funcPtr) (int *) = badSink;
    data = NULL;
    data = (int *)malloc(50*sizeof(int));
    if (data == NULL) {exit(-1);}
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(int * data)
{
    {
        int source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
static void goodG2B()
{
    int * data;
    void (*funcPtr) (int *) = goodG2BSink;
    data = NULL;
    data = (int *)malloc(100*sizeof(int));
    if (data == NULL) {exit(-1);}
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_54e.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * data)
{
    {
        int source[100] = {0}; 
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(int * data)
{
    {
        int source[100] = {0}; 
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_08.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
static int staticReturnsTrue()
{
    return 1;
}
static int staticReturnsFalse()
{
    return 0;
}
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        data = (char *)malloc(50*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncat(data, source, 100);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = NULL;
    if(staticReturnsFalse())
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncat(data, source, 100);
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncat(data, source, 100);
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_04.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
static const int STATIC_CONST_TRUE = 1; 
static const int STATIC_CONST_FALSE = 0; 
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        data = (char *)malloc(50*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = NULL;
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_loop_54b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__CWE135_65a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(void * data);
void var()
{
    void * data;
    void (*funcPtr) (void *) = var;
    data = NULL;
    {
        wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));
        if (dataBadBuffer == NULL) {exit(-1);}
        wmemset(dataBadBuffer, L'A', 50-1);
        dataBadBuffer[50-1] = L'\0';
        data = (void *)dataBadBuffer;
    }
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
void var(void * data);
static void goodG2B()
{
    void * data;
    void (*funcPtr) (void *) = var;
    data = NULL;
    {
        char * dataGoodBuffer = (char *)malloc(50*sizeof(char));
        if (dataGoodBuffer == NULL) {exit(-1);}
        memset(dataGoodBuffer, 'A', 50-1);
        dataGoodBuffer[50-1] = '\0';
        data = (void *)dataGoodBuffer;
    }
    funcPtr(data);
}
void var(void * data);
static void goodB2G()
{
    void * data;
    void (*funcPtr) (void *) = var;
    data = NULL;
    {
        wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));
        if (dataBadBuffer == NULL) {exit(-1);}
        wmemset(dataBadBuffer, L'A', 50-1);
        dataBadBuffer[50-1] = L'\0';
        data = (void *)dataBadBuffer;
    }
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_22a.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
int var = 0;
wchar_t * var(wchar_t * data);
void var()
{
    wchar_t * data;
    data = NULL;
    var = 1; 
    data = var(data);
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memmove(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
int var = 0;
int var = 0;
wchar_t * var(wchar_t * data);
static void goodG2B1()
{
    wchar_t * data;
    data = NULL;
    var = 0; 
    data = var(data);
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memmove(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
wchar_t * var(wchar_t * data);
static void goodG2B2()
{
    wchar_t * data;
    data = NULL;
    var = 1; 
    data = var(data);
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memmove(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_52c.c,CWE122,good,"#include ""std_testcase.h""
#ifdef _WIN32
#include <winsock2.h>
#include <windows.h>
#include <direct.h>
#pragma comment(lib, ""ws2_32"") 
#define CLOSE_SOCKET closesocket
#else 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#define INVALID_SOCKET -1
#define SOCKET_ERROR -1
#define CLOSE_SOCKET close
#define SOCKET int
#endif
#define TCP_PORT 27015
#define IP_ADDRESS ""127.0.0.1""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
#ifndef OMITBAD
void var(int data)
{
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
#endif 
#ifndef OMITGOOD
void var(int data)
{
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
void var(int data)
{
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
        free(buffer);
    }
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__CWE135_52b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(void * data);
void var(void * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(void * data);
void var(void * data)
{
    var(data);
}
void var(void * data);
void var(void * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_61a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
int * var(int * data);
void var()
{
    int * data;
    data = NULL;
    data = var(data);
    {
        int source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
int * var(int * data);
static void goodG2B()
{
    int * data;
    data = NULL;
    data = var(data);
    {
        int source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cpy_53c.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
void var(wchar_t * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_rand_44.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
static void badSink(int data)
{
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
void var()
{
    int data;
    void (*funcPtr) (int) = badSink;
    data = -1;
    data = RAND32();
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(int data)
{
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0)
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        free(buffer);
    }
}
static void goodG2B()
{
    int data;
    void (*funcPtr) (int) = goodG2BSink;
    data = -1;
    data = 7;
    funcPtr(data);
}
static void goodB2GSink(int data)
{
    {
        int i;
        int * buffer = (int *)malloc(10 * sizeof(int));
        if (buffer == NULL) {exit(-1);}
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
        free(buffer);
    }
}
static void goodB2G()
{
    int data;
    void (*funcPtr) (int) = goodB2GSink;
    data = -1;
    data = RAND32();
    funcPtr(data);
}
void var()
{
    goodG2B();
    goodB2G();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_53c.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(char * data);
void var(char * data)
{
    var(data);
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_01.c,CWE122,bad,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc(10*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    {
        wchar_t source[10+1] = SRC_STRING;
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    {
        wchar_t source[10+1] = SRC_STRING;
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_ncpy_61b.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
wchar_t * var(wchar_t * data)
{
    data = (wchar_t *)malloc(10*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    return data;
}
#endif 
#ifndef OMITGOOD
wchar_t * var(wchar_t * data)
{
    data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    return data;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_07.c,CWE122,good,"#include ""std_testcase.h""
static int staticFive = 5;
#ifndef OMITBAD
void var()
{
    int * data;
    data = NULL;
    if(staticFive==5)
    {
        data = (int *)malloc(10);
        if (data == NULL) {exit(-1);}
    }
    {
        int source[10] = {0};
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    int * data;
    data = NULL;
    if(staticFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (int *)malloc(10*sizeof(int));
        if (data == NULL) {exit(-1);}
    }
    {
        int source[10] = {0};
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
static void goodG2B2()
{
    int * data;
    data = NULL;
    if(staticFive==5)
    {
        data = (int *)malloc(10*sizeof(int));
        if (data == NULL) {exit(-1);}
    }
    {
        int source[10] = {0};
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_loop_12.c,CWE122,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = (char *)malloc(50*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    else
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    char * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    else
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_51a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var(int * data);
void var()
{
    int * data;
    data = NULL;
    data = (int *)malloc(10);
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(int * data);
static void goodG2B()
{
    int * data;
    data = NULL;
    data = (int *)malloc(10*sizeof(int));
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_04.c,CWE122,good,"#include ""std_testcase.h""
#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2)
static const int STATIC_CONST_TRUE = 1; 
static const int STATIC_CONST_FALSE = 0; 
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    if(STATIC_CONST_TRUE)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(STATIC_CONST_TRUE)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = -1;
    if(STATIC_CONST_TRUE)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodB2G2()
{
    int data;
    data = -1;
    if(STATIC_CONST_TRUE)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(STATIC_CONST_TRUE)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodG2B1()
{
    int data;
    data = -1;
    if(STATIC_CONST_FALSE)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 7;
    }
    if(STATIC_CONST_TRUE)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = -1;
    if(STATIC_CONST_TRUE)
    {
        data = 7;
    }
    if(STATIC_CONST_TRUE)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_rand_14.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int data;
    data = -1;
    if(globalFive==5)
    {
        data = RAND32();
    }
    if(globalFive==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
#endif 
#ifndef OMITGOOD
static void goodB2G1()
{
    int data;
    data = -1;
    if(globalFive==5)
    {
        data = RAND32();
    }
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodB2G2()
{
    int data;
    data = -1;
    if(globalFive==5)
    {
        data = RAND32();
    }
    if(globalFive==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            free(buffer);
        }
    }
}
static void goodG2B1()
{
    int data;
    data = -1;
    if(globalFive!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = 7;
    }
    if(globalFive==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
static void goodG2B2()
{
    int data;
    data = -1;
    if(globalFive==5)
    {
        data = 7;
    }
    if(globalFive==5)
    {
        {
            int i;
            int * buffer = (int *)malloc(10 * sizeof(int));
            if (buffer == NULL) {exit(-1);}
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            if (data >= 0)
            {
                buffer[data] = 1;
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            free(buffer);
        }
    }
}
void var()
{
    goodB2G1();
    goodB2G2();
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_44.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
static void badSink(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
void var()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = badSink;
    data = NULL;
    data = (wchar_t *)malloc(50*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0'; 
    funcPtr(data);
}
#endif 
#ifndef OMITGOOD
static void goodG2BSink(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); 
        source[100-1] = L'\0'; 
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; 
        printWLine(data);
        free(data);
    }
}
static void goodG2B()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = goodG2BSink;
    data = NULL;
    data = (wchar_t *)malloc(100*sizeof(wchar_t));
    if (data == NULL) {exit(-1);}
    data[0] = L'\0'; 
    funcPtr(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_52a.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING L""AAAAAAAAAA""
#ifndef OMITBAD
void var(wchar_t * data);
void var()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc(10*sizeof(wchar_t));
    var(data);
}
#endif 
#ifndef OMITGOOD
void var(wchar_t * data);
static void goodG2B()
{
    wchar_t * data;
    data = NULL;
    data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
    var(data);
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_06.c,CWE122,good,"#include ""std_testcase.h""
#ifndef _WIN32
#include <wchar.h>
#endif
#define SRC_STRING ""AAAAAAAAAA""
static const int STATIC_CONST_FIVE = 5;
#ifndef OMITBAD
void var()
{
    char * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = (char *)malloc(10*sizeof(char));
        if (data == NULL) {exit(-1);}
    }
    {
        char source[10+1] = SRC_STRING;
        strcpy(data, source);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B1()
{
    char * data;
    data = NULL;
    if(STATIC_CONST_FIVE!=5)
    {
        printLine(""Benign, fixed string"");
    }
    else
    {
        data = (char *)malloc((10+1)*sizeof(char));
        if (data == NULL) {exit(-1);}
    }
    {
        char source[10+1] = SRC_STRING;
        strcpy(data, source);
        printLine(data);
        free(data);
    }
}
static void goodG2B2()
{
    char * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        data = (char *)malloc((10+1)*sizeof(char));
        if (data == NULL) {exit(-1);}
    }
    {
        char source[10+1] = SRC_STRING;
        strcpy(data, source);
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B1();
    goodG2B2();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_17.c,CWE122,bad,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var()
{
    int i;
    char * data;
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        data = (char *)malloc(50*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncat(data, source, 100);
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int h;
    char * data;
    data = NULL;
    for(h = 0; h < 1; h++)
    {
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        data[0] = '\0'; 
    }
    {
        char source[100];
        memset(source, 'C', 100-1); 
        source[100-1] = '\0'; 
        strncat(data, source, 100);
        printLine(data);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memcpy_12.c,CWE122,good,"#include ""std_testcase.h""
#ifndef OMITBAD
void var()
{
    int64_t * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = (int64_t *)malloc(50*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
    }
    else
    {
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
    }
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
static void goodG2B()
{
    int64_t * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
    }
    else
    {
        data = (int64_t *)malloc(100*sizeof(int64_t));
        if (data == NULL) {exit(-1);}
    }
    {
        int64_t source[100] = {0}; 
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        free(data);
    }
}
void var()
{
    goodG2B();
}
#endif 
#ifdef INCLUDEMAIN
int main(int argc, char * argv[])
{
    srand( (unsigned)time(NULL) );
#ifndef OMITGOOD
    printLine(""Calling good()..."");
    var();
    printLine(""Finished good()"");
#endif 
#ifndef OMITBAD
    printLine(""Calling bad()..."");
    var();
    printLine(""Finished bad()"");
#endif 
    return 0;
}
#endif"
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncpy_66b.c,CWE122,good,"#include ""std_testcase.h""
#include <wchar.h>
#ifndef OMITBAD
void var(char * dataArray[])
{
    char * data = dataArray[2];
    {
        char dest[50] = """";
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif 
#ifndef OMITGOOD
void var(char * dataArray[])
{
    char * data = dataArray[2];
    {
        char dest[50] = """";
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; 
        printLine(data);
        free(data);
    }
}
#endif"
synthetic_none_0.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_1.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_2.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_3.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_4.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_5.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_6.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_7.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_8.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_9.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_10.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_11.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_12.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_13.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_14.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_15.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_16.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_17.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_18.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_19.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_20.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_21.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_22.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_23.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_24.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_25.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_26.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_27.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_28.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_29.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_30.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_31.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_32.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_33.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_34.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_35.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_36.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_37.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_38.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_39.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_40.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_41.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_42.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_43.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_44.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_45.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_46.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_47.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_48.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_49.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_50.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_51.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_52.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_53.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_54.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_55.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_56.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_57.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_58.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_59.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_60.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_61.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_62.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_63.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_64.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_65.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_66.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_67.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_68.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_69.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_70.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_71.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_72.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_73.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_74.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_75.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_76.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_77.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_78.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_79.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_80.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_81.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_82.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_83.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_84.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_85.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_86.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_87.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_88.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_89.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_90.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_91.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_92.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_93.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_94.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_95.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_96.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_97.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_98.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_99.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_100.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_101.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_102.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_103.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_104.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_105.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_106.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_107.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_108.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_109.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_110.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_111.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_112.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_113.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_114.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_115.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_116.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_117.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_118.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_119.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_120.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_121.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_122.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_123.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_124.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_125.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_126.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_127.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_128.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_129.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_130.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_131.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_132.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_133.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_134.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_135.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_136.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_137.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_138.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_139.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_140.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_141.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_142.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_143.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_144.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_145.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_146.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_147.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_148.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_149.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_150.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_151.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_152.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_153.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_154.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_155.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_156.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_157.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_158.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_159.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_160.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_161.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_162.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_163.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_164.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_165.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_166.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_167.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_168.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_169.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_170.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_171.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_172.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_173.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_174.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_175.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_176.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_177.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_178.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_179.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_180.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_181.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_182.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_183.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_184.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_185.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_186.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_187.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_188.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_189.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_190.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_191.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_192.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_193.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_194.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_195.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_196.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_197.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_198.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_199.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_200.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_201.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_202.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_203.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_204.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_205.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_206.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_207.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_208.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_209.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_210.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_211.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_212.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_213.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_214.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_215.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_216.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_217.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_218.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_219.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_220.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_221.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_222.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_223.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_224.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_225.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_226.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_227.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_228.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_229.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_230.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_231.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_232.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_233.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_234.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_235.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_236.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_237.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_238.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_239.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_240.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_241.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_242.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_243.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_244.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_245.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_246.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_247.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_248.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_249.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_250.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_251.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_252.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_253.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_254.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_255.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_256.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_257.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_258.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_259.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_260.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_261.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_262.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_263.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_264.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_265.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_266.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_267.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_268.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_269.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_270.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_271.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_272.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_273.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_274.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_275.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_276.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_277.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_278.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_279.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_280.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_281.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_282.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_283.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_284.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_285.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_286.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_287.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_288.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_289.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_290.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_291.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_292.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_293.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_294.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_295.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_296.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_297.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_298.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_299.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_300.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_301.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_302.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_303.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_304.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_305.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_306.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_307.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_308.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_309.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_310.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_311.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_312.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_313.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_314.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_315.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_316.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_317.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_318.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_319.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_320.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_321.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_322.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_323.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_324.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_325.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_326.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_327.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_328.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_329.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_330.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_331.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_332.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_333.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_334.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_335.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_336.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_337.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_338.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_339.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_340.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_341.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_342.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_343.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_344.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_345.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_346.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_347.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_348.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_349.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_350.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_351.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_352.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_353.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_354.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_355.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_356.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_357.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_358.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_359.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_360.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_361.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_362.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_363.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_364.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_365.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_366.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_367.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_368.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_369.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_370.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_371.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_372.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_373.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_374.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_375.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_376.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_377.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_378.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_379.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_380.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_381.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_382.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_383.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_384.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_385.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_386.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_387.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_388.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_389.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_390.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_391.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_392.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_393.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_394.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
synthetic_none_395.c,none,,"int main() { printf(""Hello, World!""); return 0; }"
synthetic_none_396.c,none,,"void func() { int x = 5; printf(""%d"", x); }"
synthetic_none_397.c,none,,"int add(int a, int b) { return a + b; }"
synthetic_none_398.c,none,,"void loop() { for(int i = 0; i < 10; i++) { printf("".""); } }"
synthetic_none_399.c,none,,"int main() { char str[] = ""test""; puts(str); return 0; }"
